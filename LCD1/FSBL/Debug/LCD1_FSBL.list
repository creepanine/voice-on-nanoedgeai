
LCD1_FSBL.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34180400  34180400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002c1c  3418074c  3418074c  0000074c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  34183368  34183368  000043a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  34183368  34183368  000043a0  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  34183368  34183368  000043a0  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  34183368  34183368  000043a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  34183368  34183368  00003368  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  3418336c  3418336c  0000336c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         0000000c  341c0000  34183370  00004000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .noncacheable 00000004  341c000c  3418337c  0000400c  2**0
                  ALLOC
 10 .gnu.sgstubs  00000020  34183380  34183380  00004380  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .bss          00000020  341c0010  341c0010  00005010  2**2
                  ALLOC
 12 ._user_heap_stack 00000a00  341c0030  341c0030  00005010  2**0
                  ALLOC
 13 .ARM.attributes 0000003a  00000000  00000000  000043a0  2**0
                  CONTENTS, READONLY
 14 .debug_info   0000c28e  00000000  00000000  000043da  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 00001225  00000000  00000000  00010668  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00001278  00000000  00000000  00011890  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 00000de6  00000000  00000000  00012b08  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00001dbf  00000000  00000000  000138ee  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   0000d79a  00000000  00000000  000156ad  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    0022db6a  00000000  00000000  00022e47  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  002509b1  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00004c38  00000000  00000000  002509f4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_line_str 0000006b  00000000  00000000  0025562c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

3418074c <__do_global_dtors_aux>:
3418074c:	b510      	push	{r4, lr}
3418074e:	4c05      	ldr	r4, [pc, #20]	@ (34180764 <__do_global_dtors_aux+0x18>)
34180750:	7823      	ldrb	r3, [r4, #0]
34180752:	b933      	cbnz	r3, 34180762 <__do_global_dtors_aux+0x16>
34180754:	4b04      	ldr	r3, [pc, #16]	@ (34180768 <__do_global_dtors_aux+0x1c>)
34180756:	b113      	cbz	r3, 3418075e <__do_global_dtors_aux+0x12>
34180758:	4804      	ldr	r0, [pc, #16]	@ (3418076c <__do_global_dtors_aux+0x20>)
3418075a:	f3af 8000 	nop.w
3418075e:	2301      	movs	r3, #1
34180760:	7023      	strb	r3, [r4, #0]
34180762:	bd10      	pop	{r4, pc}
34180764:	341c0010 	.word	0x341c0010
34180768:	00000000 	.word	0x00000000
3418076c:	34183350 	.word	0x34183350

34180770 <frame_dummy>:
34180770:	b508      	push	{r3, lr}
34180772:	4b03      	ldr	r3, [pc, #12]	@ (34180780 <frame_dummy+0x10>)
34180774:	b11b      	cbz	r3, 3418077e <frame_dummy+0xe>
34180776:	4903      	ldr	r1, [pc, #12]	@ (34180784 <frame_dummy+0x14>)
34180778:	4803      	ldr	r0, [pc, #12]	@ (34180788 <frame_dummy+0x18>)
3418077a:	f3af 8000 	nop.w
3418077e:	bd08      	pop	{r3, pc}
34180780:	00000000 	.word	0x00000000
34180784:	341c0014 	.word	0x341c0014
34180788:	34183350 	.word	0x34183350

3418078c <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
3418078c:	b580      	push	{r7, lr}
3418078e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();
34180790:	f000 fbbb 	bl	34180f0a <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
34180794:	f000 f802 	bl	3418079c <SystemClock_Config>

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
34180798:	bf00      	nop
3418079a:	e7fd      	b.n	34180798 <main+0xc>

3418079c <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
3418079c:	b580      	push	{r7, lr}
3418079e:	b0b6      	sub	sp, #216	@ 0xd8
341807a0:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
341807a2:	f107 0340 	add.w	r3, r7, #64	@ 0x40
341807a6:	2298      	movs	r2, #152	@ 0x98
341807a8:	2100      	movs	r1, #0
341807aa:	4618      	mov	r0, r3
341807ac:	f002 fda4 	bl	341832f8 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
341807b0:	463b      	mov	r3, r7
341807b2:	2240      	movs	r2, #64	@ 0x40
341807b4:	2100      	movs	r1, #0
341807b6:	4618      	mov	r0, r3
341807b8:	f002 fd9e 	bl	341832f8 <memset>

  /** Configure the System Power Supply
  */
  if (HAL_PWREx_ConfigSupply(PWR_EXTERNAL_SOURCE_SUPPLY) != HAL_OK)
341807bc:	2000      	movs	r0, #0
341807be:	f000 fcf5 	bl	341811ac <HAL_PWREx_ConfigSupply>
341807c2:	4603      	mov	r3, r0
341807c4:	2b00      	cmp	r3, #0
341807c6:	d001      	beq.n	341807cc <SystemClock_Config+0x30>
  {
    Error_Handler();
341807c8:	f000 f88c 	bl	341808e4 <Error_Handler>
  }

  /* Enable HSI */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
341807cc:	2302      	movs	r3, #2
341807ce:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
341807d0:	2308      	movs	r3, #8
341807d2:	64fb      	str	r3, [r7, #76]	@ 0x4c
  RCC_OscInitStruct.HSIDiv = RCC_HSI_DIV1;
341807d4:	2300      	movs	r3, #0
341807d6:	653b      	str	r3, [r7, #80]	@ 0x50
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
341807d8:	2300      	movs	r3, #0
341807da:	657b      	str	r3, [r7, #84]	@ 0x54
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_NONE;
341807dc:	2300      	movs	r3, #0
341807de:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_NONE;
341807e0:	2300      	movs	r3, #0
341807e2:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_NONE;
341807e6:	2300      	movs	r3, #0
341807e8:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_NONE;
341807ec:	2300      	movs	r3, #0
341807ee:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
341807f2:	f107 0340 	add.w	r3, r7, #64	@ 0x40
341807f6:	4618      	mov	r0, r3
341807f8:	f000 ff6a 	bl	341816d0 <HAL_RCC_OscConfig>
341807fc:	4603      	mov	r3, r0
341807fe:	2b00      	cmp	r3, #0
34180800:	d001      	beq.n	34180806 <SystemClock_Config+0x6a>
  {
    Error_Handler();
34180802:	f000 f86f 	bl	341808e4 <Error_Handler>
  }

  /** Get current CPU/System buses clocks configuration and if necessary switch
 to intermediate HSI clock to ensure target clock can be set
  */
  HAL_RCC_GetClockConfig(&RCC_ClkInitStruct);
34180806:	463b      	mov	r3, r7
34180808:	4618      	mov	r0, r3
3418080a:	f001 fdc3 	bl	34182394 <HAL_RCC_GetClockConfig>
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
3418080e:	687b      	ldr	r3, [r7, #4]
34180810:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34180814:	d003      	beq.n	3418081e <SystemClock_Config+0x82>
     (RCC_ClkInitStruct.SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11))
34180816:	68bb      	ldr	r3, [r7, #8]
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
34180818:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3418081c:	d10e      	bne.n	3418083c <SystemClock_Config+0xa0>
  {
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK);
3418081e:	2303      	movs	r3, #3
34180820:	603b      	str	r3, [r7, #0]
    RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_HSI;
34180822:	2300      	movs	r3, #0
34180824:	607b      	str	r3, [r7, #4]
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
34180826:	2300      	movs	r3, #0
34180828:	60bb      	str	r3, [r7, #8]
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
3418082a:	463b      	mov	r3, r7
3418082c:	4618      	mov	r0, r3
3418082e:	f001 fb2f 	bl	34181e90 <HAL_RCC_ClockConfig>
34180832:	4603      	mov	r3, r0
34180834:	2b00      	cmp	r3, #0
34180836:	d001      	beq.n	3418083c <SystemClock_Config+0xa0>
    {
      /* Initialization Error */
      Error_Handler();
34180838:	f000 f854 	bl	341808e4 <Error_Handler>
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
3418083c:	2300      	movs	r3, #0
3418083e:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
34180840:	2302      	movs	r3, #2
34180842:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
34180844:	2300      	movs	r3, #0
34180846:	66fb      	str	r3, [r7, #108]	@ 0x6c
  RCC_OscInitStruct.PLL1.PLLM = 4;
34180848:	2304      	movs	r3, #4
3418084a:	673b      	str	r3, [r7, #112]	@ 0x70
  RCC_OscInitStruct.PLL1.PLLN = 75;
3418084c:	234b      	movs	r3, #75	@ 0x4b
3418084e:	67bb      	str	r3, [r7, #120]	@ 0x78
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
34180850:	2300      	movs	r3, #0
34180852:	677b      	str	r3, [r7, #116]	@ 0x74
  RCC_OscInitStruct.PLL1.PLLP1 = 1;
34180854:	2301      	movs	r3, #1
34180856:	67fb      	str	r3, [r7, #124]	@ 0x7c
  RCC_OscInitStruct.PLL1.PLLP2 = 1;
34180858:	2301      	movs	r3, #1
3418085a:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_NONE;
3418085e:	2300      	movs	r3, #0
34180860:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_NONE;
34180864:	2300      	movs	r3, #0
34180866:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_NONE;
3418086a:	2300      	movs	r3, #0
3418086c:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34180870:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34180874:	4618      	mov	r0, r3
34180876:	f000 ff2b 	bl	341816d0 <HAL_RCC_OscConfig>
3418087a:	4603      	mov	r3, r0
3418087c:	2b00      	cmp	r3, #0
3418087e:	d001      	beq.n	34180884 <SystemClock_Config+0xe8>
  {
    Error_Handler();
34180880:	f000 f830 	bl	341808e4 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_CPUCLK|RCC_CLOCKTYPE_HCLK
34180884:	237f      	movs	r3, #127	@ 0x7f
34180886:	603b      	str	r3, [r7, #0]
                              |RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
                              |RCC_CLOCKTYPE_PCLK2|RCC_CLOCKTYPE_PCLK5
                              |RCC_CLOCKTYPE_PCLK4;
  RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_IC1;
34180888:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
3418088c:	607b      	str	r3, [r7, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_IC2_IC6_IC11;
3418088e:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
34180892:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
34180894:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
34180898:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
3418089a:	2300      	movs	r3, #0
3418089c:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
3418089e:	2300      	movs	r3, #0
341808a0:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
341808a2:	2300      	movs	r3, #0
341808a4:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB5CLKDivider = RCC_APB5_DIV1;
341808a6:	2300      	movs	r3, #0
341808a8:	61fb      	str	r3, [r7, #28]
  RCC_ClkInitStruct.IC1Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
341808aa:	2300      	movs	r3, #0
341808ac:	623b      	str	r3, [r7, #32]
  RCC_ClkInitStruct.IC1Selection.ClockDivider = 2;
341808ae:	2302      	movs	r3, #2
341808b0:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_ClkInitStruct.IC2Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
341808b2:	2300      	movs	r3, #0
341808b4:	62bb      	str	r3, [r7, #40]	@ 0x28
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 3;
341808b6:	2303      	movs	r3, #3
341808b8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  RCC_ClkInitStruct.IC6Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
341808ba:	2300      	movs	r3, #0
341808bc:	633b      	str	r3, [r7, #48]	@ 0x30
  RCC_ClkInitStruct.IC6Selection.ClockDivider = 4;
341808be:	2304      	movs	r3, #4
341808c0:	637b      	str	r3, [r7, #52]	@ 0x34
  RCC_ClkInitStruct.IC11Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
341808c2:	2300      	movs	r3, #0
341808c4:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_ClkInitStruct.IC11Selection.ClockDivider = 3;
341808c6:	2303      	movs	r3, #3
341808c8:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
341808ca:	463b      	mov	r3, r7
341808cc:	4618      	mov	r0, r3
341808ce:	f001 fadf 	bl	34181e90 <HAL_RCC_ClockConfig>
341808d2:	4603      	mov	r3, r0
341808d4:	2b00      	cmp	r3, #0
341808d6:	d001      	beq.n	341808dc <SystemClock_Config+0x140>
  {
    Error_Handler();
341808d8:	f000 f804 	bl	341808e4 <Error_Handler>
  }
}
341808dc:	bf00      	nop
341808de:	37d8      	adds	r7, #216	@ 0xd8
341808e0:	46bd      	mov	sp, r7
341808e2:	bd80      	pop	{r7, pc}

341808e4 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
341808e4:	b480      	push	{r7}
341808e6:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
341808e8:	b672      	cpsid	i
}
341808ea:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
341808ec:	bf00      	nop
341808ee:	e7fd      	b.n	341808ec <Error_Handler+0x8>

341808f0 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
341808f0:	b480      	push	{r7}
341808f2:	af00      	add	r7, sp, #0
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
341808f4:	bf00      	nop
341808f6:	46bd      	mov	sp, r7
341808f8:	f85d 7b04 	ldr.w	r7, [sp], #4
341808fc:	4770      	bx	lr

341808fe <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
341808fe:	b480      	push	{r7}
34180900:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
34180902:	bf00      	nop
34180904:	e7fd      	b.n	34180902 <NMI_Handler+0x4>

34180906 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
34180906:	b480      	push	{r7}
34180908:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
3418090a:	bf00      	nop
3418090c:	e7fd      	b.n	3418090a <HardFault_Handler+0x4>

3418090e <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
3418090e:	b480      	push	{r7}
34180910:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
34180912:	bf00      	nop
34180914:	e7fd      	b.n	34180912 <MemManage_Handler+0x4>

34180916 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
34180916:	b480      	push	{r7}
34180918:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
3418091a:	bf00      	nop
3418091c:	e7fd      	b.n	3418091a <BusFault_Handler+0x4>

3418091e <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
3418091e:	b480      	push	{r7}
34180920:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
34180922:	bf00      	nop
34180924:	e7fd      	b.n	34180922 <UsageFault_Handler+0x4>

34180926 <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
34180926:	b480      	push	{r7}
34180928:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */

  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
3418092a:	bf00      	nop
3418092c:	e7fd      	b.n	3418092a <SecureFault_Handler+0x4>

3418092e <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
3418092e:	b480      	push	{r7}
34180930:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
34180932:	bf00      	nop
34180934:	46bd      	mov	sp, r7
34180936:	f85d 7b04 	ldr.w	r7, [sp], #4
3418093a:	4770      	bx	lr

3418093c <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
3418093c:	b480      	push	{r7}
3418093e:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
34180940:	bf00      	nop
34180942:	46bd      	mov	sp, r7
34180944:	f85d 7b04 	ldr.w	r7, [sp], #4
34180948:	4770      	bx	lr

3418094a <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
3418094a:	b480      	push	{r7}
3418094c:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
3418094e:	bf00      	nop
34180950:	46bd      	mov	sp, r7
34180952:	f85d 7b04 	ldr.w	r7, [sp], #4
34180956:	4770      	bx	lr

34180958 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
34180958:	b580      	push	{r7, lr}
3418095a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
3418095c:	f000 fb20 	bl	34180fa0 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
34180960:	bf00      	nop
34180962:	bd80      	pop	{r7, pc}

34180964 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
34180964:	b480      	push	{r7}
34180966:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
34180968:	4b6a      	ldr	r3, [pc, #424]	@ (34180b14 <SystemInit+0x1b0>)
3418096a:	4a6b      	ldr	r2, [pc, #428]	@ (34180b18 <SystemInit+0x1b4>)
3418096c:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* RNG reset */
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
3418096e:	4b6b      	ldr	r3, [pc, #428]	@ (34180b1c <SystemInit+0x1b8>)
34180970:	2201      	movs	r2, #1
34180972:	f8c3 2a18 	str.w	r2, [r3, #2584]	@ 0xa18
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
34180976:	4b69      	ldr	r3, [pc, #420]	@ (34180b1c <SystemInit+0x1b8>)
34180978:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418097c:	461a      	mov	r2, r3
3418097e:	2301      	movs	r3, #1
34180980:	f8c2 3218 	str.w	r3, [r2, #536]	@ 0x218
  /* Deactivate RNG clock */
  RCC->AHB3ENCR = RCC_AHB3ENCR_RNGENC;
34180984:	4b65      	ldr	r3, [pc, #404]	@ (34180b1c <SystemInit+0x1b8>)
34180986:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418098a:	461a      	mov	r2, r3
3418098c:	2301      	movs	r3, #1
3418098e:	f8c2 3258 	str.w	r3, [r2, #600]	@ 0x258

  /* Clear SAU regions */
  SAU->RNR = 0;
34180992:	4b63      	ldr	r3, [pc, #396]	@ (34180b20 <SystemInit+0x1bc>)
34180994:	2200      	movs	r2, #0
34180996:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34180998:	4b61      	ldr	r3, [pc, #388]	@ (34180b20 <SystemInit+0x1bc>)
3418099a:	2200      	movs	r2, #0
3418099c:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
3418099e:	4b60      	ldr	r3, [pc, #384]	@ (34180b20 <SystemInit+0x1bc>)
341809a0:	2200      	movs	r2, #0
341809a2:	611a      	str	r2, [r3, #16]
  SAU->RNR = 1;
341809a4:	4b5e      	ldr	r3, [pc, #376]	@ (34180b20 <SystemInit+0x1bc>)
341809a6:	2201      	movs	r2, #1
341809a8:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
341809aa:	4b5d      	ldr	r3, [pc, #372]	@ (34180b20 <SystemInit+0x1bc>)
341809ac:	2200      	movs	r2, #0
341809ae:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
341809b0:	4b5b      	ldr	r3, [pc, #364]	@ (34180b20 <SystemInit+0x1bc>)
341809b2:	2200      	movs	r2, #0
341809b4:	611a      	str	r2, [r3, #16]
  SAU->RNR = 2;
341809b6:	4b5a      	ldr	r3, [pc, #360]	@ (34180b20 <SystemInit+0x1bc>)
341809b8:	2202      	movs	r2, #2
341809ba:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
341809bc:	4b58      	ldr	r3, [pc, #352]	@ (34180b20 <SystemInit+0x1bc>)
341809be:	2200      	movs	r2, #0
341809c0:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
341809c2:	4b57      	ldr	r3, [pc, #348]	@ (34180b20 <SystemInit+0x1bc>)
341809c4:	2200      	movs	r2, #0
341809c6:	611a      	str	r2, [r3, #16]
  SAU->RNR = 3;
341809c8:	4b55      	ldr	r3, [pc, #340]	@ (34180b20 <SystemInit+0x1bc>)
341809ca:	2203      	movs	r2, #3
341809cc:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
341809ce:	4b54      	ldr	r3, [pc, #336]	@ (34180b20 <SystemInit+0x1bc>)
341809d0:	2200      	movs	r2, #0
341809d2:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
341809d4:	4b52      	ldr	r3, [pc, #328]	@ (34180b20 <SystemInit+0x1bc>)
341809d6:	2200      	movs	r2, #0
341809d8:	611a      	str	r2, [r3, #16]
  SAU->RNR = 4;
341809da:	4b51      	ldr	r3, [pc, #324]	@ (34180b20 <SystemInit+0x1bc>)
341809dc:	2204      	movs	r2, #4
341809de:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
341809e0:	4b4f      	ldr	r3, [pc, #316]	@ (34180b20 <SystemInit+0x1bc>)
341809e2:	2200      	movs	r2, #0
341809e4:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
341809e6:	4b4e      	ldr	r3, [pc, #312]	@ (34180b20 <SystemInit+0x1bc>)
341809e8:	2200      	movs	r2, #0
341809ea:	611a      	str	r2, [r3, #16]
  SAU->RNR = 5;
341809ec:	4b4c      	ldr	r3, [pc, #304]	@ (34180b20 <SystemInit+0x1bc>)
341809ee:	2205      	movs	r2, #5
341809f0:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
341809f2:	4b4b      	ldr	r3, [pc, #300]	@ (34180b20 <SystemInit+0x1bc>)
341809f4:	2200      	movs	r2, #0
341809f6:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
341809f8:	4b49      	ldr	r3, [pc, #292]	@ (34180b20 <SystemInit+0x1bc>)
341809fa:	2200      	movs	r2, #0
341809fc:	611a      	str	r2, [r3, #16]
  SAU->RNR = 6;
341809fe:	4b48      	ldr	r3, [pc, #288]	@ (34180b20 <SystemInit+0x1bc>)
34180a00:	2206      	movs	r2, #6
34180a02:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34180a04:	4b46      	ldr	r3, [pc, #280]	@ (34180b20 <SystemInit+0x1bc>)
34180a06:	2200      	movs	r2, #0
34180a08:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34180a0a:	4b45      	ldr	r3, [pc, #276]	@ (34180b20 <SystemInit+0x1bc>)
34180a0c:	2200      	movs	r2, #0
34180a0e:	611a      	str	r2, [r3, #16]
  SAU->RNR = 7;
34180a10:	4b43      	ldr	r3, [pc, #268]	@ (34180b20 <SystemInit+0x1bc>)
34180a12:	2207      	movs	r2, #7
34180a14:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34180a16:	4b42      	ldr	r3, [pc, #264]	@ (34180b20 <SystemInit+0x1bc>)
34180a18:	2200      	movs	r2, #0
34180a1a:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34180a1c:	4b40      	ldr	r3, [pc, #256]	@ (34180b20 <SystemInit+0x1bc>)
34180a1e:	2200      	movs	r2, #0
34180a20:	611a      	str	r2, [r3, #16]

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
34180a22:	4b3e      	ldr	r3, [pc, #248]	@ (34180b1c <SystemInit+0x1b8>)
34180a24:	2201      	movs	r2, #1
34180a26:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
34180a2a:	4b3c      	ldr	r3, [pc, #240]	@ (34180b1c <SystemInit+0x1b8>)
34180a2c:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34180a30:	4b38      	ldr	r3, [pc, #224]	@ (34180b14 <SystemInit+0x1b0>)
34180a32:	4a3c      	ldr	r2, [pc, #240]	@ (34180b24 <SystemInit+0x1c0>)
34180a34:	689b      	ldr	r3, [r3, #8]
34180a36:	6113      	str	r3, [r2, #16]

  /* Enable VDDADC CLAMP */
  PWR->SVMCR3 |= PWR_SVMCR3_ASV;
34180a38:	4b3b      	ldr	r3, [pc, #236]	@ (34180b28 <SystemInit+0x1c4>)
34180a3a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34180a3c:	4a3a      	ldr	r2, [pc, #232]	@ (34180b28 <SystemInit+0x1c4>)
34180a3e:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
34180a42:	63d3      	str	r3, [r2, #60]	@ 0x3c
  PWR->SVMCR3 |= PWR_SVMCR3_AVMEN;
34180a44:	4b38      	ldr	r3, [pc, #224]	@ (34180b28 <SystemInit+0x1c4>)
34180a46:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34180a48:	4a37      	ldr	r2, [pc, #220]	@ (34180b28 <SystemInit+0x1c4>)
34180a4a:	f043 0310 	orr.w	r3, r3, #16
34180a4e:	63d3      	str	r3, [r2, #60]	@ 0x3c
  /* read back the register to make sure that the transaction has taken place */
  (void) PWR->SVMCR3;
34180a50:	4b35      	ldr	r3, [pc, #212]	@ (34180b28 <SystemInit+0x1c4>)
34180a52:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  /* enable VREF */
  RCC->APB4ENR1 |= RCC_APB4ENR1_VREFBUFEN;
34180a54:	4b31      	ldr	r3, [pc, #196]	@ (34180b1c <SystemInit+0x1b8>)
34180a56:	f8d3 3274 	ldr.w	r3, [r3, #628]	@ 0x274
34180a5a:	4a30      	ldr	r2, [pc, #192]	@ (34180b1c <SystemInit+0x1b8>)
34180a5c:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34180a60:	f8c2 3274 	str.w	r3, [r2, #628]	@ 0x274

  /* RCC Fix to lower power consumption */
  RCC->APB4ENR2 |= 0x00000010UL;
34180a64:	4b2d      	ldr	r3, [pc, #180]	@ (34180b1c <SystemInit+0x1b8>)
34180a66:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
34180a6a:	4a2c      	ldr	r2, [pc, #176]	@ (34180b1c <SystemInit+0x1b8>)
34180a6c:	f043 0310 	orr.w	r3, r3, #16
34180a70:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  (void) RCC->APB4ENR2;
34180a74:	4b29      	ldr	r3, [pc, #164]	@ (34180b1c <SystemInit+0x1b8>)
34180a76:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
  RCC->APB4ENR2 &= ~(0x00000010UL);
34180a7a:	4b28      	ldr	r3, [pc, #160]	@ (34180b1c <SystemInit+0x1b8>)
34180a7c:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
34180a80:	4a26      	ldr	r2, [pc, #152]	@ (34180b1c <SystemInit+0x1b8>)
34180a82:	f023 0310 	bic.w	r3, r3, #16
34180a86:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278

  /* XSPI2 & XSPIM reset                                  */
  RCC->AHB5RSTSR = RCC_AHB5RSTSR_XSPIMRSTS | RCC_AHB5RSTSR_XSPI2RSTS;
34180a8a:	4b24      	ldr	r3, [pc, #144]	@ (34180b1c <SystemInit+0x1b8>)
34180a8c:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
34180a90:	f8c3 2a20 	str.w	r2, [r3, #2592]	@ 0xa20
  RCC->AHB5RSTCR = RCC_AHB5RSTCR_XSPIMRSTC | RCC_AHB5RSTCR_XSPI2RSTC;
34180a94:	4b21      	ldr	r3, [pc, #132]	@ (34180b1c <SystemInit+0x1b8>)
34180a96:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34180a9a:	461a      	mov	r2, r3
34180a9c:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34180aa0:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220

  /* TIM2 reset */
  RCC->APB1RSTSR1 = RCC_APB1RSTSR1_TIM2RSTS;
34180aa4:	4b1d      	ldr	r3, [pc, #116]	@ (34180b1c <SystemInit+0x1b8>)
34180aa6:	2201      	movs	r2, #1
34180aa8:	f8c3 2a24 	str.w	r2, [r3, #2596]	@ 0xa24
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
34180aac:	4b1b      	ldr	r3, [pc, #108]	@ (34180b1c <SystemInit+0x1b8>)
34180aae:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34180ab2:	461a      	mov	r2, r3
34180ab4:	2301      	movs	r3, #1
34180ab6:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
  /* Deactivate TIM2 clock */
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;
34180aba:	4b18      	ldr	r3, [pc, #96]	@ (34180b1c <SystemInit+0x1b8>)
34180abc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34180ac0:	461a      	mov	r2, r3
34180ac2:	2301      	movs	r3, #1
34180ac4:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264

  /* Deactivate GPIOG clock */
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34180ac8:	4b14      	ldr	r3, [pc, #80]	@ (34180b1c <SystemInit+0x1b8>)
34180aca:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34180ace:	461a      	mov	r2, r3
34180ad0:	2340      	movs	r3, #64	@ 0x40
34180ad2:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c

  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
34180ad6:	4b13      	ldr	r3, [pc, #76]	@ (34180b24 <SystemInit+0x1c0>)
34180ad8:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34180ada:	4b10      	ldr	r3, [pc, #64]	@ (34180b1c <SystemInit+0x1b8>)
34180adc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34180ae0:	461a      	mov	r2, r3
34180ae2:	2301      	movs	r3, #1
34180ae4:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  TZ_SAU_Setup();
#endif /* USER_TZ_SAU_SETUP */

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34180ae8:	4b0a      	ldr	r3, [pc, #40]	@ (34180b14 <SystemInit+0x1b0>)
34180aea:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34180aee:	4a09      	ldr	r2, [pc, #36]	@ (34180b14 <SystemInit+0x1b0>)
34180af0:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34180af4:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34180af8:	4b0c      	ldr	r3, [pc, #48]	@ (34180b2c <SystemInit+0x1c8>)
34180afa:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34180afe:	4a0b      	ldr	r2, [pc, #44]	@ (34180b2c <SystemInit+0x1c8>)
34180b00:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34180b04:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
34180b08:	bf00      	nop
34180b0a:	46bd      	mov	sp, r7
34180b0c:	f85d 7b04 	ldr.w	r7, [sp], #4
34180b10:	4770      	bx	lr
34180b12:	bf00      	nop
34180b14:	e000ed00 	.word	0xe000ed00
34180b18:	34180400 	.word	0x34180400
34180b1c:	56028000 	.word	0x56028000
34180b20:	e000edd0 	.word	0xe000edd0
34180b24:	56008000 	.word	0x56008000
34180b28:	56024800 	.word	0x56024800
34180b2c:	e002ed00 	.word	0xe002ed00

34180b30 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
34180b30:	b480      	push	{r7}
34180b32:	b08d      	sub	sp, #52	@ 0x34
34180b34:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
34180b36:	2300      	movs	r3, #0
34180b38:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
34180b3a:	2300      	movs	r3, #0
34180b3c:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
34180b3e:	2300      	movs	r3, #0
34180b40:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
34180b42:	2300      	movs	r3, #0
34180b44:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
34180b46:	2300      	movs	r3, #0
34180b48:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
34180b4a:	2300      	movs	r3, #0
34180b4c:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34180b4e:	4b9b      	ldr	r3, [pc, #620]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180b50:	6a1b      	ldr	r3, [r3, #32]
34180b52:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
34180b56:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34180b5a:	d029      	beq.n	34180bb0 <SystemCoreClockUpdate+0x80>
34180b5c:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34180b60:	f200 8180 	bhi.w	34180e64 <SystemCoreClockUpdate+0x334>
34180b64:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34180b68:	d01f      	beq.n	34180baa <SystemCoreClockUpdate+0x7a>
34180b6a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34180b6e:	f200 8179 	bhi.w	34180e64 <SystemCoreClockUpdate+0x334>
34180b72:	2b00      	cmp	r3, #0
34180b74:	d003      	beq.n	34180b7e <SystemCoreClockUpdate+0x4e>
34180b76:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34180b7a:	d00a      	beq.n	34180b92 <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
34180b7c:	e172      	b.n	34180e64 <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34180b7e:	4b8f      	ldr	r3, [pc, #572]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180b80:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34180b82:	09db      	lsrs	r3, r3, #7
34180b84:	f003 0303 	and.w	r3, r3, #3
34180b88:	4a8d      	ldr	r2, [pc, #564]	@ (34180dc0 <SystemCoreClockUpdate+0x290>)
34180b8a:	fa22 f303 	lsr.w	r3, r2, r3
34180b8e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34180b90:	e169      	b.n	34180e66 <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34180b92:	4b8a      	ldr	r3, [pc, #552]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180b94:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34180b96:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34180b9a:	2b00      	cmp	r3, #0
34180b9c:	d102      	bne.n	34180ba4 <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
34180b9e:	4b89      	ldr	r3, [pc, #548]	@ (34180dc4 <SystemCoreClockUpdate+0x294>)
34180ba0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34180ba2:	e160      	b.n	34180e66 <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
34180ba4:	4b88      	ldr	r3, [pc, #544]	@ (34180dc8 <SystemCoreClockUpdate+0x298>)
34180ba6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34180ba8:	e15d      	b.n	34180e66 <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
34180baa:	4b88      	ldr	r3, [pc, #544]	@ (34180dcc <SystemCoreClockUpdate+0x29c>)
34180bac:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34180bae:	e15a      	b.n	34180e66 <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34180bb0:	4b82      	ldr	r3, [pc, #520]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180bb2:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34180bb6:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
34180bba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34180bbe:	d066      	beq.n	34180c8e <SystemCoreClockUpdate+0x15e>
34180bc0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34180bc4:	f200 8091 	bhi.w	34180cea <SystemCoreClockUpdate+0x1ba>
34180bc8:	2b00      	cmp	r3, #0
34180bca:	d003      	beq.n	34180bd4 <SystemCoreClockUpdate+0xa4>
34180bcc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34180bd0:	d02f      	beq.n	34180c32 <SystemCoreClockUpdate+0x102>
34180bd2:	e08a      	b.n	34180cea <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
34180bd4:	4b79      	ldr	r3, [pc, #484]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180bd6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34180bda:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
34180bdc:	68fb      	ldr	r3, [r7, #12]
34180bde:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34180be2:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
34180be4:	68fb      	ldr	r3, [r7, #12]
34180be6:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34180bea:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34180bec:	693b      	ldr	r3, [r7, #16]
34180bee:	2b00      	cmp	r3, #0
34180bf0:	f040 80a9 	bne.w	34180d46 <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
34180bf4:	68fb      	ldr	r3, [r7, #12]
34180bf6:	0d1b      	lsrs	r3, r3, #20
34180bf8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34180bfc:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
34180bfe:	68fb      	ldr	r3, [r7, #12]
34180c00:	0a1b      	lsrs	r3, r3, #8
34180c02:	f3c3 030b 	ubfx	r3, r3, #0, #12
34180c06:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34180c08:	4b6c      	ldr	r3, [pc, #432]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180c0a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34180c0e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34180c12:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
34180c14:	4b69      	ldr	r3, [pc, #420]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180c16:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34180c1a:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
34180c1c:	68fb      	ldr	r3, [r7, #12]
34180c1e:	0edb      	lsrs	r3, r3, #27
34180c20:	f003 0307 	and.w	r3, r3, #7
34180c24:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
34180c26:	68fb      	ldr	r3, [r7, #12]
34180c28:	0e1b      	lsrs	r3, r3, #24
34180c2a:	f003 0307 	and.w	r3, r3, #7
34180c2e:	61bb      	str	r3, [r7, #24]
      break;
34180c30:	e089      	b.n	34180d46 <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
34180c32:	4b62      	ldr	r3, [pc, #392]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180c34:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34180c38:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
34180c3a:	68fb      	ldr	r3, [r7, #12]
34180c3c:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34180c40:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
34180c42:	68fb      	ldr	r3, [r7, #12]
34180c44:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34180c48:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34180c4a:	693b      	ldr	r3, [r7, #16]
34180c4c:	2b00      	cmp	r3, #0
34180c4e:	d17c      	bne.n	34180d4a <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
34180c50:	68fb      	ldr	r3, [r7, #12]
34180c52:	0d1b      	lsrs	r3, r3, #20
34180c54:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34180c58:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
34180c5a:	68fb      	ldr	r3, [r7, #12]
34180c5c:	0a1b      	lsrs	r3, r3, #8
34180c5e:	f3c3 030b 	ubfx	r3, r3, #0, #12
34180c62:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34180c64:	4b55      	ldr	r3, [pc, #340]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180c66:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34180c6a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34180c6e:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
34180c70:	4b52      	ldr	r3, [pc, #328]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180c72:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34180c76:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34180c78:	68fb      	ldr	r3, [r7, #12]
34180c7a:	0edb      	lsrs	r3, r3, #27
34180c7c:	f003 0307 	and.w	r3, r3, #7
34180c80:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
34180c82:	68fb      	ldr	r3, [r7, #12]
34180c84:	0e1b      	lsrs	r3, r3, #24
34180c86:	f003 0307 	and.w	r3, r3, #7
34180c8a:	61bb      	str	r3, [r7, #24]
      break;
34180c8c:	e05d      	b.n	34180d4a <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
34180c8e:	4b4b      	ldr	r3, [pc, #300]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180c90:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34180c94:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
34180c96:	68fb      	ldr	r3, [r7, #12]
34180c98:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34180c9c:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
34180c9e:	68fb      	ldr	r3, [r7, #12]
34180ca0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34180ca4:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34180ca6:	693b      	ldr	r3, [r7, #16]
34180ca8:	2b00      	cmp	r3, #0
34180caa:	d150      	bne.n	34180d4e <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
34180cac:	68fb      	ldr	r3, [r7, #12]
34180cae:	0d1b      	lsrs	r3, r3, #20
34180cb0:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34180cb4:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
34180cb6:	68fb      	ldr	r3, [r7, #12]
34180cb8:	0a1b      	lsrs	r3, r3, #8
34180cba:	f3c3 030b 	ubfx	r3, r3, #0, #12
34180cbe:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34180cc0:	4b3e      	ldr	r3, [pc, #248]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180cc2:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34180cc6:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34180cca:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34180ccc:	4b3b      	ldr	r3, [pc, #236]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180cce:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34180cd2:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34180cd4:	68fb      	ldr	r3, [r7, #12]
34180cd6:	0edb      	lsrs	r3, r3, #27
34180cd8:	f003 0307 	and.w	r3, r3, #7
34180cdc:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
34180cde:	68fb      	ldr	r3, [r7, #12]
34180ce0:	0e1b      	lsrs	r3, r3, #24
34180ce2:	f003 0307 	and.w	r3, r3, #7
34180ce6:	61bb      	str	r3, [r7, #24]
      break;
34180ce8:	e031      	b.n	34180d4e <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
34180cea:	4b34      	ldr	r3, [pc, #208]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180cec:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34180cf0:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34180cf2:	68fb      	ldr	r3, [r7, #12]
34180cf4:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34180cf8:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
34180cfa:	68fb      	ldr	r3, [r7, #12]
34180cfc:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34180d00:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34180d02:	693b      	ldr	r3, [r7, #16]
34180d04:	2b00      	cmp	r3, #0
34180d06:	d124      	bne.n	34180d52 <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
34180d08:	68fb      	ldr	r3, [r7, #12]
34180d0a:	0d1b      	lsrs	r3, r3, #20
34180d0c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34180d10:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
34180d12:	68fb      	ldr	r3, [r7, #12]
34180d14:	0a1b      	lsrs	r3, r3, #8
34180d16:	f3c3 030b 	ubfx	r3, r3, #0, #12
34180d1a:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34180d1c:	4b27      	ldr	r3, [pc, #156]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180d1e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34180d22:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34180d26:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34180d28:	4b24      	ldr	r3, [pc, #144]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180d2a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34180d2e:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
34180d30:	68fb      	ldr	r3, [r7, #12]
34180d32:	0edb      	lsrs	r3, r3, #27
34180d34:	f003 0307 	and.w	r3, r3, #7
34180d38:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
34180d3a:	68fb      	ldr	r3, [r7, #12]
34180d3c:	0e1b      	lsrs	r3, r3, #24
34180d3e:	f003 0307 	and.w	r3, r3, #7
34180d42:	61bb      	str	r3, [r7, #24]
      break;
34180d44:	e005      	b.n	34180d52 <SystemCoreClockUpdate+0x222>
      break;
34180d46:	bf00      	nop
34180d48:	e004      	b.n	34180d54 <SystemCoreClockUpdate+0x224>
      break;
34180d4a:	bf00      	nop
34180d4c:	e002      	b.n	34180d54 <SystemCoreClockUpdate+0x224>
      break;
34180d4e:	bf00      	nop
34180d50:	e000      	b.n	34180d54 <SystemCoreClockUpdate+0x224>
      break;
34180d52:	bf00      	nop
    switch (pllsource)
34180d54:	697b      	ldr	r3, [r7, #20]
34180d56:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34180d5a:	d02c      	beq.n	34180db6 <SystemCoreClockUpdate+0x286>
34180d5c:	697b      	ldr	r3, [r7, #20]
34180d5e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34180d62:	d839      	bhi.n	34180dd8 <SystemCoreClockUpdate+0x2a8>
34180d64:	697b      	ldr	r3, [r7, #20]
34180d66:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34180d6a:	d021      	beq.n	34180db0 <SystemCoreClockUpdate+0x280>
34180d6c:	697b      	ldr	r3, [r7, #20]
34180d6e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34180d72:	d831      	bhi.n	34180dd8 <SystemCoreClockUpdate+0x2a8>
34180d74:	697b      	ldr	r3, [r7, #20]
34180d76:	2b00      	cmp	r3, #0
34180d78:	d004      	beq.n	34180d84 <SystemCoreClockUpdate+0x254>
34180d7a:	697b      	ldr	r3, [r7, #20]
34180d7c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34180d80:	d00a      	beq.n	34180d98 <SystemCoreClockUpdate+0x268>
      break;
34180d82:	e029      	b.n	34180dd8 <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34180d84:	4b0d      	ldr	r3, [pc, #52]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180d86:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34180d88:	09db      	lsrs	r3, r3, #7
34180d8a:	f003 0303 	and.w	r3, r3, #3
34180d8e:	4a0c      	ldr	r2, [pc, #48]	@ (34180dc0 <SystemCoreClockUpdate+0x290>)
34180d90:	fa22 f303 	lsr.w	r3, r2, r3
34180d94:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34180d96:	e020      	b.n	34180dda <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34180d98:	4b08      	ldr	r3, [pc, #32]	@ (34180dbc <SystemCoreClockUpdate+0x28c>)
34180d9a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34180d9c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34180da0:	2b00      	cmp	r3, #0
34180da2:	d102      	bne.n	34180daa <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
34180da4:	4b07      	ldr	r3, [pc, #28]	@ (34180dc4 <SystemCoreClockUpdate+0x294>)
34180da6:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34180da8:	e017      	b.n	34180dda <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
34180daa:	4b07      	ldr	r3, [pc, #28]	@ (34180dc8 <SystemCoreClockUpdate+0x298>)
34180dac:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34180dae:	e014      	b.n	34180dda <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
34180db0:	4b06      	ldr	r3, [pc, #24]	@ (34180dcc <SystemCoreClockUpdate+0x29c>)
34180db2:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34180db4:	e011      	b.n	34180dda <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34180db6:	4b06      	ldr	r3, [pc, #24]	@ (34180dd0 <SystemCoreClockUpdate+0x2a0>)
34180db8:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34180dba:	e00e      	b.n	34180dda <SystemCoreClockUpdate+0x2aa>
34180dbc:	56028000 	.word	0x56028000
34180dc0:	03d09000 	.word	0x03d09000
34180dc4:	003d0900 	.word	0x003d0900
34180dc8:	00f42400 	.word	0x00f42400
34180dcc:	02dc6c00 	.word	0x02dc6c00
34180dd0:	00bb8000 	.word	0x00bb8000
34180dd4:	4b800000 	.word	0x4b800000
      break;
34180dd8:	bf00      	nop
    if (pllbypass == 0U)
34180dda:	693b      	ldr	r3, [r7, #16]
34180ddc:	2b00      	cmp	r3, #0
34180dde:	d134      	bne.n	34180e4a <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34180de0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34180de2:	ee07 3a90 	vmov	s15, r3
34180de6:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34180dea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34180dec:	ee07 3a90 	vmov	s15, r3
34180df0:	eef8 6a67 	vcvt.f32.u32	s13, s15
34180df4:	6a3b      	ldr	r3, [r7, #32]
34180df6:	ee07 3a90 	vmov	s15, r3
34180dfa:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34180dfe:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 34180dd4 <SystemCoreClockUpdate+0x2a4>
34180e02:	eec6 7a25 	vdiv.f32	s15, s12, s11
34180e06:	ee76 7aa7 	vadd.f32	s15, s13, s15
34180e0a:	ee67 6a27 	vmul.f32	s13, s14, s15
34180e0e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34180e10:	ee07 3a90 	vmov	s15, r3
34180e14:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34180e18:	eec6 7a87 	vdiv.f32	s15, s13, s14
34180e1c:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
34180e20:	69fb      	ldr	r3, [r7, #28]
34180e22:	ee07 3a90 	vmov	s15, r3
34180e26:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34180e2a:	69bb      	ldr	r3, [r7, #24]
34180e2c:	ee07 3a90 	vmov	s15, r3
34180e30:	eef8 7a67 	vcvt.f32.u32	s15, s15
34180e34:	ee27 7a27 	vmul.f32	s14, s14, s15
34180e38:	edd7 6a02 	vldr	s13, [r7, #8]
34180e3c:	eec6 7a87 	vdiv.f32	s15, s13, s14
34180e40:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34180e44:	ee17 3a90 	vmov	r3, s15
34180e48:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
34180e4a:	4b0b      	ldr	r3, [pc, #44]	@ (34180e78 <SystemCoreClockUpdate+0x348>)
34180e4c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34180e50:	0c1b      	lsrs	r3, r3, #16
34180e52:	b2db      	uxtb	r3, r3
34180e54:	3301      	adds	r3, #1
34180e56:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
34180e58:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34180e5a:	687b      	ldr	r3, [r7, #4]
34180e5c:	fbb2 f3f3 	udiv	r3, r2, r3
34180e60:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34180e62:	e000      	b.n	34180e66 <SystemCoreClockUpdate+0x336>
    break;
34180e64:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
34180e66:	4a05      	ldr	r2, [pc, #20]	@ (34180e7c <SystemCoreClockUpdate+0x34c>)
34180e68:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34180e6a:	6013      	str	r3, [r2, #0]
}
34180e6c:	bf00      	nop
34180e6e:	3734      	adds	r7, #52	@ 0x34
34180e70:	46bd      	mov	sp, r7
34180e72:	f85d 7b04 	ldr.w	r7, [sp], #4
34180e76:	4770      	bx	lr
34180e78:	56028000 	.word	0x56028000
34180e7c:	341c0000 	.word	0x341c0000

34180e80 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
34180e80:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34180e84:	b588      	push	{r3, r7, lr}
34180e86:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
34180e88:	f7ff fe52 	bl	34180b30 <SystemCoreClockUpdate>

  return SystemCoreClock;
34180e8c:	4b06      	ldr	r3, [pc, #24]	@ (34180ea8 <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
34180e8e:	681b      	ldr	r3, [r3, #0]
}
34180e90:	4618      	mov	r0, r3
34180e92:	46bd      	mov	sp, r7
34180e94:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
34180e98:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34180e9c:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34180ea0:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34180ea4:	4774      	bxns	lr
34180ea6:	bf00      	nop
34180ea8:	341c0000 	.word	0x341c0000

34180eac <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
34180eac:	480f      	ldr	r0, [pc, #60]	@ (34180eec <LoopForever+0x4>)
  msr   MSPLIM, r0
34180eae:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
34180eb2:	480f      	ldr	r0, [pc, #60]	@ (34180ef0 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
34180eb4:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
34180eb6:	f7ff fd55 	bl	34180964 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
34180eba:	480e      	ldr	r0, [pc, #56]	@ (34180ef4 <LoopForever+0xc>)
  ldr r1, =_edata
34180ebc:	490e      	ldr	r1, [pc, #56]	@ (34180ef8 <LoopForever+0x10>)
  ldr r2, =_sidata
34180ebe:	4a0f      	ldr	r2, [pc, #60]	@ (34180efc <LoopForever+0x14>)
  movs r3, #0
34180ec0:	2300      	movs	r3, #0
  b LoopCopyDataInit
34180ec2:	e002      	b.n	34180eca <LoopCopyDataInit>

34180ec4 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
34180ec4:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
34180ec6:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
34180ec8:	3304      	adds	r3, #4

34180eca <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
34180eca:	18c4      	adds	r4, r0, r3
  cmp r4, r1
34180ecc:	428c      	cmp	r4, r1
  bcc CopyDataInit
34180ece:	d3f9      	bcc.n	34180ec4 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
34180ed0:	4a0b      	ldr	r2, [pc, #44]	@ (34180f00 <LoopForever+0x18>)
  ldr r4, =_ebss
34180ed2:	4c0c      	ldr	r4, [pc, #48]	@ (34180f04 <LoopForever+0x1c>)
  movs r3, #0
34180ed4:	2300      	movs	r3, #0
  b LoopFillZerobss
34180ed6:	e001      	b.n	34180edc <LoopFillZerobss>

34180ed8 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
34180ed8:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
34180eda:	3204      	adds	r2, #4

34180edc <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
34180edc:	42a2      	cmp	r2, r4
  bcc FillZerobss
34180ede:	d3fb      	bcc.n	34180ed8 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
34180ee0:	f002 fa12 	bl	34183308 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
34180ee4:	f7ff fc52 	bl	3418078c <main>

34180ee8 <LoopForever>:

LoopForever:
  b LoopForever
34180ee8:	e7fe      	b.n	34180ee8 <LoopForever>
34180eea:	0000      	.short	0x0000
  ldr   r0, =_sstack
34180eec:	341ff800 	.word	0x341ff800
  ldr   r0, =_estack
34180ef0:	34200000 	.word	0x34200000
  ldr r0, =_sdata
34180ef4:	341c0000 	.word	0x341c0000
  ldr r1, =_edata
34180ef8:	341c000c 	.word	0x341c000c
  ldr r2, =_sidata
34180efc:	34183370 	.word	0x34183370
  ldr r2, =_sbss
34180f00:	341c0010 	.word	0x341c0010
  ldr r4, =_ebss
34180f04:	341c0030 	.word	0x341c0030

34180f08 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
34180f08:	e7fe      	b.n	34180f08 <ADC1_2_IRQHandler>

34180f0a <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
34180f0a:	b580      	push	{r7, lr}
34180f0c:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
34180f0e:	2003      	movs	r0, #3
34180f10:	f000 f918 	bl	34181144 <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
34180f14:	f7ff fe0c 	bl	34180b30 <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
34180f18:	200f      	movs	r0, #15
34180f1a:	f000 f80b 	bl	34180f34 <HAL_InitTick>
34180f1e:	4603      	mov	r3, r0
34180f20:	2b00      	cmp	r3, #0
34180f22:	d001      	beq.n	34180f28 <HAL_Init+0x1e>
  {
    return HAL_ERROR;
34180f24:	2301      	movs	r3, #1
34180f26:	e002      	b.n	34180f2e <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
34180f28:	f7ff fce2 	bl	341808f0 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
34180f2c:	2300      	movs	r3, #0
}
34180f2e:	4618      	mov	r0, r3
34180f30:	bd80      	pop	{r7, pc}
	...

34180f34 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
34180f34:	b580      	push	{r7, lr}
34180f36:	b082      	sub	sp, #8
34180f38:	af00      	add	r7, sp, #0
34180f3a:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
34180f3c:	4b15      	ldr	r3, [pc, #84]	@ (34180f94 <HAL_InitTick+0x60>)
34180f3e:	781b      	ldrb	r3, [r3, #0]
34180f40:	2b00      	cmp	r3, #0
34180f42:	d101      	bne.n	34180f48 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
34180f44:	2301      	movs	r3, #1
34180f46:	e021      	b.n	34180f8c <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
34180f48:	4b13      	ldr	r3, [pc, #76]	@ (34180f98 <HAL_InitTick+0x64>)
34180f4a:	681a      	ldr	r2, [r3, #0]
34180f4c:	4b11      	ldr	r3, [pc, #68]	@ (34180f94 <HAL_InitTick+0x60>)
34180f4e:	781b      	ldrb	r3, [r3, #0]
34180f50:	4619      	mov	r1, r3
34180f52:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34180f56:	fbb3 f3f1 	udiv	r3, r3, r1
34180f5a:	fbb2 f3f3 	udiv	r3, r2, r3
34180f5e:	4618      	mov	r0, r3
34180f60:	f000 f918 	bl	34181194 <HAL_SYSTICK_Config>
34180f64:	4603      	mov	r3, r0
34180f66:	2b00      	cmp	r3, #0
34180f68:	d001      	beq.n	34180f6e <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
34180f6a:	2301      	movs	r3, #1
34180f6c:	e00e      	b.n	34180f8c <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
34180f6e:	687b      	ldr	r3, [r7, #4]
34180f70:	2b0f      	cmp	r3, #15
34180f72:	d80a      	bhi.n	34180f8a <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
34180f74:	2200      	movs	r2, #0
34180f76:	6879      	ldr	r1, [r7, #4]
34180f78:	f04f 30ff 	mov.w	r0, #4294967295
34180f7c:	f000 f8ed 	bl	3418115a <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
34180f80:	4a06      	ldr	r2, [pc, #24]	@ (34180f9c <HAL_InitTick+0x68>)
34180f82:	687b      	ldr	r3, [r7, #4]
34180f84:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
34180f86:	2300      	movs	r3, #0
34180f88:	e000      	b.n	34180f8c <HAL_InitTick+0x58>
    return HAL_ERROR;
34180f8a:	2301      	movs	r3, #1
}
34180f8c:	4618      	mov	r0, r3
34180f8e:	3708      	adds	r7, #8
34180f90:	46bd      	mov	sp, r7
34180f92:	bd80      	pop	{r7, pc}
34180f94:	341c0008 	.word	0x341c0008
34180f98:	341c0000 	.word	0x341c0000
34180f9c:	341c0004 	.word	0x341c0004

34180fa0 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
34180fa0:	b480      	push	{r7}
34180fa2:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
34180fa4:	4b06      	ldr	r3, [pc, #24]	@ (34180fc0 <HAL_IncTick+0x20>)
34180fa6:	781b      	ldrb	r3, [r3, #0]
34180fa8:	461a      	mov	r2, r3
34180faa:	4b06      	ldr	r3, [pc, #24]	@ (34180fc4 <HAL_IncTick+0x24>)
34180fac:	681b      	ldr	r3, [r3, #0]
34180fae:	4413      	add	r3, r2
34180fb0:	4a04      	ldr	r2, [pc, #16]	@ (34180fc4 <HAL_IncTick+0x24>)
34180fb2:	6013      	str	r3, [r2, #0]
}
34180fb4:	bf00      	nop
34180fb6:	46bd      	mov	sp, r7
34180fb8:	f85d 7b04 	ldr.w	r7, [sp], #4
34180fbc:	4770      	bx	lr
34180fbe:	bf00      	nop
34180fc0:	341c0008 	.word	0x341c0008
34180fc4:	341c002c 	.word	0x341c002c

34180fc8 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
34180fc8:	b480      	push	{r7}
34180fca:	af00      	add	r7, sp, #0
  return uwTick;
34180fcc:	4b03      	ldr	r3, [pc, #12]	@ (34180fdc <HAL_GetTick+0x14>)
34180fce:	681b      	ldr	r3, [r3, #0]
}
34180fd0:	4618      	mov	r0, r3
34180fd2:	46bd      	mov	sp, r7
34180fd4:	f85d 7b04 	ldr.w	r7, [sp], #4
34180fd8:	4770      	bx	lr
34180fda:	bf00      	nop
34180fdc:	341c002c 	.word	0x341c002c

34180fe0 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34180fe0:	b480      	push	{r7}
34180fe2:	b085      	sub	sp, #20
34180fe4:	af00      	add	r7, sp, #0
34180fe6:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
34180fe8:	687b      	ldr	r3, [r7, #4]
34180fea:	f003 0307 	and.w	r3, r3, #7
34180fee:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34180ff0:	4b0c      	ldr	r3, [pc, #48]	@ (34181024 <__NVIC_SetPriorityGrouping+0x44>)
34180ff2:	68db      	ldr	r3, [r3, #12]
34180ff4:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
34180ff6:	68ba      	ldr	r2, [r7, #8]
34180ff8:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
34180ffc:	4013      	ands	r3, r2
34180ffe:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
34181000:	68fb      	ldr	r3, [r7, #12]
34181002:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
34181004:	68bb      	ldr	r3, [r7, #8]
34181006:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
34181008:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
3418100c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34181010:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
34181012:	4a04      	ldr	r2, [pc, #16]	@ (34181024 <__NVIC_SetPriorityGrouping+0x44>)
34181014:	68bb      	ldr	r3, [r7, #8]
34181016:	60d3      	str	r3, [r2, #12]
}
34181018:	bf00      	nop
3418101a:	3714      	adds	r7, #20
3418101c:	46bd      	mov	sp, r7
3418101e:	f85d 7b04 	ldr.w	r7, [sp], #4
34181022:	4770      	bx	lr
34181024:	e000ed00 	.word	0xe000ed00

34181028 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
34181028:	b480      	push	{r7}
3418102a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
3418102c:	4b04      	ldr	r3, [pc, #16]	@ (34181040 <__NVIC_GetPriorityGrouping+0x18>)
3418102e:	68db      	ldr	r3, [r3, #12]
34181030:	0a1b      	lsrs	r3, r3, #8
34181032:	f003 0307 	and.w	r3, r3, #7
}
34181036:	4618      	mov	r0, r3
34181038:	46bd      	mov	sp, r7
3418103a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418103e:	4770      	bx	lr
34181040:	e000ed00 	.word	0xe000ed00

34181044 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
34181044:	b480      	push	{r7}
34181046:	b083      	sub	sp, #12
34181048:	af00      	add	r7, sp, #0
3418104a:	4603      	mov	r3, r0
3418104c:	6039      	str	r1, [r7, #0]
3418104e:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34181050:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34181054:	2b00      	cmp	r3, #0
34181056:	db0a      	blt.n	3418106e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34181058:	683b      	ldr	r3, [r7, #0]
3418105a:	b2da      	uxtb	r2, r3
3418105c:	490c      	ldr	r1, [pc, #48]	@ (34181090 <__NVIC_SetPriority+0x4c>)
3418105e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34181062:	0112      	lsls	r2, r2, #4
34181064:	b2d2      	uxtb	r2, r2
34181066:	440b      	add	r3, r1
34181068:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
3418106c:	e00a      	b.n	34181084 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
3418106e:	683b      	ldr	r3, [r7, #0]
34181070:	b2da      	uxtb	r2, r3
34181072:	4908      	ldr	r1, [pc, #32]	@ (34181094 <__NVIC_SetPriority+0x50>)
34181074:	88fb      	ldrh	r3, [r7, #6]
34181076:	f003 030f 	and.w	r3, r3, #15
3418107a:	3b04      	subs	r3, #4
3418107c:	0112      	lsls	r2, r2, #4
3418107e:	b2d2      	uxtb	r2, r2
34181080:	440b      	add	r3, r1
34181082:	761a      	strb	r2, [r3, #24]
}
34181084:	bf00      	nop
34181086:	370c      	adds	r7, #12
34181088:	46bd      	mov	sp, r7
3418108a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418108e:	4770      	bx	lr
34181090:	e000e100 	.word	0xe000e100
34181094:	e000ed00 	.word	0xe000ed00

34181098 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
34181098:	b480      	push	{r7}
3418109a:	b089      	sub	sp, #36	@ 0x24
3418109c:	af00      	add	r7, sp, #0
3418109e:	60f8      	str	r0, [r7, #12]
341810a0:	60b9      	str	r1, [r7, #8]
341810a2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
341810a4:	68fb      	ldr	r3, [r7, #12]
341810a6:	f003 0307 	and.w	r3, r3, #7
341810aa:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
341810ac:	69fb      	ldr	r3, [r7, #28]
341810ae:	f1c3 0307 	rsb	r3, r3, #7
341810b2:	2b04      	cmp	r3, #4
341810b4:	bf28      	it	cs
341810b6:	2304      	movcs	r3, #4
341810b8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
341810ba:	69fb      	ldr	r3, [r7, #28]
341810bc:	3304      	adds	r3, #4
341810be:	2b06      	cmp	r3, #6
341810c0:	d902      	bls.n	341810c8 <NVIC_EncodePriority+0x30>
341810c2:	69fb      	ldr	r3, [r7, #28]
341810c4:	3b03      	subs	r3, #3
341810c6:	e000      	b.n	341810ca <NVIC_EncodePriority+0x32>
341810c8:	2300      	movs	r3, #0
341810ca:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
341810cc:	f04f 32ff 	mov.w	r2, #4294967295
341810d0:	69bb      	ldr	r3, [r7, #24]
341810d2:	fa02 f303 	lsl.w	r3, r2, r3
341810d6:	43da      	mvns	r2, r3
341810d8:	68bb      	ldr	r3, [r7, #8]
341810da:	401a      	ands	r2, r3
341810dc:	697b      	ldr	r3, [r7, #20]
341810de:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
341810e0:	f04f 31ff 	mov.w	r1, #4294967295
341810e4:	697b      	ldr	r3, [r7, #20]
341810e6:	fa01 f303 	lsl.w	r3, r1, r3
341810ea:	43d9      	mvns	r1, r3
341810ec:	687b      	ldr	r3, [r7, #4]
341810ee:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
341810f0:	4313      	orrs	r3, r2
         );
}
341810f2:	4618      	mov	r0, r3
341810f4:	3724      	adds	r7, #36	@ 0x24
341810f6:	46bd      	mov	sp, r7
341810f8:	f85d 7b04 	ldr.w	r7, [sp], #4
341810fc:	4770      	bx	lr
	...

34181100 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
34181100:	b580      	push	{r7, lr}
34181102:	b082      	sub	sp, #8
34181104:	af00      	add	r7, sp, #0
34181106:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
34181108:	687b      	ldr	r3, [r7, #4]
3418110a:	3b01      	subs	r3, #1
3418110c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34181110:	d301      	bcc.n	34181116 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
34181112:	2301      	movs	r3, #1
34181114:	e00f      	b.n	34181136 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
34181116:	4a0a      	ldr	r2, [pc, #40]	@ (34181140 <SysTick_Config+0x40>)
34181118:	687b      	ldr	r3, [r7, #4]
3418111a:	3b01      	subs	r3, #1
3418111c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
3418111e:	210f      	movs	r1, #15
34181120:	f04f 30ff 	mov.w	r0, #4294967295
34181124:	f7ff ff8e 	bl	34181044 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34181128:	4b05      	ldr	r3, [pc, #20]	@ (34181140 <SysTick_Config+0x40>)
3418112a:	2200      	movs	r2, #0
3418112c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
3418112e:	4b04      	ldr	r3, [pc, #16]	@ (34181140 <SysTick_Config+0x40>)
34181130:	2207      	movs	r2, #7
34181132:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
34181134:	2300      	movs	r3, #0
}
34181136:	4618      	mov	r0, r3
34181138:	3708      	adds	r7, #8
3418113a:	46bd      	mov	sp, r7
3418113c:	bd80      	pop	{r7, pc}
3418113e:	bf00      	nop
34181140:	e000e010 	.word	0xe000e010

34181144 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34181144:	b580      	push	{r7, lr}
34181146:	b082      	sub	sp, #8
34181148:	af00      	add	r7, sp, #0
3418114a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
3418114c:	6878      	ldr	r0, [r7, #4]
3418114e:	f7ff ff47 	bl	34180fe0 <__NVIC_SetPriorityGrouping>
}
34181152:	bf00      	nop
34181154:	3708      	adds	r7, #8
34181156:	46bd      	mov	sp, r7
34181158:	bd80      	pop	{r7, pc}

3418115a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
3418115a:	b580      	push	{r7, lr}
3418115c:	b086      	sub	sp, #24
3418115e:	af00      	add	r7, sp, #0
34181160:	4603      	mov	r3, r0
34181162:	60b9      	str	r1, [r7, #8]
34181164:	607a      	str	r2, [r7, #4]
34181166:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
34181168:	f7ff ff5e 	bl	34181028 <__NVIC_GetPriorityGrouping>
3418116c:	4603      	mov	r3, r0
3418116e:	f003 0307 	and.w	r3, r3, #7
34181172:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
34181174:	687a      	ldr	r2, [r7, #4]
34181176:	68b9      	ldr	r1, [r7, #8]
34181178:	6978      	ldr	r0, [r7, #20]
3418117a:	f7ff ff8d 	bl	34181098 <NVIC_EncodePriority>
3418117e:	4602      	mov	r2, r0
34181180:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
34181184:	4611      	mov	r1, r2
34181186:	4618      	mov	r0, r3
34181188:	f7ff ff5c 	bl	34181044 <__NVIC_SetPriority>
}
3418118c:	bf00      	nop
3418118e:	3718      	adds	r7, #24
34181190:	46bd      	mov	sp, r7
34181192:	bd80      	pop	{r7, pc}

34181194 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
34181194:	b580      	push	{r7, lr}
34181196:	b082      	sub	sp, #8
34181198:	af00      	add	r7, sp, #0
3418119a:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
3418119c:	6878      	ldr	r0, [r7, #4]
3418119e:	f7ff ffaf 	bl	34181100 <SysTick_Config>
341811a2:	4603      	mov	r3, r0
}
341811a4:	4618      	mov	r0, r3
341811a6:	3708      	adds	r7, #8
341811a8:	46bd      	mov	sp, r7
341811aa:	bd80      	pop	{r7, pc}

341811ac <HAL_PWREx_ConfigSupply>:
  * @note: The power supply configuration is not reset by wakeup from Standby mode and
  *        application reset, but only reset by VDD POR.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply(uint32_t SupplySource)
{
341811ac:	b580      	push	{r7, lr}
341811ae:	b084      	sub	sp, #16
341811b0:	af00      	add	r7, sp, #0
341811b2:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_PWR_SUPPLY(SupplySource));

  /* Set the power supply configuration */
  MODIFY_REG(PWR->CR1, PWR_SUPPLY_CONFIG_MASK, SupplySource);
341811b4:	4b10      	ldr	r3, [pc, #64]	@ (341811f8 <HAL_PWREx_ConfigSupply+0x4c>)
341811b6:	681b      	ldr	r3, [r3, #0]
341811b8:	f023 0204 	bic.w	r2, r3, #4
341811bc:	490e      	ldr	r1, [pc, #56]	@ (341811f8 <HAL_PWREx_ConfigSupply+0x4c>)
341811be:	687b      	ldr	r3, [r7, #4]
341811c0:	4313      	orrs	r3, r2
341811c2:	600b      	str	r3, [r1, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
341811c4:	f7ff ff00 	bl	34180fc8 <HAL_GetTick>
341811c8:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
341811ca:	e009      	b.n	341811e0 <HAL_PWREx_ConfigSupply+0x34>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
341811cc:	f7ff fefc 	bl	34180fc8 <HAL_GetTick>
341811d0:	4602      	mov	r2, r0
341811d2:	68fb      	ldr	r3, [r7, #12]
341811d4:	1ad3      	subs	r3, r2, r3
341811d6:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
341811da:	d901      	bls.n	341811e0 <HAL_PWREx_ConfigSupply+0x34>
    {
      return HAL_ERROR;
341811dc:	2301      	movs	r3, #1
341811de:	e006      	b.n	341811ee <HAL_PWREx_ConfigSupply+0x42>
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
341811e0:	4b05      	ldr	r3, [pc, #20]	@ (341811f8 <HAL_PWREx_ConfigSupply+0x4c>)
341811e2:	6a1b      	ldr	r3, [r3, #32]
341811e4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
341811e8:	2b00      	cmp	r3, #0
341811ea:	d0ef      	beq.n	341811cc <HAL_PWREx_ConfigSupply+0x20>
    }
  }

  return HAL_OK;
341811ec:	2300      	movs	r3, #0
}
341811ee:	4618      	mov	r0, r3
341811f0:	3710      	adds	r7, #16
341811f2:	46bd      	mov	sp, r7
341811f4:	bd80      	pop	{r7, pc}
341811f6:	bf00      	nop
341811f8:	56024800 	.word	0x56024800

341811fc <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll SR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
341811fc:	b480      	push	{r7}
341811fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34181200:	4b06      	ldr	r3, [pc, #24]	@ (3418121c <LL_RCC_HSE_IsReady+0x20>)
34181202:	685b      	ldr	r3, [r3, #4]
34181204:	f003 0310 	and.w	r3, r3, #16
34181208:	2b00      	cmp	r3, #0
3418120a:	d001      	beq.n	34181210 <LL_RCC_HSE_IsReady+0x14>
3418120c:	2301      	movs	r3, #1
3418120e:	e000      	b.n	34181212 <LL_RCC_HSE_IsReady+0x16>
34181210:	2300      	movs	r3, #0
}
34181212:	4618      	mov	r0, r3
34181214:	46bd      	mov	sp, r7
34181216:	f85d 7b04 	ldr.w	r7, [sp], #4
3418121a:	4770      	bx	lr
3418121c:	56028000 	.word	0x56028000

34181220 <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI oscillator
  * @rmtoll CSR          HSIONS        LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
34181220:	b480      	push	{r7}
34181222:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_HSIONS);
34181224:	4b04      	ldr	r3, [pc, #16]	@ (34181238 <LL_RCC_HSI_Enable+0x18>)
34181226:	2208      	movs	r2, #8
34181228:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3418122c:	bf00      	nop
3418122e:	46bd      	mov	sp, r7
34181230:	f85d 7b04 	ldr.w	r7, [sp], #4
34181234:	4770      	bx	lr
34181236:	bf00      	nop
34181238:	56028000 	.word	0x56028000

3418123c <LL_RCC_HSI_Disable>:
  * @brief  Disable HSI oscillator
  * @rmtoll CCR          HSIONC        LL_RCC_HSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Disable(void)
{
3418123c:	b480      	push	{r7}
3418123e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_HSIONC);
34181240:	4b05      	ldr	r3, [pc, #20]	@ (34181258 <LL_RCC_HSI_Disable+0x1c>)
34181242:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181246:	461a      	mov	r2, r3
34181248:	2308      	movs	r3, #8
3418124a:	6013      	str	r3, [r2, #0]
}
3418124c:	bf00      	nop
3418124e:	46bd      	mov	sp, r7
34181250:	f85d 7b04 	ldr.w	r7, [sp], #4
34181254:	4770      	bx	lr
34181256:	bf00      	nop
34181258:	56028000 	.word	0x56028000

3418125c <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll SR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
3418125c:	b480      	push	{r7}
3418125e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
34181260:	4b06      	ldr	r3, [pc, #24]	@ (3418127c <LL_RCC_HSI_IsReady+0x20>)
34181262:	685b      	ldr	r3, [r3, #4]
34181264:	f003 0308 	and.w	r3, r3, #8
34181268:	2b00      	cmp	r3, #0
3418126a:	d001      	beq.n	34181270 <LL_RCC_HSI_IsReady+0x14>
3418126c:	2301      	movs	r3, #1
3418126e:	e000      	b.n	34181272 <LL_RCC_HSI_IsReady+0x16>
34181270:	2300      	movs	r3, #0
}
34181272:	4618      	mov	r0, r3
34181274:	46bd      	mov	sp, r7
34181276:	f85d 7b04 	ldr.w	r7, [sp], #4
3418127a:	4770      	bx	lr
3418127c:	56028000 	.word	0x56028000

34181280 <LL_RCC_HSI_SetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_HSI_SetDivider(uint32_t Divider)
{
34181280:	b480      	push	{r7}
34181282:	b083      	sub	sp, #12
34181284:	af00      	add	r7, sp, #0
34181286:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSIDIV, Divider);
34181288:	4b06      	ldr	r3, [pc, #24]	@ (341812a4 <LL_RCC_HSI_SetDivider+0x24>)
3418128a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418128c:	f423 72c0 	bic.w	r2, r3, #384	@ 0x180
34181290:	4904      	ldr	r1, [pc, #16]	@ (341812a4 <LL_RCC_HSI_SetDivider+0x24>)
34181292:	687b      	ldr	r3, [r7, #4]
34181294:	4313      	orrs	r3, r2
34181296:	648b      	str	r3, [r1, #72]	@ 0x48
}
34181298:	bf00      	nop
3418129a:	370c      	adds	r7, #12
3418129c:	46bd      	mov	sp, r7
3418129e:	f85d 7b04 	ldr.w	r7, [sp], #4
341812a2:	4770      	bx	lr
341812a4:	56028000 	.word	0x56028000

341812a8 <LL_RCC_HSI_GetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_2
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_GetDivider(void)
{
341812a8:	b480      	push	{r7}
341812aa:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
341812ac:	4b04      	ldr	r3, [pc, #16]	@ (341812c0 <LL_RCC_HSI_GetDivider+0x18>)
341812ae:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341812b0:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
341812b4:	4618      	mov	r0, r3
341812b6:	46bd      	mov	sp, r7
341812b8:	f85d 7b04 	ldr.w	r7, [sp], #4
341812bc:	4770      	bx	lr
341812be:	bf00      	nop
341812c0:	56028000 	.word	0x56028000

341812c4 <LL_RCC_HSI_SetCalibTrimming>:
  * @rmtoll HSICFGR      HSITRIM       LL_RCC_HSI_SetCalibTrimming
  * @param  Value This parameter can be a value between 0 and 63
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_SetCalibTrimming(uint32_t Value)
{
341812c4:	b480      	push	{r7}
341812c6:	b083      	sub	sp, #12
341812c8:	af00      	add	r7, sp, #0
341812ca:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
341812cc:	4b07      	ldr	r3, [pc, #28]	@ (341812ec <LL_RCC_HSI_SetCalibTrimming+0x28>)
341812ce:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341812d0:	f423 02fe 	bic.w	r2, r3, #8323072	@ 0x7f0000
341812d4:	687b      	ldr	r3, [r7, #4]
341812d6:	041b      	lsls	r3, r3, #16
341812d8:	4904      	ldr	r1, [pc, #16]	@ (341812ec <LL_RCC_HSI_SetCalibTrimming+0x28>)
341812da:	4313      	orrs	r3, r2
341812dc:	648b      	str	r3, [r1, #72]	@ 0x48
}
341812de:	bf00      	nop
341812e0:	370c      	adds	r7, #12
341812e2:	46bd      	mov	sp, r7
341812e4:	f85d 7b04 	ldr.w	r7, [sp], #4
341812e8:	4770      	bx	lr
341812ea:	bf00      	nop
341812ec:	56028000 	.word	0x56028000

341812f0 <LL_RCC_MSI_Enable>:
  * @brief  Enable MSI oscillator
  * @rmtoll CSR          MSIONS        LL_RCC_MSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Enable(void)
{
341812f0:	b480      	push	{r7}
341812f2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_MSIONS);
341812f4:	4b04      	ldr	r3, [pc, #16]	@ (34181308 <LL_RCC_MSI_Enable+0x18>)
341812f6:	2204      	movs	r2, #4
341812f8:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
341812fc:	bf00      	nop
341812fe:	46bd      	mov	sp, r7
34181300:	f85d 7b04 	ldr.w	r7, [sp], #4
34181304:	4770      	bx	lr
34181306:	bf00      	nop
34181308:	56028000 	.word	0x56028000

3418130c <LL_RCC_MSI_Disable>:
  * @brief  Disable MSI oscillator
  * @rmtoll CCR          MSIONC        LL_RCC_MSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Disable(void)
{
3418130c:	b480      	push	{r7}
3418130e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_MSIONC);
34181310:	4b05      	ldr	r3, [pc, #20]	@ (34181328 <LL_RCC_MSI_Disable+0x1c>)
34181312:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181316:	461a      	mov	r2, r3
34181318:	2304      	movs	r3, #4
3418131a:	6013      	str	r3, [r2, #0]
}
3418131c:	bf00      	nop
3418131e:	46bd      	mov	sp, r7
34181320:	f85d 7b04 	ldr.w	r7, [sp], #4
34181324:	4770      	bx	lr
34181326:	bf00      	nop
34181328:	56028000 	.word	0x56028000

3418132c <LL_RCC_MSI_IsReady>:
  * @brief  Check if MSI clock is ready
  * @rmtoll SR           MSIRDY        LL_RCC_MSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_IsReady(void)
{
3418132c:	b480      	push	{r7}
3418132e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
34181330:	4b06      	ldr	r3, [pc, #24]	@ (3418134c <LL_RCC_MSI_IsReady+0x20>)
34181332:	685b      	ldr	r3, [r3, #4]
34181334:	f003 0304 	and.w	r3, r3, #4
34181338:	2b00      	cmp	r3, #0
3418133a:	d001      	beq.n	34181340 <LL_RCC_MSI_IsReady+0x14>
3418133c:	2301      	movs	r3, #1
3418133e:	e000      	b.n	34181342 <LL_RCC_MSI_IsReady+0x16>
34181340:	2300      	movs	r3, #0
}
34181342:	4618      	mov	r0, r3
34181344:	46bd      	mov	sp, r7
34181346:	f85d 7b04 	ldr.w	r7, [sp], #4
3418134a:	4770      	bx	lr
3418134c:	56028000 	.word	0x56028000

34181350 <LL_RCC_MSI_SetFrequency>:
  *         @arg @ref LL_RCC_MSI_FREQ_4MHZ
  *         @arg @ref LL_RCC_MSI_FREQ_16MHZ
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_MSI_SetFrequency(uint32_t Value)
{
34181350:	b480      	push	{r7}
34181352:	b083      	sub	sp, #12
34181354:	af00      	add	r7, sp, #0
34181356:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL, Value);
34181358:	4b06      	ldr	r3, [pc, #24]	@ (34181374 <LL_RCC_MSI_SetFrequency+0x24>)
3418135a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418135c:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34181360:	4904      	ldr	r1, [pc, #16]	@ (34181374 <LL_RCC_MSI_SetFrequency+0x24>)
34181362:	687b      	ldr	r3, [r7, #4]
34181364:	4313      	orrs	r3, r2
34181366:	644b      	str	r3, [r1, #68]	@ 0x44
}
34181368:	bf00      	nop
3418136a:	370c      	adds	r7, #12
3418136c:	46bd      	mov	sp, r7
3418136e:	f85d 7b04 	ldr.w	r7, [sp], #4
34181372:	4770      	bx	lr
34181374:	56028000 	.word	0x56028000

34181378 <LL_RCC_MSI_GetFrequency>:
  * @retval can be one of the following values:
  *         @arg @ref LL_RCC_MSI_FREQ_4MHZ
  *         @arg @ref LL_RCC_MSI_FREQ_16MHZ
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_GetFrequency(void)
{
34181378:	b480      	push	{r7}
3418137a:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3418137c:	4b04      	ldr	r3, [pc, #16]	@ (34181390 <LL_RCC_MSI_GetFrequency+0x18>)
3418137e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34181380:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
34181384:	4618      	mov	r0, r3
34181386:	46bd      	mov	sp, r7
34181388:	f85d 7b04 	ldr.w	r7, [sp], #4
3418138c:	4770      	bx	lr
3418138e:	bf00      	nop
34181390:	56028000 	.word	0x56028000

34181394 <LL_RCC_MSI_SetCalibTrimming>:
  * @rmtoll MSICFGR      MSITRIM       LL_RCC_MSI_SetCalibTrimming
  * @param  Value can be a value between 0 and 31
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_SetCalibTrimming(uint32_t Value)
{
34181394:	b480      	push	{r7}
34181396:	b083      	sub	sp, #12
34181398:	af00      	add	r7, sp, #0
3418139a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSITRIM, Value << RCC_MSICFGR_MSITRIM_Pos);
3418139c:	4b07      	ldr	r3, [pc, #28]	@ (341813bc <LL_RCC_MSI_SetCalibTrimming+0x28>)
3418139e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341813a0:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
341813a4:	687b      	ldr	r3, [r7, #4]
341813a6:	041b      	lsls	r3, r3, #16
341813a8:	4904      	ldr	r1, [pc, #16]	@ (341813bc <LL_RCC_MSI_SetCalibTrimming+0x28>)
341813aa:	4313      	orrs	r3, r2
341813ac:	644b      	str	r3, [r1, #68]	@ 0x44
}
341813ae:	bf00      	nop
341813b0:	370c      	adds	r7, #12
341813b2:	46bd      	mov	sp, r7
341813b4:	f85d 7b04 	ldr.w	r7, [sp], #4
341813b8:	4770      	bx	lr
341813ba:	bf00      	nop
341813bc:	56028000 	.word	0x56028000

341813c0 <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll SR           LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
341813c0:	b480      	push	{r7}
341813c2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
341813c4:	4b06      	ldr	r3, [pc, #24]	@ (341813e0 <LL_RCC_LSE_IsReady+0x20>)
341813c6:	685b      	ldr	r3, [r3, #4]
341813c8:	f003 0302 	and.w	r3, r3, #2
341813cc:	2b00      	cmp	r3, #0
341813ce:	d001      	beq.n	341813d4 <LL_RCC_LSE_IsReady+0x14>
341813d0:	2301      	movs	r3, #1
341813d2:	e000      	b.n	341813d6 <LL_RCC_LSE_IsReady+0x16>
341813d4:	2300      	movs	r3, #0
}
341813d6:	4618      	mov	r0, r3
341813d8:	46bd      	mov	sp, r7
341813da:	f85d 7b04 	ldr.w	r7, [sp], #4
341813de:	4770      	bx	lr
341813e0:	56028000 	.word	0x56028000

341813e4 <LL_RCC_LSI_Enable>:
  * @brief  Enable LSI Oscillator
  * @rmtoll CSR          LSIONS        LL_RCC_LSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Enable(void)
{
341813e4:	b480      	push	{r7}
341813e6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_LSIONS);
341813e8:	4b04      	ldr	r3, [pc, #16]	@ (341813fc <LL_RCC_LSI_Enable+0x18>)
341813ea:	2201      	movs	r2, #1
341813ec:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
341813f0:	bf00      	nop
341813f2:	46bd      	mov	sp, r7
341813f4:	f85d 7b04 	ldr.w	r7, [sp], #4
341813f8:	4770      	bx	lr
341813fa:	bf00      	nop
341813fc:	56028000 	.word	0x56028000

34181400 <LL_RCC_LSI_Disable>:
  * @brief  Disable LSI Oscillator
  * @rmtoll CCR          LSIONC        LL_RCC_LSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Disable(void)
{
34181400:	b480      	push	{r7}
34181402:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
34181404:	4b05      	ldr	r3, [pc, #20]	@ (3418141c <LL_RCC_LSI_Disable+0x1c>)
34181406:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418140a:	461a      	mov	r2, r3
3418140c:	2301      	movs	r3, #1
3418140e:	6013      	str	r3, [r2, #0]
}
34181410:	bf00      	nop
34181412:	46bd      	mov	sp, r7
34181414:	f85d 7b04 	ldr.w	r7, [sp], #4
34181418:	4770      	bx	lr
3418141a:	bf00      	nop
3418141c:	56028000 	.word	0x56028000

34181420 <LL_RCC_LSI_IsReady>:
  * @brief  Check if LSI is Ready
  * @rmtoll SR           LSIRDY        LL_RCC_LSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSI_IsReady(void)
{
34181420:	b480      	push	{r7}
34181422:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
34181424:	4b04      	ldr	r3, [pc, #16]	@ (34181438 <LL_RCC_LSI_IsReady+0x18>)
34181426:	685b      	ldr	r3, [r3, #4]
34181428:	f003 0301 	and.w	r3, r3, #1
}
3418142c:	4618      	mov	r0, r3
3418142e:	46bd      	mov	sp, r7
34181430:	f85d 7b04 	ldr.w	r7, [sp], #4
34181434:	4770      	bx	lr
34181436:	bf00      	nop
34181438:	56028000 	.word	0x56028000

3418143c <LL_RCC_GetCpuClkSource>:
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_IC1
  */
__STATIC_INLINE uint32_t LL_RCC_GetCpuClkSource(void)
{
3418143c:	b480      	push	{r7}
3418143e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
34181440:	4b04      	ldr	r3, [pc, #16]	@ (34181454 <LL_RCC_GetCpuClkSource+0x18>)
34181442:	6a1b      	ldr	r3, [r3, #32]
34181444:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
34181448:	4618      	mov	r0, r3
3418144a:	46bd      	mov	sp, r7
3418144c:	f85d 7b04 	ldr.w	r7, [sp], #4
34181450:	4770      	bx	lr
34181452:	bf00      	nop
34181454:	56028000 	.word	0x56028000

34181458 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_IC2_IC6_IC11
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
34181458:	b480      	push	{r7}
3418145a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
3418145c:	4b04      	ldr	r3, [pc, #16]	@ (34181470 <LL_RCC_GetSysClkSource+0x18>)
3418145e:	6a1b      	ldr	r3, [r3, #32]
34181460:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34181464:	4618      	mov	r0, r3
34181466:	46bd      	mov	sp, r7
34181468:	f85d 7b04 	ldr.w	r7, [sp], #4
3418146c:	4770      	bx	lr
3418146e:	bf00      	nop
34181470:	56028000 	.word	0x56028000

34181474 <LL_RCC_PLL1_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetSource(void)
{
34181474:	b480      	push	{r7}
34181476:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
34181478:	4b04      	ldr	r3, [pc, #16]	@ (3418148c <LL_RCC_PLL1_GetSource+0x18>)
3418147a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418147e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34181482:	4618      	mov	r0, r3
34181484:	46bd      	mov	sp, r7
34181486:	f85d 7b04 	ldr.w	r7, [sp], #4
3418148a:	4770      	bx	lr
3418148c:	56028000 	.word	0x56028000

34181490 <LL_RCC_PLL1_IsReady>:
  * @brief  Check if PLL1 Ready
  * @rmtoll SR           PLL1RDY         LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
34181490:	b480      	push	{r7}
34181492:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
34181494:	4b07      	ldr	r3, [pc, #28]	@ (341814b4 <LL_RCC_PLL1_IsReady+0x24>)
34181496:	685b      	ldr	r3, [r3, #4]
34181498:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418149c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
341814a0:	d101      	bne.n	341814a6 <LL_RCC_PLL1_IsReady+0x16>
341814a2:	2301      	movs	r3, #1
341814a4:	e000      	b.n	341814a8 <LL_RCC_PLL1_IsReady+0x18>
341814a6:	2300      	movs	r3, #0
}
341814a8:	4618      	mov	r0, r3
341814aa:	46bd      	mov	sp, r7
341814ac:	f85d 7b04 	ldr.w	r7, [sp], #4
341814b0:	4770      	bx	lr
341814b2:	bf00      	nop
341814b4:	56028000 	.word	0x56028000

341814b8 <LL_RCC_PLL1_IsEnabledBypass>:
  * @brief  Check if PLL1 bypass is enabled
  * @rmtoll PLL1CFGR1    PLL1BYP         LL_RCC_PLL1_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsEnabledBypass(void)
{
341814b8:	b480      	push	{r7}
341814ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
341814bc:	4b07      	ldr	r3, [pc, #28]	@ (341814dc <LL_RCC_PLL1_IsEnabledBypass+0x24>)
341814be:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341814c2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
341814c6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341814ca:	d101      	bne.n	341814d0 <LL_RCC_PLL1_IsEnabledBypass+0x18>
341814cc:	2301      	movs	r3, #1
341814ce:	e000      	b.n	341814d2 <LL_RCC_PLL1_IsEnabledBypass+0x1a>
341814d0:	2300      	movs	r3, #0
}
341814d2:	4618      	mov	r0, r3
341814d4:	46bd      	mov	sp, r7
341814d6:	f85d 7b04 	ldr.w	r7, [sp], #4
341814da:	4770      	bx	lr
341814dc:	56028000 	.word	0x56028000

341814e0 <LL_RCC_PLL2_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetSource(void)
{
341814e0:	b480      	push	{r7}
341814e2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
341814e4:	4b04      	ldr	r3, [pc, #16]	@ (341814f8 <LL_RCC_PLL2_GetSource+0x18>)
341814e6:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
341814ea:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
341814ee:	4618      	mov	r0, r3
341814f0:	46bd      	mov	sp, r7
341814f2:	f85d 7b04 	ldr.w	r7, [sp], #4
341814f6:	4770      	bx	lr
341814f8:	56028000 	.word	0x56028000

341814fc <LL_RCC_PLL2_IsReady>:
  * @brief  Check if PLL2 Ready
  * @rmtoll SR           PLL2RDY         LL_RCC_PLL2_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsReady(void)
{
341814fc:	b480      	push	{r7}
341814fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34181500:	4b07      	ldr	r3, [pc, #28]	@ (34181520 <LL_RCC_PLL2_IsReady+0x24>)
34181502:	685b      	ldr	r3, [r3, #4]
34181504:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34181508:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418150c:	d101      	bne.n	34181512 <LL_RCC_PLL2_IsReady+0x16>
3418150e:	2301      	movs	r3, #1
34181510:	e000      	b.n	34181514 <LL_RCC_PLL2_IsReady+0x18>
34181512:	2300      	movs	r3, #0
}
34181514:	4618      	mov	r0, r3
34181516:	46bd      	mov	sp, r7
34181518:	f85d 7b04 	ldr.w	r7, [sp], #4
3418151c:	4770      	bx	lr
3418151e:	bf00      	nop
34181520:	56028000 	.word	0x56028000

34181524 <LL_RCC_PLL2_IsEnabledBypass>:
  * @brief  Check if PLL2 bypass is enabled
  * @rmtoll PLL2CFGR1    PLL2BYP         LL_RCC_PLL2_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsEnabledBypass(void)
{
34181524:	b480      	push	{r7}
34181526:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34181528:	4b07      	ldr	r3, [pc, #28]	@ (34181548 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
3418152a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418152e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34181532:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34181536:	d101      	bne.n	3418153c <LL_RCC_PLL2_IsEnabledBypass+0x18>
34181538:	2301      	movs	r3, #1
3418153a:	e000      	b.n	3418153e <LL_RCC_PLL2_IsEnabledBypass+0x1a>
3418153c:	2300      	movs	r3, #0
}
3418153e:	4618      	mov	r0, r3
34181540:	46bd      	mov	sp, r7
34181542:	f85d 7b04 	ldr.w	r7, [sp], #4
34181546:	4770      	bx	lr
34181548:	56028000 	.word	0x56028000

3418154c <LL_RCC_PLL3_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetSource(void)
{
3418154c:	b480      	push	{r7}
3418154e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
34181550:	4b04      	ldr	r3, [pc, #16]	@ (34181564 <LL_RCC_PLL3_GetSource+0x18>)
34181552:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34181556:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418155a:	4618      	mov	r0, r3
3418155c:	46bd      	mov	sp, r7
3418155e:	f85d 7b04 	ldr.w	r7, [sp], #4
34181562:	4770      	bx	lr
34181564:	56028000 	.word	0x56028000

34181568 <LL_RCC_PLL3_IsReady>:
  * @brief  Check if PLL3 Ready
  * @rmtoll SR           PLL3RDY         LL_RCC_PLL3_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsReady(void)
{
34181568:	b480      	push	{r7}
3418156a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3418156c:	4b07      	ldr	r3, [pc, #28]	@ (3418158c <LL_RCC_PLL3_IsReady+0x24>)
3418156e:	685b      	ldr	r3, [r3, #4]
34181570:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34181574:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34181578:	d101      	bne.n	3418157e <LL_RCC_PLL3_IsReady+0x16>
3418157a:	2301      	movs	r3, #1
3418157c:	e000      	b.n	34181580 <LL_RCC_PLL3_IsReady+0x18>
3418157e:	2300      	movs	r3, #0
}
34181580:	4618      	mov	r0, r3
34181582:	46bd      	mov	sp, r7
34181584:	f85d 7b04 	ldr.w	r7, [sp], #4
34181588:	4770      	bx	lr
3418158a:	bf00      	nop
3418158c:	56028000 	.word	0x56028000

34181590 <LL_RCC_PLL3_IsEnabledBypass>:
  * @brief  Check if PLL3 bypass is enabled
  * @rmtoll PLL3CFGR1    PLL3BYP         LL_RCC_PLL3_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsEnabledBypass(void)
{
34181590:	b480      	push	{r7}
34181592:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
34181594:	4b07      	ldr	r3, [pc, #28]	@ (341815b4 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
34181596:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418159a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418159e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341815a2:	d101      	bne.n	341815a8 <LL_RCC_PLL3_IsEnabledBypass+0x18>
341815a4:	2301      	movs	r3, #1
341815a6:	e000      	b.n	341815aa <LL_RCC_PLL3_IsEnabledBypass+0x1a>
341815a8:	2300      	movs	r3, #0
}
341815aa:	4618      	mov	r0, r3
341815ac:	46bd      	mov	sp, r7
341815ae:	f85d 7b04 	ldr.w	r7, [sp], #4
341815b2:	4770      	bx	lr
341815b4:	56028000 	.word	0x56028000

341815b8 <LL_RCC_PLL4_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_GetSource(void)
{
341815b8:	b480      	push	{r7}
341815ba:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
341815bc:	4b04      	ldr	r3, [pc, #16]	@ (341815d0 <LL_RCC_PLL4_GetSource+0x18>)
341815be:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
341815c2:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
341815c6:	4618      	mov	r0, r3
341815c8:	46bd      	mov	sp, r7
341815ca:	f85d 7b04 	ldr.w	r7, [sp], #4
341815ce:	4770      	bx	lr
341815d0:	56028000 	.word	0x56028000

341815d4 <LL_RCC_PLL4_IsReady>:
  * @brief  Check if PLL4 Ready
  * @rmtoll SR           PLL4RDY         LL_RCC_PLL4_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsReady(void)
{
341815d4:	b480      	push	{r7}
341815d6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
341815d8:	4b07      	ldr	r3, [pc, #28]	@ (341815f8 <LL_RCC_PLL4_IsReady+0x24>)
341815da:	685b      	ldr	r3, [r3, #4]
341815dc:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
341815e0:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
341815e4:	d101      	bne.n	341815ea <LL_RCC_PLL4_IsReady+0x16>
341815e6:	2301      	movs	r3, #1
341815e8:	e000      	b.n	341815ec <LL_RCC_PLL4_IsReady+0x18>
341815ea:	2300      	movs	r3, #0
}
341815ec:	4618      	mov	r0, r3
341815ee:	46bd      	mov	sp, r7
341815f0:	f85d 7b04 	ldr.w	r7, [sp], #4
341815f4:	4770      	bx	lr
341815f6:	bf00      	nop
341815f8:	56028000 	.word	0x56028000

341815fc <LL_RCC_PLL4_IsEnabledBypass>:
  * @brief  Check if PLL4 bypass is enabled
  * @rmtoll PLL4CFGR1    PLL4BYP         LL_RCC_PLL4_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsEnabledBypass(void)
{
341815fc:	b480      	push	{r7}
341815fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34181600:	4b07      	ldr	r3, [pc, #28]	@ (34181620 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
34181602:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34181606:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418160a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418160e:	d101      	bne.n	34181614 <LL_RCC_PLL4_IsEnabledBypass+0x18>
34181610:	2301      	movs	r3, #1
34181612:	e000      	b.n	34181616 <LL_RCC_PLL4_IsEnabledBypass+0x1a>
34181614:	2300      	movs	r3, #0
}
34181616:	4618      	mov	r0, r3
34181618:	46bd      	mov	sp, r7
3418161a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418161e:	4770      	bx	lr
34181620:	56028000 	.word	0x56028000

34181624 <LL_RCC_IC1_Enable>:
  * @brief  Enable IC1
  * @rmtoll DIVENSR      IC1ENS        LL_RCC_IC1_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC1_Enable(void)
{
34181624:	b480      	push	{r7}
34181626:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC1ENS);
34181628:	4b04      	ldr	r3, [pc, #16]	@ (3418163c <LL_RCC_IC1_Enable+0x18>)
3418162a:	2201      	movs	r2, #1
3418162c:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34181630:	bf00      	nop
34181632:	46bd      	mov	sp, r7
34181634:	f85d 7b04 	ldr.w	r7, [sp], #4
34181638:	4770      	bx	lr
3418163a:	bf00      	nop
3418163c:	56028000 	.word	0x56028000

34181640 <LL_RCC_IC1_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetSource(void)
{
34181640:	b480      	push	{r7}
34181642:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34181644:	4b04      	ldr	r3, [pc, #16]	@ (34181658 <LL_RCC_IC1_GetSource+0x18>)
34181646:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418164a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418164e:	4618      	mov	r0, r3
34181650:	46bd      	mov	sp, r7
34181652:	f85d 7b04 	ldr.w	r7, [sp], #4
34181656:	4770      	bx	lr
34181658:	56028000 	.word	0x56028000

3418165c <LL_RCC_IC1_GetDivider>:
  * @brief  Get IC1 divider
  * @rmtoll IC1CFGR      IC1INT        LL_RCC_IC1_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetDivider(void)
{
3418165c:	b480      	push	{r7}
3418165e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
34181660:	4b05      	ldr	r3, [pc, #20]	@ (34181678 <LL_RCC_IC1_GetDivider+0x1c>)
34181662:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34181666:	0c1b      	lsrs	r3, r3, #16
34181668:	b2db      	uxtb	r3, r3
3418166a:	3301      	adds	r3, #1
}
3418166c:	4618      	mov	r0, r3
3418166e:	46bd      	mov	sp, r7
34181670:	f85d 7b04 	ldr.w	r7, [sp], #4
34181674:	4770      	bx	lr
34181676:	bf00      	nop
34181678:	56028000 	.word	0x56028000

3418167c <LL_RCC_IC2_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
3418167c:	b480      	push	{r7}
3418167e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34181680:	4b04      	ldr	r3, [pc, #16]	@ (34181694 <LL_RCC_IC2_GetSource+0x18>)
34181682:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34181686:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418168a:	4618      	mov	r0, r3
3418168c:	46bd      	mov	sp, r7
3418168e:	f85d 7b04 	ldr.w	r7, [sp], #4
34181692:	4770      	bx	lr
34181694:	56028000 	.word	0x56028000

34181698 <LL_RCC_IC6_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC6_GetSource(void)
{
34181698:	b480      	push	{r7}
3418169a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3418169c:	4b04      	ldr	r3, [pc, #16]	@ (341816b0 <LL_RCC_IC6_GetSource+0x18>)
3418169e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
341816a2:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
341816a6:	4618      	mov	r0, r3
341816a8:	46bd      	mov	sp, r7
341816aa:	f85d 7b04 	ldr.w	r7, [sp], #4
341816ae:	4770      	bx	lr
341816b0:	56028000 	.word	0x56028000

341816b4 <LL_RCC_IC11_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC11_GetSource(void)
{
341816b4:	b480      	push	{r7}
341816b6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
341816b8:	4b04      	ldr	r3, [pc, #16]	@ (341816cc <LL_RCC_IC11_GetSource+0x18>)
341816ba:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
341816be:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
341816c2:	4618      	mov	r0, r3
341816c4:	46bd      	mov	sp, r7
341816c6:	f85d 7b04 	ldr.w	r7, [sp], #4
341816ca:	4770      	bx	lr
341816cc:	56028000 	.word	0x56028000

341816d0 <HAL_RCC_OscConfig>:
  * @note   This function activates HSE but does not wait for the startup time defined in the datasheet.
  *         This must be ensured by the application when the HSE is selected as PLL source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
341816d0:	b580      	push	{r7, lr}
341816d2:	b0a2      	sub	sp, #136	@ 0x88
341816d4:	af00      	add	r7, sp, #0
341816d6:	6078      	str	r0, [r7, #4]
  uint32_t pll3src;
  uint32_t pll4src;
  uint32_t rccsr;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
341816d8:	687b      	ldr	r3, [r7, #4]
341816da:	2b00      	cmp	r3, #0
341816dc:	d101      	bne.n	341816e2 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
341816de:	2301      	movs	r3, #1
341816e0:	e3d1      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));

  cpuclksrc = LL_RCC_GetCpuClkSource();
341816e2:	f7ff feab 	bl	3418143c <LL_RCC_GetCpuClkSource>
341816e6:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
  sysclksrc = LL_RCC_GetSysClkSource();
341816ea:	f7ff feb5 	bl	34181458 <LL_RCC_GetSysClkSource>
341816ee:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
  pll1src = LL_RCC_PLL1_GetSource();
341816f2:	f7ff febf 	bl	34181474 <LL_RCC_PLL1_GetSource>
341816f6:	67f8      	str	r0, [r7, #124]	@ 0x7c
  pll2src = LL_RCC_PLL2_GetSource();
341816f8:	f7ff fef2 	bl	341814e0 <LL_RCC_PLL2_GetSource>
341816fc:	67b8      	str	r0, [r7, #120]	@ 0x78
  pll3src = LL_RCC_PLL3_GetSource();
341816fe:	f7ff ff25 	bl	3418154c <LL_RCC_PLL3_GetSource>
34181702:	6778      	str	r0, [r7, #116]	@ 0x74
  pll4src = LL_RCC_PLL4_GetSource();
34181704:	f7ff ff58 	bl	341815b8 <LL_RCC_PLL4_GetSource>
34181708:	6738      	str	r0, [r7, #112]	@ 0x70
  rccsr = RCC->SR;
3418170a:	4b91      	ldr	r3, [pc, #580]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
3418170c:	685b      	ldr	r3, [r3, #4]
3418170e:	66fb      	str	r3, [r7, #108]	@ 0x6c

  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
34181710:	687b      	ldr	r3, [r7, #4]
34181712:	681b      	ldr	r3, [r3, #0]
34181714:	f003 0301 	and.w	r3, r3, #1
34181718:	2b00      	cmp	r3, #0
3418171a:	f000 80a8 	beq.w	3418186e <HAL_RCC_OscConfig+0x19e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));

    /* When the HSE is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
3418171e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34181722:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34181726:	d028      	beq.n	3418177a <HAL_RCC_OscConfig+0xaa>
34181728:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418172c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34181730:	d023      	beq.n	3418177a <HAL_RCC_OscConfig+0xaa>
34181732:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34181734:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34181738:	d104      	bne.n	34181744 <HAL_RCC_OscConfig+0x74>
        ((pll1src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3418173a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418173c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34181740:	2b00      	cmp	r3, #0
34181742:	d11a      	bne.n	3418177a <HAL_RCC_OscConfig+0xaa>
34181744:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34181746:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418174a:	d104      	bne.n	34181756 <HAL_RCC_OscConfig+0x86>
        ((pll2src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3418174c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418174e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34181752:	2b00      	cmp	r3, #0
34181754:	d111      	bne.n	3418177a <HAL_RCC_OscConfig+0xaa>
34181756:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34181758:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418175c:	d104      	bne.n	34181768 <HAL_RCC_OscConfig+0x98>
        ((pll3src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3418175e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34181760:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34181764:	2b00      	cmp	r3, #0
34181766:	d108      	bne.n	3418177a <HAL_RCC_OscConfig+0xaa>
34181768:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3418176a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418176e:	d10a      	bne.n	34181786 <HAL_RCC_OscConfig+0xb6>
        ((pll4src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34181770:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34181772:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34181776:	2b00      	cmp	r3, #0
34181778:	d005      	beq.n	34181786 <HAL_RCC_OscConfig+0xb6>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
3418177a:	687b      	ldr	r3, [r7, #4]
3418177c:	685b      	ldr	r3, [r3, #4]
3418177e:	2b00      	cmp	r3, #0
34181780:	d175      	bne.n	3418186e <HAL_RCC_OscConfig+0x19e>
      {
        return HAL_ERROR;
34181782:	2301      	movs	r3, #1
34181784:	e37f      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      /* HSE ON , nothing to do */
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
34181786:	687b      	ldr	r3, [r7, #4]
34181788:	685b      	ldr	r3, [r3, #4]
3418178a:	2b10      	cmp	r3, #16
3418178c:	d104      	bne.n	34181798 <HAL_RCC_OscConfig+0xc8>
3418178e:	4b70      	ldr	r3, [pc, #448]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
34181790:	2210      	movs	r2, #16
34181792:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34181796:	e043      	b.n	34181820 <HAL_RCC_OscConfig+0x150>
34181798:	687b      	ldr	r3, [r7, #4]
3418179a:	685b      	ldr	r3, [r3, #4]
3418179c:	2b00      	cmp	r3, #0
3418179e:	d10c      	bne.n	341817ba <HAL_RCC_OscConfig+0xea>
341817a0:	4b6b      	ldr	r3, [pc, #428]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
341817a2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341817a6:	461a      	mov	r2, r3
341817a8:	2310      	movs	r3, #16
341817aa:	6013      	str	r3, [r2, #0]
341817ac:	4b68      	ldr	r3, [pc, #416]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
341817ae:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341817b0:	4a67      	ldr	r2, [pc, #412]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
341817b2:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
341817b6:	6553      	str	r3, [r2, #84]	@ 0x54
341817b8:	e032      	b.n	34181820 <HAL_RCC_OscConfig+0x150>
341817ba:	687b      	ldr	r3, [r7, #4]
341817bc:	685b      	ldr	r3, [r3, #4]
341817be:	f248 0210 	movw	r2, #32784	@ 0x8010
341817c2:	4293      	cmp	r3, r2
341817c4:	d110      	bne.n	341817e8 <HAL_RCC_OscConfig+0x118>
341817c6:	4b62      	ldr	r3, [pc, #392]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
341817c8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341817ca:	4a61      	ldr	r2, [pc, #388]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
341817cc:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
341817d0:	6553      	str	r3, [r2, #84]	@ 0x54
341817d2:	4b5f      	ldr	r3, [pc, #380]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
341817d4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341817d6:	4a5e      	ldr	r2, [pc, #376]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
341817d8:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
341817dc:	6553      	str	r3, [r2, #84]	@ 0x54
341817de:	4b5c      	ldr	r3, [pc, #368]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
341817e0:	2210      	movs	r2, #16
341817e2:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
341817e6:	e01b      	b.n	34181820 <HAL_RCC_OscConfig+0x150>
341817e8:	687b      	ldr	r3, [r7, #4]
341817ea:	685b      	ldr	r3, [r3, #4]
341817ec:	4a59      	ldr	r2, [pc, #356]	@ (34181954 <HAL_RCC_OscConfig+0x284>)
341817ee:	4293      	cmp	r3, r2
341817f0:	d10a      	bne.n	34181808 <HAL_RCC_OscConfig+0x138>
341817f2:	4b57      	ldr	r3, [pc, #348]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
341817f4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341817f6:	4a56      	ldr	r2, [pc, #344]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
341817f8:	f443 33c0 	orr.w	r3, r3, #98304	@ 0x18000
341817fc:	6553      	str	r3, [r2, #84]	@ 0x54
341817fe:	4b54      	ldr	r3, [pc, #336]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
34181800:	2210      	movs	r2, #16
34181802:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34181806:	e00b      	b.n	34181820 <HAL_RCC_OscConfig+0x150>
34181808:	4b51      	ldr	r3, [pc, #324]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
3418180a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418180e:	461a      	mov	r2, r3
34181810:	2310      	movs	r3, #16
34181812:	6013      	str	r3, [r2, #0]
34181814:	4b4e      	ldr	r3, [pc, #312]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
34181816:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34181818:	4a4d      	ldr	r2, [pc, #308]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
3418181a:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
3418181e:	6553      	str	r3, [r2, #84]	@ 0x54

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34181820:	f7ff fbd2 	bl	34180fc8 <HAL_GetTick>
34181824:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
34181826:	687b      	ldr	r3, [r7, #4]
34181828:	685b      	ldr	r3, [r3, #4]
3418182a:	2b00      	cmp	r3, #0
3418182c:	d019      	beq.n	34181862 <HAL_RCC_OscConfig+0x192>
      {
        /* Wait till HSE is ready */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
3418182e:	e008      	b.n	34181842 <HAL_RCC_OscConfig+0x172>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34181830:	f7ff fbca 	bl	34180fc8 <HAL_GetTick>
34181834:	4602      	mov	r2, r0
34181836:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34181838:	1ad3      	subs	r3, r2, r3
3418183a:	2b64      	cmp	r3, #100	@ 0x64
3418183c:	d901      	bls.n	34181842 <HAL_RCC_OscConfig+0x172>
          {
            return HAL_TIMEOUT;
3418183e:	2303      	movs	r3, #3
34181840:	e321      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
34181842:	4b43      	ldr	r3, [pc, #268]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
34181844:	685b      	ldr	r3, [r3, #4]
34181846:	f003 0310 	and.w	r3, r3, #16
3418184a:	2b00      	cmp	r3, #0
3418184c:	d0f0      	beq.n	34181830 <HAL_RCC_OscConfig+0x160>
3418184e:	e00e      	b.n	3418186e <HAL_RCC_OscConfig+0x19e>
      else
      {
        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34181850:	f7ff fbba 	bl	34180fc8 <HAL_GetTick>
34181854:	4602      	mov	r2, r0
34181856:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34181858:	1ad3      	subs	r3, r2, r3
3418185a:	2b64      	cmp	r3, #100	@ 0x64
3418185c:	d901      	bls.n	34181862 <HAL_RCC_OscConfig+0x192>
          {
            return HAL_TIMEOUT;
3418185e:	2303      	movs	r3, #3
34181860:	e311      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
34181862:	4b3b      	ldr	r3, [pc, #236]	@ (34181950 <HAL_RCC_OscConfig+0x280>)
34181864:	685b      	ldr	r3, [r3, #4]
34181866:	f003 0310 	and.w	r3, r3, #16
3418186a:	2b00      	cmp	r3, #0
3418186c:	d1f0      	bne.n	34181850 <HAL_RCC_OscConfig+0x180>
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
3418186e:	687b      	ldr	r3, [r7, #4]
34181870:	681b      	ldr	r3, [r3, #0]
34181872:	f003 0302 	and.w	r3, r3, #2
34181876:	2b00      	cmp	r3, #0
34181878:	d073      	beq.n	34181962 <HAL_RCC_OscConfig+0x292>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));

    /* When the HSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
3418187a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418187e:	2b00      	cmp	r3, #0
34181880:	d023      	beq.n	341818ca <HAL_RCC_OscConfig+0x1fa>
34181882:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34181886:	2b00      	cmp	r3, #0
34181888:	d01f      	beq.n	341818ca <HAL_RCC_OscConfig+0x1fa>
3418188a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3418188c:	2b00      	cmp	r3, #0
3418188e:	d104      	bne.n	3418189a <HAL_RCC_OscConfig+0x1ca>
        ((pll1src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
34181890:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34181892:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34181896:	2b00      	cmp	r3, #0
34181898:	d117      	bne.n	341818ca <HAL_RCC_OscConfig+0x1fa>
3418189a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3418189c:	2b00      	cmp	r3, #0
3418189e:	d104      	bne.n	341818aa <HAL_RCC_OscConfig+0x1da>
        ((pll2src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
341818a0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341818a2:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341818a6:	2b00      	cmp	r3, #0
341818a8:	d10f      	bne.n	341818ca <HAL_RCC_OscConfig+0x1fa>
341818aa:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
341818ac:	2b00      	cmp	r3, #0
341818ae:	d104      	bne.n	341818ba <HAL_RCC_OscConfig+0x1ea>
        ((pll3src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
341818b0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341818b2:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341818b6:	2b00      	cmp	r3, #0
341818b8:	d107      	bne.n	341818ca <HAL_RCC_OscConfig+0x1fa>
341818ba:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
341818bc:	2b00      	cmp	r3, #0
341818be:	d115      	bne.n	341818ec <HAL_RCC_OscConfig+0x21c>
        ((pll4src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
341818c0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341818c2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
341818c6:	2b00      	cmp	r3, #0
341818c8:	d010      	beq.n	341818ec <HAL_RCC_OscConfig+0x21c>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
341818ca:	687b      	ldr	r3, [r7, #4]
341818cc:	68db      	ldr	r3, [r3, #12]
341818ce:	2b00      	cmp	r3, #0
341818d0:	d101      	bne.n	341818d6 <HAL_RCC_OscConfig+0x206>
      {
        return HAL_ERROR;
341818d2:	2301      	movs	r3, #1
341818d4:	e2d7      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
341818d6:	687b      	ldr	r3, [r7, #4]
341818d8:	691b      	ldr	r3, [r3, #16]
341818da:	4618      	mov	r0, r3
341818dc:	f7ff fcd0 	bl	34181280 <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
341818e0:	687b      	ldr	r3, [r7, #4]
341818e2:	695b      	ldr	r3, [r3, #20]
341818e4:	4618      	mov	r0, r3
341818e6:	f7ff fced 	bl	341812c4 <LL_RCC_HSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
341818ea:	e03a      	b.n	34181962 <HAL_RCC_OscConfig+0x292>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
341818ec:	687b      	ldr	r3, [r7, #4]
341818ee:	68db      	ldr	r3, [r3, #12]
341818f0:	2b00      	cmp	r3, #0
341818f2:	d01e      	beq.n	34181932 <HAL_RCC_OscConfig+0x262>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
341818f4:	f7ff fc94 	bl	34181220 <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
341818f8:	f7ff fb66 	bl	34180fc8 <HAL_GetTick>
341818fc:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
341818fe:	e008      	b.n	34181912 <HAL_RCC_OscConfig+0x242>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
34181900:	f7ff fb62 	bl	34180fc8 <HAL_GetTick>
34181904:	4602      	mov	r2, r0
34181906:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34181908:	1ad3      	subs	r3, r2, r3
3418190a:	2b01      	cmp	r3, #1
3418190c:	d901      	bls.n	34181912 <HAL_RCC_OscConfig+0x242>
          {
            return HAL_TIMEOUT;
3418190e:	2303      	movs	r3, #3
34181910:	e2b9      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_HSI_IsReady() == 0U)
34181912:	f7ff fca3 	bl	3418125c <LL_RCC_HSI_IsReady>
34181916:	4603      	mov	r3, r0
34181918:	2b00      	cmp	r3, #0
3418191a:	d0f1      	beq.n	34181900 <HAL_RCC_OscConfig+0x230>
          }
        }

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3418191c:	687b      	ldr	r3, [r7, #4]
3418191e:	691b      	ldr	r3, [r3, #16]
34181920:	4618      	mov	r0, r3
34181922:	f7ff fcad 	bl	34181280 <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
34181926:	687b      	ldr	r3, [r7, #4]
34181928:	695b      	ldr	r3, [r3, #20]
3418192a:	4618      	mov	r0, r3
3418192c:	f7ff fcca 	bl	341812c4 <LL_RCC_HSI_SetCalibTrimming>
34181930:	e017      	b.n	34181962 <HAL_RCC_OscConfig+0x292>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
34181932:	f7ff fc83 	bl	3418123c <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34181936:	f7ff fb47 	bl	34180fc8 <HAL_GetTick>
3418193a:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
3418193c:	e00c      	b.n	34181958 <HAL_RCC_OscConfig+0x288>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3418193e:	f7ff fb43 	bl	34180fc8 <HAL_GetTick>
34181942:	4602      	mov	r2, r0
34181944:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34181946:	1ad3      	subs	r3, r2, r3
34181948:	2b01      	cmp	r3, #1
3418194a:	d905      	bls.n	34181958 <HAL_RCC_OscConfig+0x288>
          {
            return HAL_TIMEOUT;
3418194c:	2303      	movs	r3, #3
3418194e:	e29a      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
34181950:	56028000 	.word	0x56028000
34181954:	00018010 	.word	0x00018010
        while (LL_RCC_HSI_IsReady() != 0U)
34181958:	f7ff fc80 	bl	3418125c <LL_RCC_HSI_IsReady>
3418195c:	4603      	mov	r3, r0
3418195e:	2b00      	cmp	r3, #0
34181960:	d1ed      	bne.n	3418193e <HAL_RCC_OscConfig+0x26e>
      }
    }
  }

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
34181962:	687b      	ldr	r3, [r7, #4]
34181964:	681b      	ldr	r3, [r3, #0]
34181966:	f003 0310 	and.w	r3, r3, #16
3418196a:	2b00      	cmp	r3, #0
3418196c:	d070      	beq.n	34181a50 <HAL_RCC_OscConfig+0x380>
    /* Check the parameters */
    assert_param(IS_RCC_MSI(pRCC_OscInitStruct->MSIState));

    /* When the MSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    /* but just to update the MSI calibration value */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
3418196e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34181972:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34181976:	d028      	beq.n	341819ca <HAL_RCC_OscConfig+0x2fa>
34181978:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418197c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34181980:	d023      	beq.n	341819ca <HAL_RCC_OscConfig+0x2fa>
34181982:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34181984:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34181988:	d104      	bne.n	34181994 <HAL_RCC_OscConfig+0x2c4>
        ((pll1src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3418198a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418198c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34181990:	2b00      	cmp	r3, #0
34181992:	d11a      	bne.n	341819ca <HAL_RCC_OscConfig+0x2fa>
34181994:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34181996:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418199a:	d104      	bne.n	341819a6 <HAL_RCC_OscConfig+0x2d6>
        ((pll2src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3418199c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418199e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341819a2:	2b00      	cmp	r3, #0
341819a4:	d111      	bne.n	341819ca <HAL_RCC_OscConfig+0x2fa>
341819a6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
341819a8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341819ac:	d104      	bne.n	341819b8 <HAL_RCC_OscConfig+0x2e8>
        ((pll3src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
341819ae:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341819b0:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341819b4:	2b00      	cmp	r3, #0
341819b6:	d108      	bne.n	341819ca <HAL_RCC_OscConfig+0x2fa>
341819b8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
341819ba:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341819be:	d110      	bne.n	341819e2 <HAL_RCC_OscConfig+0x312>
        ((pll4src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
341819c0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341819c2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
341819c6:	2b00      	cmp	r3, #0
341819c8:	d00b      	beq.n	341819e2 <HAL_RCC_OscConfig+0x312>
    {
      /* When MSI is used as system clock it will not disabled */
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
341819ca:	687b      	ldr	r3, [r7, #4]
341819cc:	69db      	ldr	r3, [r3, #28]
341819ce:	2b00      	cmp	r3, #0
341819d0:	d101      	bne.n	341819d6 <HAL_RCC_OscConfig+0x306>
      {
        return HAL_ERROR;
341819d2:	2301      	movs	r3, #1
341819d4:	e257      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      {
        /* Check the parameters */
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
341819d6:	687b      	ldr	r3, [r7, #4]
341819d8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341819da:	4618      	mov	r0, r3
341819dc:	f7ff fcda 	bl	34181394 <LL_RCC_MSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
341819e0:	e036      	b.n	34181a50 <HAL_RCC_OscConfig+0x380>
      }
    }
    else
    {
      /* Check the MSI State */
      if ((pRCC_OscInitStruct->MSIState) != RCC_MSI_OFF)
341819e2:	687b      	ldr	r3, [r7, #4]
341819e4:	69db      	ldr	r3, [r3, #28]
341819e6:	2b00      	cmp	r3, #0
341819e8:	d01e      	beq.n	34181a28 <HAL_RCC_OscConfig+0x358>
        /* Check the parameters */
        assert_param(IS_RCC_MSI_FREQUENCY(pRCC_OscInitStruct->MSIFrequency));
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Set the frequency */
        __HAL_RCC_MSI_FREQUENCY_CONFIG(pRCC_OscInitStruct->MSIFrequency);
341819ea:	687b      	ldr	r3, [r7, #4]
341819ec:	6a1b      	ldr	r3, [r3, #32]
341819ee:	4618      	mov	r0, r3
341819f0:	f7ff fcae 	bl	34181350 <LL_RCC_MSI_SetFrequency>

        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
341819f4:	f7ff fc7c 	bl	341812f0 <LL_RCC_MSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
341819f8:	f7ff fae6 	bl	34180fc8 <HAL_GetTick>
341819fc:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
341819fe:	e008      	b.n	34181a12 <HAL_RCC_OscConfig+0x342>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
34181a00:	f7ff fae2 	bl	34180fc8 <HAL_GetTick>
34181a04:	4602      	mov	r2, r0
34181a06:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34181a08:	1ad3      	subs	r3, r2, r3
34181a0a:	2b01      	cmp	r3, #1
34181a0c:	d901      	bls.n	34181a12 <HAL_RCC_OscConfig+0x342>
          {
            return HAL_TIMEOUT;
34181a0e:	2303      	movs	r3, #3
34181a10:	e239      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() == 0U)
34181a12:	f7ff fc8b 	bl	3418132c <LL_RCC_MSI_IsReady>
34181a16:	4603      	mov	r3, r0
34181a18:	2b00      	cmp	r3, #0
34181a1a:	d0f1      	beq.n	34181a00 <HAL_RCC_OscConfig+0x330>
          }
        }

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
34181a1c:	687b      	ldr	r3, [r7, #4]
34181a1e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34181a20:	4618      	mov	r0, r3
34181a22:	f7ff fcb7 	bl	34181394 <LL_RCC_MSI_SetCalibTrimming>
34181a26:	e013      	b.n	34181a50 <HAL_RCC_OscConfig+0x380>
      }
      else
      {
        /* Ignore MSI frequency and calibration values in disable case */
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
34181a28:	f7ff fc70 	bl	3418130c <LL_RCC_MSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34181a2c:	f7ff facc 	bl	34180fc8 <HAL_GetTick>
34181a30:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
34181a32:	e008      	b.n	34181a46 <HAL_RCC_OscConfig+0x376>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
34181a34:	f7ff fac8 	bl	34180fc8 <HAL_GetTick>
34181a38:	4602      	mov	r2, r0
34181a3a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34181a3c:	1ad3      	subs	r3, r2, r3
34181a3e:	2b01      	cmp	r3, #1
34181a40:	d901      	bls.n	34181a46 <HAL_RCC_OscConfig+0x376>
          {
            return HAL_TIMEOUT;
34181a42:	2303      	movs	r3, #3
34181a44:	e21f      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() != 0U)
34181a46:	f7ff fc71 	bl	3418132c <LL_RCC_MSI_IsReady>
34181a4a:	4603      	mov	r3, r0
34181a4c:	2b00      	cmp	r3, #0
34181a4e:	d1f1      	bne.n	34181a34 <HAL_RCC_OscConfig+0x364>
      }
    }
  }

  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
34181a50:	687b      	ldr	r3, [r7, #4]
34181a52:	681b      	ldr	r3, [r3, #0]
34181a54:	f003 0308 	and.w	r3, r3, #8
34181a58:	2b00      	cmp	r3, #0
34181a5a:	d02c      	beq.n	34181ab6 <HAL_RCC_OscConfig+0x3e6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((pRCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
34181a5c:	687b      	ldr	r3, [r7, #4]
34181a5e:	699b      	ldr	r3, [r3, #24]
34181a60:	2b00      	cmp	r3, #0
34181a62:	d014      	beq.n	34181a8e <HAL_RCC_OscConfig+0x3be>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
34181a64:	f7ff fcbe 	bl	341813e4 <LL_RCC_LSI_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34181a68:	f7ff faae 	bl	34180fc8 <HAL_GetTick>
34181a6c:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() == 0U)
34181a6e:	e008      	b.n	34181a82 <HAL_RCC_OscConfig+0x3b2>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
34181a70:	f7ff faaa 	bl	34180fc8 <HAL_GetTick>
34181a74:	4602      	mov	r2, r0
34181a76:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34181a78:	1ad3      	subs	r3, r2, r3
34181a7a:	2b01      	cmp	r3, #1
34181a7c:	d901      	bls.n	34181a82 <HAL_RCC_OscConfig+0x3b2>
        {
          return HAL_TIMEOUT;
34181a7e:	2303      	movs	r3, #3
34181a80:	e201      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() == 0U)
34181a82:	f7ff fccd 	bl	34181420 <LL_RCC_LSI_IsReady>
34181a86:	4603      	mov	r3, r0
34181a88:	2b00      	cmp	r3, #0
34181a8a:	d0f1      	beq.n	34181a70 <HAL_RCC_OscConfig+0x3a0>
34181a8c:	e013      	b.n	34181ab6 <HAL_RCC_OscConfig+0x3e6>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
34181a8e:	f7ff fcb7 	bl	34181400 <LL_RCC_LSI_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34181a92:	f7ff fa99 	bl	34180fc8 <HAL_GetTick>
34181a96:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() != 0U)
34181a98:	e008      	b.n	34181aac <HAL_RCC_OscConfig+0x3dc>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
34181a9a:	f7ff fa95 	bl	34180fc8 <HAL_GetTick>
34181a9e:	4602      	mov	r2, r0
34181aa0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34181aa2:	1ad3      	subs	r3, r2, r3
34181aa4:	2b01      	cmp	r3, #1
34181aa6:	d901      	bls.n	34181aac <HAL_RCC_OscConfig+0x3dc>
        {
          return HAL_TIMEOUT;
34181aa8:	2303      	movs	r3, #3
34181aaa:	e1ec      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() != 0U)
34181aac:	f7ff fcb8 	bl	34181420 <LL_RCC_LSI_IsReady>
34181ab0:	4603      	mov	r3, r0
34181ab2:	2b00      	cmp	r3, #0
34181ab4:	d1f1      	bne.n	34181a9a <HAL_RCC_OscConfig+0x3ca>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
34181ab6:	687b      	ldr	r3, [r7, #4]
34181ab8:	681b      	ldr	r3, [r3, #0]
34181aba:	f003 0304 	and.w	r3, r3, #4
34181abe:	2b00      	cmp	r3, #0
34181ac0:	f000 808c 	beq.w	34181bdc <HAL_RCC_OscConfig+0x50c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
34181ac4:	687b      	ldr	r3, [r7, #4]
34181ac6:	689b      	ldr	r3, [r3, #8]
34181ac8:	2b02      	cmp	r3, #2
34181aca:	d104      	bne.n	34181ad6 <HAL_RCC_OscConfig+0x406>
34181acc:	4b96      	ldr	r3, [pc, #600]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181ace:	2202      	movs	r2, #2
34181ad0:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34181ad4:	e055      	b.n	34181b82 <HAL_RCC_OscConfig+0x4b2>
34181ad6:	687b      	ldr	r3, [r7, #4]
34181ad8:	689b      	ldr	r3, [r3, #8]
34181ada:	2b00      	cmp	r3, #0
34181adc:	d112      	bne.n	34181b04 <HAL_RCC_OscConfig+0x434>
34181ade:	4b92      	ldr	r3, [pc, #584]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181ae0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181ae4:	461a      	mov	r2, r3
34181ae6:	2302      	movs	r3, #2
34181ae8:	6013      	str	r3, [r2, #0]
34181aea:	4b8f      	ldr	r3, [pc, #572]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181aec:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34181aee:	4a8e      	ldr	r2, [pc, #568]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181af0:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34181af4:	6413      	str	r3, [r2, #64]	@ 0x40
34181af6:	4b8c      	ldr	r3, [pc, #560]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181af8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34181afa:	4a8b      	ldr	r2, [pc, #556]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181afc:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
34181b00:	6413      	str	r3, [r2, #64]	@ 0x40
34181b02:	e03e      	b.n	34181b82 <HAL_RCC_OscConfig+0x4b2>
34181b04:	687b      	ldr	r3, [r7, #4]
34181b06:	689b      	ldr	r3, [r3, #8]
34181b08:	f248 0202 	movw	r2, #32770	@ 0x8002
34181b0c:	4293      	cmp	r3, r2
34181b0e:	d110      	bne.n	34181b32 <HAL_RCC_OscConfig+0x462>
34181b10:	4b85      	ldr	r3, [pc, #532]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b12:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34181b14:	4a84      	ldr	r2, [pc, #528]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b16:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34181b1a:	6413      	str	r3, [r2, #64]	@ 0x40
34181b1c:	4b82      	ldr	r3, [pc, #520]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b1e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34181b20:	4a81      	ldr	r2, [pc, #516]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b22:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34181b26:	6413      	str	r3, [r2, #64]	@ 0x40
34181b28:	4b7f      	ldr	r3, [pc, #508]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b2a:	2202      	movs	r2, #2
34181b2c:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34181b30:	e027      	b.n	34181b82 <HAL_RCC_OscConfig+0x4b2>
34181b32:	687b      	ldr	r3, [r7, #4]
34181b34:	689b      	ldr	r3, [r3, #8]
34181b36:	4a7d      	ldr	r2, [pc, #500]	@ (34181d2c <HAL_RCC_OscConfig+0x65c>)
34181b38:	4293      	cmp	r3, r2
34181b3a:	d110      	bne.n	34181b5e <HAL_RCC_OscConfig+0x48e>
34181b3c:	4b7a      	ldr	r3, [pc, #488]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b3e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34181b40:	4a79      	ldr	r2, [pc, #484]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b42:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34181b46:	6413      	str	r3, [r2, #64]	@ 0x40
34181b48:	4b77      	ldr	r3, [pc, #476]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b4a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34181b4c:	4a76      	ldr	r2, [pc, #472]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b4e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34181b52:	6413      	str	r3, [r2, #64]	@ 0x40
34181b54:	4b74      	ldr	r3, [pc, #464]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b56:	2202      	movs	r2, #2
34181b58:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34181b5c:	e011      	b.n	34181b82 <HAL_RCC_OscConfig+0x4b2>
34181b5e:	4b72      	ldr	r3, [pc, #456]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b60:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181b64:	461a      	mov	r2, r3
34181b66:	2302      	movs	r3, #2
34181b68:	6013      	str	r3, [r2, #0]
34181b6a:	4b6f      	ldr	r3, [pc, #444]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b6c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34181b6e:	4a6e      	ldr	r2, [pc, #440]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b70:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
34181b74:	6413      	str	r3, [r2, #64]	@ 0x40
34181b76:	4b6c      	ldr	r3, [pc, #432]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b78:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34181b7a:	4a6b      	ldr	r2, [pc, #428]	@ (34181d28 <HAL_RCC_OscConfig+0x658>)
34181b7c:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34181b80:	6413      	str	r3, [r2, #64]	@ 0x40
    /* Check the LSE State */
    if ((pRCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
34181b82:	687b      	ldr	r3, [r7, #4]
34181b84:	689b      	ldr	r3, [r3, #8]
34181b86:	2b00      	cmp	r3, #0
34181b88:	d014      	beq.n	34181bb4 <HAL_RCC_OscConfig+0x4e4>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34181b8a:	f7ff fa1d 	bl	34180fc8 <HAL_GetTick>
34181b8e:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
34181b90:	e00a      	b.n	34181ba8 <HAL_RCC_OscConfig+0x4d8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
34181b92:	f7ff fa19 	bl	34180fc8 <HAL_GetTick>
34181b96:	4602      	mov	r2, r0
34181b98:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34181b9a:	1ad3      	subs	r3, r2, r3
34181b9c:	f241 3288 	movw	r2, #5000	@ 0x1388
34181ba0:	4293      	cmp	r3, r2
34181ba2:	d901      	bls.n	34181ba8 <HAL_RCC_OscConfig+0x4d8>
        {
          return HAL_TIMEOUT;
34181ba4:	2303      	movs	r3, #3
34181ba6:	e16e      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() == 0U)
34181ba8:	f7ff fc0a 	bl	341813c0 <LL_RCC_LSE_IsReady>
34181bac:	4603      	mov	r3, r0
34181bae:	2b00      	cmp	r3, #0
34181bb0:	d0ef      	beq.n	34181b92 <HAL_RCC_OscConfig+0x4c2>
34181bb2:	e013      	b.n	34181bdc <HAL_RCC_OscConfig+0x50c>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34181bb4:	f7ff fa08 	bl	34180fc8 <HAL_GetTick>
34181bb8:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
34181bba:	e00a      	b.n	34181bd2 <HAL_RCC_OscConfig+0x502>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
34181bbc:	f7ff fa04 	bl	34180fc8 <HAL_GetTick>
34181bc0:	4602      	mov	r2, r0
34181bc2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34181bc4:	1ad3      	subs	r3, r2, r3
34181bc6:	f241 3288 	movw	r2, #5000	@ 0x1388
34181bca:	4293      	cmp	r3, r2
34181bcc:	d901      	bls.n	34181bd2 <HAL_RCC_OscConfig+0x502>
        {
          return HAL_TIMEOUT;
34181bce:	2303      	movs	r3, #3
34181bd0:	e159      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() != 0U)
34181bd2:	f7ff fbf5 	bl	341813c0 <LL_RCC_LSE_IsReady>
34181bd6:	4603      	mov	r3, r0
34181bd8:	2b00      	cmp	r3, #0
34181bda:	d1ef      	bne.n	34181bbc <HAL_RCC_OscConfig+0x4ec>

  /*-------------------------------- PLL1 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL1.PLLState));

  if (pRCC_OscInitStruct->PLL1.PLLState != RCC_PLL_NONE)
34181bdc:	687b      	ldr	r3, [r7, #4]
34181bde:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34181be0:	2b00      	cmp	r3, #0
34181be2:	d04c      	beq.n	34181c7e <HAL_RCC_OscConfig+0x5ae>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1));
34181be4:	687b      	ldr	r3, [r7, #4]
34181be6:	3328      	adds	r3, #40	@ 0x28
34181be8:	4619      	mov	r1, r3
34181bea:	2000      	movs	r0, #0
34181bec:	f000 fda4 	bl	34182738 <RCC_PLL_IsNewConfig>
34181bf0:	6678      	str	r0, [r7, #100]	@ 0x64
    uint32_t pll1_ready = LL_RCC_PLL1_IsReady();
34181bf2:	f7ff fc4d 	bl	34181490 <LL_RCC_PLL1_IsReady>
34181bf6:	6638      	str	r0, [r7, #96]	@ 0x60
    if (new_pll_config == 1U)
34181bf8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34181bfa:	2b01      	cmp	r3, #1
34181bfc:	d130      	bne.n	34181c60 <HAL_RCC_OscConfig+0x590>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
34181bfe:	f7ff fd1f 	bl	34181640 <LL_RCC_IC1_GetSource>
34181c02:	65f8      	str	r0, [r7, #92]	@ 0x5c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34181c04:	f7ff fd3a 	bl	3418167c <LL_RCC_IC2_GetSource>
34181c08:	65b8      	str	r0, [r7, #88]	@ 0x58
      uint32_t ic6src = LL_RCC_IC6_GetSource();
34181c0a:	f7ff fd45 	bl	34181698 <LL_RCC_IC6_GetSource>
34181c0e:	6578      	str	r0, [r7, #84]	@ 0x54
      uint32_t ic11src = LL_RCC_IC11_GetSource();
34181c10:	f7ff fd50 	bl	341816b4 <LL_RCC_IC11_GetSource>
34181c14:	6538      	str	r0, [r7, #80]	@ 0x50
      /* PLL1 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL1))
34181c16:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34181c1a:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34181c1e:	d104      	bne.n	34181c2a <HAL_RCC_OscConfig+0x55a>
34181c20:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34181c22:	2b00      	cmp	r3, #0
34181c24:	d101      	bne.n	34181c2a <HAL_RCC_OscConfig+0x55a>
      {
        return HAL_ERROR;
34181c26:	2301      	movs	r3, #1
34181c28:	e12d      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL1 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL1) ||
34181c2a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34181c2e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34181c32:	d10a      	bne.n	34181c4a <HAL_RCC_OscConfig+0x57a>
34181c34:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34181c36:	2b00      	cmp	r3, #0
34181c38:	d005      	beq.n	34181c46 <HAL_RCC_OscConfig+0x576>
34181c3a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34181c3c:	2b00      	cmp	r3, #0
34181c3e:	d002      	beq.n	34181c46 <HAL_RCC_OscConfig+0x576>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL1) ||
34181c40:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34181c42:	2b00      	cmp	r3, #0
34181c44:	d101      	bne.n	34181c4a <HAL_RCC_OscConfig+0x57a>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL1)))
      {
        return HAL_ERROR;
34181c46:	2301      	movs	r3, #1
34181c48:	e11d      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL1 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1)) != HAL_OK)
34181c4a:	687b      	ldr	r3, [r7, #4]
34181c4c:	3328      	adds	r3, #40	@ 0x28
34181c4e:	4619      	mov	r1, r3
34181c50:	2000      	movs	r0, #0
34181c52:	f000 fc15 	bl	34182480 <RCC_PLL_Config>
34181c56:	4603      	mov	r3, r0
34181c58:	2b00      	cmp	r3, #0
34181c5a:	d010      	beq.n	34181c7e <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
34181c5c:	2301      	movs	r3, #1
34181c5e:	e112      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL1.PLLState == RCC_PLL_ON) && (pll1_ready == 0U))
34181c60:	687b      	ldr	r3, [r7, #4]
34181c62:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34181c64:	2b02      	cmp	r3, #2
34181c66:	d10a      	bne.n	34181c7e <HAL_RCC_OscConfig+0x5ae>
34181c68:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34181c6a:	2b00      	cmp	r3, #0
34181c6c:	d107      	bne.n	34181c7e <HAL_RCC_OscConfig+0x5ae>
    {
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
34181c6e:	2000      	movs	r0, #0
34181c70:	f000 fd36 	bl	341826e0 <RCC_PLL_Enable>
34181c74:	4603      	mov	r3, r0
34181c76:	2b00      	cmp	r3, #0
34181c78:	d001      	beq.n	34181c7e <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
34181c7a:	2301      	movs	r3, #1
34181c7c:	e103      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL2 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL2.PLLState));

  if (pRCC_OscInitStruct->PLL2.PLLState != RCC_PLL_NONE)
34181c7e:	687b      	ldr	r3, [r7, #4]
34181c80:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34181c82:	2b00      	cmp	r3, #0
34181c84:	d054      	beq.n	34181d30 <HAL_RCC_OscConfig+0x660>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2));
34181c86:	687b      	ldr	r3, [r7, #4]
34181c88:	3344      	adds	r3, #68	@ 0x44
34181c8a:	4619      	mov	r1, r3
34181c8c:	2001      	movs	r0, #1
34181c8e:	f000 fd53 	bl	34182738 <RCC_PLL_IsNewConfig>
34181c92:	64f8      	str	r0, [r7, #76]	@ 0x4c
    uint32_t pll2_ready = LL_RCC_PLL2_IsReady();
34181c94:	f7ff fc32 	bl	341814fc <LL_RCC_PLL2_IsReady>
34181c98:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (new_pll_config == 1U)
34181c9a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34181c9c:	2b01      	cmp	r3, #1
34181c9e:	d134      	bne.n	34181d0a <HAL_RCC_OscConfig+0x63a>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
34181ca0:	f7ff fcce 	bl	34181640 <LL_RCC_IC1_GetSource>
34181ca4:	6478      	str	r0, [r7, #68]	@ 0x44
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34181ca6:	f7ff fce9 	bl	3418167c <LL_RCC_IC2_GetSource>
34181caa:	6438      	str	r0, [r7, #64]	@ 0x40
      uint32_t ic6src = LL_RCC_IC6_GetSource();
34181cac:	f7ff fcf4 	bl	34181698 <LL_RCC_IC6_GetSource>
34181cb0:	63f8      	str	r0, [r7, #60]	@ 0x3c
      uint32_t ic11src = LL_RCC_IC11_GetSource();
34181cb2:	f7ff fcff 	bl	341816b4 <LL_RCC_IC11_GetSource>
34181cb6:	63b8      	str	r0, [r7, #56]	@ 0x38
      /* PLL2 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL2))
34181cb8:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34181cbc:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34181cc0:	d105      	bne.n	34181cce <HAL_RCC_OscConfig+0x5fe>
34181cc2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34181cc4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34181cc8:	d101      	bne.n	34181cce <HAL_RCC_OscConfig+0x5fe>
      {
        return HAL_ERROR;
34181cca:	2301      	movs	r3, #1
34181ccc:	e0db      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL2 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL2) ||
34181cce:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34181cd2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34181cd6:	d10d      	bne.n	34181cf4 <HAL_RCC_OscConfig+0x624>
34181cd8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34181cda:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34181cde:	d007      	beq.n	34181cf0 <HAL_RCC_OscConfig+0x620>
34181ce0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34181ce2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34181ce6:	d003      	beq.n	34181cf0 <HAL_RCC_OscConfig+0x620>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL2) ||
34181ce8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34181cea:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34181cee:	d101      	bne.n	34181cf4 <HAL_RCC_OscConfig+0x624>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL2)))
      {
        return HAL_ERROR;
34181cf0:	2301      	movs	r3, #1
34181cf2:	e0c8      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL2 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2)) != HAL_OK)
34181cf4:	687b      	ldr	r3, [r7, #4]
34181cf6:	3344      	adds	r3, #68	@ 0x44
34181cf8:	4619      	mov	r1, r3
34181cfa:	2001      	movs	r0, #1
34181cfc:	f000 fbc0 	bl	34182480 <RCC_PLL_Config>
34181d00:	4603      	mov	r3, r0
34181d02:	2b00      	cmp	r3, #0
34181d04:	d014      	beq.n	34181d30 <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
34181d06:	2301      	movs	r3, #1
34181d08:	e0bd      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL2.PLLState == RCC_PLL_ON) && (pll2_ready == 0U))
34181d0a:	687b      	ldr	r3, [r7, #4]
34181d0c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34181d0e:	2b02      	cmp	r3, #2
34181d10:	d10e      	bne.n	34181d30 <HAL_RCC_OscConfig+0x660>
34181d12:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34181d14:	2b00      	cmp	r3, #0
34181d16:	d10b      	bne.n	34181d30 <HAL_RCC_OscConfig+0x660>
    {
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
34181d18:	2001      	movs	r0, #1
34181d1a:	f000 fce1 	bl	341826e0 <RCC_PLL_Enable>
34181d1e:	4603      	mov	r3, r0
34181d20:	2b00      	cmp	r3, #0
34181d22:	d005      	beq.n	34181d30 <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
34181d24:	2301      	movs	r3, #1
34181d26:	e0ae      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
34181d28:	56028000 	.word	0x56028000
34181d2c:	00018002 	.word	0x00018002

  /*-------------------------------- PLL3 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL3.PLLState));

  if (pRCC_OscInitStruct->PLL3.PLLState != RCC_PLL_NONE)
34181d30:	687b      	ldr	r3, [r7, #4]
34181d32:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34181d34:	2b00      	cmp	r3, #0
34181d36:	d050      	beq.n	34181dda <HAL_RCC_OscConfig+0x70a>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3));
34181d38:	687b      	ldr	r3, [r7, #4]
34181d3a:	3360      	adds	r3, #96	@ 0x60
34181d3c:	4619      	mov	r1, r3
34181d3e:	2002      	movs	r0, #2
34181d40:	f000 fcfa 	bl	34182738 <RCC_PLL_IsNewConfig>
34181d44:	6378      	str	r0, [r7, #52]	@ 0x34
    uint32_t pll3_ready = LL_RCC_PLL1_IsReady();
34181d46:	f7ff fba3 	bl	34181490 <LL_RCC_PLL1_IsReady>
34181d4a:	6338      	str	r0, [r7, #48]	@ 0x30
    if (new_pll_config == 1U)
34181d4c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34181d4e:	2b01      	cmp	r3, #1
34181d50:	d134      	bne.n	34181dbc <HAL_RCC_OscConfig+0x6ec>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
34181d52:	f7ff fc75 	bl	34181640 <LL_RCC_IC1_GetSource>
34181d56:	62f8      	str	r0, [r7, #44]	@ 0x2c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34181d58:	f7ff fc90 	bl	3418167c <LL_RCC_IC2_GetSource>
34181d5c:	62b8      	str	r0, [r7, #40]	@ 0x28
      uint32_t ic6src = LL_RCC_IC6_GetSource();
34181d5e:	f7ff fc9b 	bl	34181698 <LL_RCC_IC6_GetSource>
34181d62:	6278      	str	r0, [r7, #36]	@ 0x24
      uint32_t ic11src = LL_RCC_IC11_GetSource();
34181d64:	f7ff fca6 	bl	341816b4 <LL_RCC_IC11_GetSource>
34181d68:	6238      	str	r0, [r7, #32]
      /* PLL3 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL3))
34181d6a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34181d6e:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34181d72:	d105      	bne.n	34181d80 <HAL_RCC_OscConfig+0x6b0>
34181d74:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34181d76:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34181d7a:	d101      	bne.n	34181d80 <HAL_RCC_OscConfig+0x6b0>
      {
        return HAL_ERROR;
34181d7c:	2301      	movs	r3, #1
34181d7e:	e082      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL3) ||
34181d80:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34181d84:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34181d88:	d10d      	bne.n	34181da6 <HAL_RCC_OscConfig+0x6d6>
34181d8a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34181d8c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34181d90:	d007      	beq.n	34181da2 <HAL_RCC_OscConfig+0x6d2>
34181d92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34181d94:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34181d98:	d003      	beq.n	34181da2 <HAL_RCC_OscConfig+0x6d2>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL3) ||
34181d9a:	6a3b      	ldr	r3, [r7, #32]
34181d9c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34181da0:	d101      	bne.n	34181da6 <HAL_RCC_OscConfig+0x6d6>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL3)))
      {
        return HAL_ERROR;
34181da2:	2301      	movs	r3, #1
34181da4:	e06f      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3)) != HAL_OK)
34181da6:	687b      	ldr	r3, [r7, #4]
34181da8:	3360      	adds	r3, #96	@ 0x60
34181daa:	4619      	mov	r1, r3
34181dac:	2002      	movs	r0, #2
34181dae:	f000 fb67 	bl	34182480 <RCC_PLL_Config>
34181db2:	4603      	mov	r3, r0
34181db4:	2b00      	cmp	r3, #0
34181db6:	d010      	beq.n	34181dda <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
34181db8:	2301      	movs	r3, #1
34181dba:	e064      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL3.PLLState == RCC_PLL_ON) && (pll3_ready == 0U))
34181dbc:	687b      	ldr	r3, [r7, #4]
34181dbe:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34181dc0:	2b02      	cmp	r3, #2
34181dc2:	d10a      	bne.n	34181dda <HAL_RCC_OscConfig+0x70a>
34181dc4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34181dc6:	2b00      	cmp	r3, #0
34181dc8:	d107      	bne.n	34181dda <HAL_RCC_OscConfig+0x70a>
    {
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
34181dca:	2002      	movs	r0, #2
34181dcc:	f000 fc88 	bl	341826e0 <RCC_PLL_Enable>
34181dd0:	4603      	mov	r3, r0
34181dd2:	2b00      	cmp	r3, #0
34181dd4:	d001      	beq.n	34181dda <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
34181dd6:	2301      	movs	r3, #1
34181dd8:	e055      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL4 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL4.PLLState));

  if (pRCC_OscInitStruct->PLL4.PLLState != RCC_PLL_NONE)
34181dda:	687b      	ldr	r3, [r7, #4]
34181ddc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34181dde:	2b00      	cmp	r3, #0
34181de0:	d050      	beq.n	34181e84 <HAL_RCC_OscConfig+0x7b4>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4));
34181de2:	687b      	ldr	r3, [r7, #4]
34181de4:	337c      	adds	r3, #124	@ 0x7c
34181de6:	4619      	mov	r1, r3
34181de8:	2003      	movs	r0, #3
34181dea:	f000 fca5 	bl	34182738 <RCC_PLL_IsNewConfig>
34181dee:	61f8      	str	r0, [r7, #28]
    uint32_t pll4_ready = LL_RCC_PLL4_IsReady();
34181df0:	f7ff fbf0 	bl	341815d4 <LL_RCC_PLL4_IsReady>
34181df4:	61b8      	str	r0, [r7, #24]

    if (new_pll_config == 1U)
34181df6:	69fb      	ldr	r3, [r7, #28]
34181df8:	2b01      	cmp	r3, #1
34181dfa:	d134      	bne.n	34181e66 <HAL_RCC_OscConfig+0x796>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
34181dfc:	f7ff fc20 	bl	34181640 <LL_RCC_IC1_GetSource>
34181e00:	6178      	str	r0, [r7, #20]
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34181e02:	f7ff fc3b 	bl	3418167c <LL_RCC_IC2_GetSource>
34181e06:	6138      	str	r0, [r7, #16]
      uint32_t ic6src = LL_RCC_IC6_GetSource();
34181e08:	f7ff fc46 	bl	34181698 <LL_RCC_IC6_GetSource>
34181e0c:	60f8      	str	r0, [r7, #12]
      uint32_t ic11src = LL_RCC_IC11_GetSource();
34181e0e:	f7ff fc51 	bl	341816b4 <LL_RCC_IC11_GetSource>
34181e12:	60b8      	str	r0, [r7, #8]
      /* PLL4 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL4))
34181e14:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34181e18:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34181e1c:	d105      	bne.n	34181e2a <HAL_RCC_OscConfig+0x75a>
34181e1e:	697b      	ldr	r3, [r7, #20]
34181e20:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34181e24:	d101      	bne.n	34181e2a <HAL_RCC_OscConfig+0x75a>
      {
        return HAL_ERROR;
34181e26:	2301      	movs	r3, #1
34181e28:	e02d      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL4) ||
34181e2a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34181e2e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34181e32:	d10d      	bne.n	34181e50 <HAL_RCC_OscConfig+0x780>
34181e34:	693b      	ldr	r3, [r7, #16]
34181e36:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34181e3a:	d007      	beq.n	34181e4c <HAL_RCC_OscConfig+0x77c>
34181e3c:	68fb      	ldr	r3, [r7, #12]
34181e3e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34181e42:	d003      	beq.n	34181e4c <HAL_RCC_OscConfig+0x77c>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL4) ||
34181e44:	68bb      	ldr	r3, [r7, #8]
34181e46:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34181e4a:	d101      	bne.n	34181e50 <HAL_RCC_OscConfig+0x780>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL4)))
      {
        return HAL_ERROR;
34181e4c:	2301      	movs	r3, #1
34181e4e:	e01a      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4)) != HAL_OK)
34181e50:	687b      	ldr	r3, [r7, #4]
34181e52:	337c      	adds	r3, #124	@ 0x7c
34181e54:	4619      	mov	r1, r3
34181e56:	2003      	movs	r0, #3
34181e58:	f000 fb12 	bl	34182480 <RCC_PLL_Config>
34181e5c:	4603      	mov	r3, r0
34181e5e:	2b00      	cmp	r3, #0
34181e60:	d010      	beq.n	34181e84 <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
34181e62:	2301      	movs	r3, #1
34181e64:	e00f      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL4.PLLState == RCC_PLL_ON) && (pll4_ready == 0U))
34181e66:	687b      	ldr	r3, [r7, #4]
34181e68:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34181e6a:	2b02      	cmp	r3, #2
34181e6c:	d10a      	bne.n	34181e84 <HAL_RCC_OscConfig+0x7b4>
34181e6e:	69bb      	ldr	r3, [r7, #24]
34181e70:	2b00      	cmp	r3, #0
34181e72:	d107      	bne.n	34181e84 <HAL_RCC_OscConfig+0x7b4>
    {
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
34181e74:	2003      	movs	r0, #3
34181e76:	f000 fc33 	bl	341826e0 <RCC_PLL_Enable>
34181e7a:	4603      	mov	r3, r0
34181e7c:	2b00      	cmp	r3, #0
34181e7e:	d001      	beq.n	34181e84 <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
34181e80:	2301      	movs	r3, #1
34181e82:	e000      	b.n	34181e86 <HAL_RCC_OscConfig+0x7b6>
    {
      /* Nothing to do */
    }
  }

  return HAL_OK;
34181e84:	2300      	movs	r3, #0
}
34181e86:	4618      	mov	r0, r3
34181e88:	3788      	adds	r7, #136	@ 0x88
34181e8a:	46bd      	mov	sp, r7
34181e8c:	bd80      	pop	{r7, pc}
34181e8e:	bf00      	nop

34181e90 <HAL_RCC_ClockConfig>:
  *         You can use HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
34181e90:	b580      	push	{r7, lr}
34181e92:	b084      	sub	sp, #16
34181e94:	af00      	add	r7, sp, #0
34181e96:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
34181e98:	687b      	ldr	r3, [r7, #4]
34181e9a:	2b00      	cmp	r3, #0
34181e9c:	d101      	bne.n	34181ea2 <HAL_RCC_ClockConfig+0x12>
  {
    return HAL_ERROR;
34181e9e:	2301      	movs	r3, #1
34181ea0:	e1f2      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
  assert_param(IS_RCC_CLOCKTYPE(pRCC_ClkInitStruct->ClockType));

  /* Increasing the BUS frequency divider ? */

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
34181ea2:	687b      	ldr	r3, [r7, #4]
34181ea4:	681b      	ldr	r3, [r3, #0]
34181ea6:	f003 0308 	and.w	r3, r3, #8
34181eaa:	2b00      	cmp	r3, #0
34181eac:	d010      	beq.n	34181ed0 <HAL_RCC_ClockConfig+0x40>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
34181eae:	687b      	ldr	r3, [r7, #4]
34181eb0:	691a      	ldr	r2, [r3, #16]
34181eb2:	4ba3      	ldr	r3, [pc, #652]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181eb4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34181eb6:	f003 0307 	and.w	r3, r3, #7
34181eba:	429a      	cmp	r2, r3
34181ebc:	d908      	bls.n	34181ed0 <HAL_RCC_ClockConfig+0x40>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
34181ebe:	4ba0      	ldr	r3, [pc, #640]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181ec0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34181ec2:	f023 0207 	bic.w	r2, r3, #7
34181ec6:	687b      	ldr	r3, [r7, #4]
34181ec8:	691b      	ldr	r3, [r3, #16]
34181eca:	499d      	ldr	r1, [pc, #628]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181ecc:	4313      	orrs	r3, r2
34181ece:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
34181ed0:	687b      	ldr	r3, [r7, #4]
34181ed2:	681b      	ldr	r3, [r3, #0]
34181ed4:	f003 0310 	and.w	r3, r3, #16
34181ed8:	2b00      	cmp	r3, #0
34181eda:	d010      	beq.n	34181efe <HAL_RCC_ClockConfig+0x6e>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE2))
34181edc:	687b      	ldr	r3, [r7, #4]
34181ede:	695a      	ldr	r2, [r3, #20]
34181ee0:	4b97      	ldr	r3, [pc, #604]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181ee2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34181ee4:	f003 0370 	and.w	r3, r3, #112	@ 0x70
34181ee8:	429a      	cmp	r2, r3
34181eea:	d908      	bls.n	34181efe <HAL_RCC_ClockConfig+0x6e>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
34181eec:	4b94      	ldr	r3, [pc, #592]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181eee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34181ef0:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
34181ef4:	687b      	ldr	r3, [r7, #4]
34181ef6:	695b      	ldr	r3, [r3, #20]
34181ef8:	4991      	ldr	r1, [pc, #580]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181efa:	4313      	orrs	r3, r2
34181efc:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
34181efe:	687b      	ldr	r3, [r7, #4]
34181f00:	681b      	ldr	r3, [r3, #0]
34181f02:	f003 0320 	and.w	r3, r3, #32
34181f06:	2b00      	cmp	r3, #0
34181f08:	d010      	beq.n	34181f2c <HAL_RCC_ClockConfig+0x9c>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE4))
34181f0a:	687b      	ldr	r3, [r7, #4]
34181f0c:	699a      	ldr	r2, [r3, #24]
34181f0e:	4b8c      	ldr	r3, [pc, #560]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181f10:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34181f12:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
34181f16:	429a      	cmp	r2, r3
34181f18:	d908      	bls.n	34181f2c <HAL_RCC_ClockConfig+0x9c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
34181f1a:	4b89      	ldr	r3, [pc, #548]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181f1c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34181f1e:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
34181f22:	687b      	ldr	r3, [r7, #4]
34181f24:	699b      	ldr	r3, [r3, #24]
34181f26:	4986      	ldr	r1, [pc, #536]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181f28:	4313      	orrs	r3, r2
34181f2a:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
34181f2c:	687b      	ldr	r3, [r7, #4]
34181f2e:	681b      	ldr	r3, [r3, #0]
34181f30:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34181f34:	2b00      	cmp	r3, #0
34181f36:	d010      	beq.n	34181f5a <HAL_RCC_ClockConfig+0xca>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE5))
34181f38:	687b      	ldr	r3, [r7, #4]
34181f3a:	69da      	ldr	r2, [r3, #28]
34181f3c:	4b80      	ldr	r3, [pc, #512]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181f3e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34181f40:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
34181f44:	429a      	cmp	r2, r3
34181f46:	d908      	bls.n	34181f5a <HAL_RCC_ClockConfig+0xca>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
34181f48:	4b7d      	ldr	r3, [pc, #500]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181f4a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34181f4c:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34181f50:	687b      	ldr	r3, [r7, #4]
34181f52:	69db      	ldr	r3, [r3, #28]
34181f54:	497a      	ldr	r1, [pc, #488]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181f56:	4313      	orrs	r3, r2
34181f58:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
34181f5a:	687b      	ldr	r3, [r7, #4]
34181f5c:	681b      	ldr	r3, [r3, #0]
34181f5e:	f003 0304 	and.w	r3, r3, #4
34181f62:	2b00      	cmp	r3, #0
34181f64:	d010      	beq.n	34181f88 <HAL_RCC_ClockConfig+0xf8>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
34181f66:	687b      	ldr	r3, [r7, #4]
34181f68:	68da      	ldr	r2, [r3, #12]
34181f6a:	4b75      	ldr	r3, [pc, #468]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181f6c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34181f6e:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
34181f72:	429a      	cmp	r2, r3
34181f74:	d908      	bls.n	34181f88 <HAL_RCC_ClockConfig+0xf8>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
34181f76:	4b72      	ldr	r3, [pc, #456]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181f78:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34181f7a:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
34181f7e:	687b      	ldr	r3, [r7, #4]
34181f80:	68db      	ldr	r3, [r3, #12]
34181f82:	496f      	ldr	r1, [pc, #444]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181f84:	4313      	orrs	r3, r2
34181f86:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*------------------------- CPUCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_CPUCLK) == RCC_CLOCKTYPE_CPUCLK)
34181f88:	687b      	ldr	r3, [r7, #4]
34181f8a:	681b      	ldr	r3, [r3, #0]
34181f8c:	f003 0301 	and.w	r3, r3, #1
34181f90:	2b00      	cmp	r3, #0
34181f92:	d063      	beq.n	3418205c <HAL_RCC_ClockConfig+0x1cc>
  {
    assert_param(IS_RCC_CPUCLKSOURCE(pRCC_ClkInitStruct->CPUCLKSource));

    /* HSE is selected as CPU Clock Source */
    if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_HSE)
34181f94:	687b      	ldr	r3, [r7, #4]
34181f96:	685b      	ldr	r3, [r3, #4]
34181f98:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34181f9c:	d106      	bne.n	34181fac <HAL_RCC_ClockConfig+0x11c>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
34181f9e:	f7ff f92d 	bl	341811fc <LL_RCC_HSE_IsReady>
34181fa2:	4603      	mov	r3, r0
34181fa4:	2b00      	cmp	r3, #0
34181fa6:	d134      	bne.n	34182012 <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
34181fa8:	2301      	movs	r3, #1
34181faa:	e16d      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_IC1)
34181fac:	687b      	ldr	r3, [r7, #4]
34181fae:	685b      	ldr	r3, [r3, #4]
34181fb0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34181fb4:	d11a      	bne.n	34181fec <HAL_RCC_ClockConfig+0x15c>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC1Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC1Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC1 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC1_GetSource(), pRCC_ClkInitStruct->IC1Selection.ClockSelection) != 1U)
34181fb6:	f7ff fb43 	bl	34181640 <LL_RCC_IC1_GetSource>
34181fba:	4602      	mov	r2, r0
34181fbc:	687b      	ldr	r3, [r7, #4]
34181fbe:	6a1b      	ldr	r3, [r3, #32]
34181fc0:	4619      	mov	r1, r3
34181fc2:	4610      	mov	r0, r2
34181fc4:	f000 fc6c 	bl	341828a0 <RCC_IC_CheckPLLSources>
34181fc8:	4603      	mov	r3, r0
34181fca:	2b01      	cmp	r3, #1
34181fcc:	d001      	beq.n	34181fd2 <HAL_RCC_ClockConfig+0x142>
      {
        return HAL_ERROR;
34181fce:	2301      	movs	r3, #1
34181fd0:	e15a      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC1 source and divider */
      WRITE_REG(RCC->IC1CFGR, pRCC_ClkInitStruct->IC1Selection.ClockSelection | \
34181fd2:	687b      	ldr	r3, [r7, #4]
34181fd4:	6a1a      	ldr	r2, [r3, #32]
34181fd6:	687b      	ldr	r3, [r7, #4]
34181fd8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34181fda:	3b01      	subs	r3, #1
34181fdc:	041b      	lsls	r3, r3, #16
34181fde:	4958      	ldr	r1, [pc, #352]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34181fe0:	4313      	orrs	r3, r2
34181fe2:	f8c1 30c4 	str.w	r3, [r1, #196]	@ 0xc4
                ((pRCC_ClkInitStruct->IC1Selection.ClockDivider - 1U) << RCC_IC1CFGR_IC1INT_Pos));

      /* Enable IC1 */
      LL_RCC_IC1_Enable();
34181fe6:	f7ff fb1d 	bl	34181624 <LL_RCC_IC1_Enable>
34181fea:	e012      	b.n	34182012 <HAL_RCC_ClockConfig+0x182>
    }
    /* MSI is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_MSI)
34181fec:	687b      	ldr	r3, [r7, #4]
34181fee:	685b      	ldr	r3, [r3, #4]
34181ff0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34181ff4:	d106      	bne.n	34182004 <HAL_RCC_ClockConfig+0x174>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
34181ff6:	f7ff f999 	bl	3418132c <LL_RCC_MSI_IsReady>
34181ffa:	4603      	mov	r3, r0
34181ffc:	2b00      	cmp	r3, #0
34181ffe:	d108      	bne.n	34182012 <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
34182000:	2301      	movs	r3, #1
34182002:	e141      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
    }
    /* HSI is selected as CPU Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
34182004:	f7ff f92a 	bl	3418125c <LL_RCC_HSI_IsReady>
34182008:	4603      	mov	r3, r0
3418200a:	2b00      	cmp	r3, #0
3418200c:	d101      	bne.n	34182012 <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3418200e:	2301      	movs	r3, #1
34182010:	e13a      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the CPU clock */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
34182012:	4b4b      	ldr	r3, [pc, #300]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34182014:	6a1b      	ldr	r3, [r3, #32]
34182016:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
3418201a:	687b      	ldr	r3, [r7, #4]
3418201c:	685b      	ldr	r3, [r3, #4]
3418201e:	4948      	ldr	r1, [pc, #288]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34182020:	4313      	orrs	r3, r2
34182022:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34182024:	f7fe ffd0 	bl	34180fc8 <HAL_GetTick>
34182028:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3418202a:	e00a      	b.n	34182042 <HAL_RCC_ClockConfig+0x1b2>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3418202c:	f7fe ffcc 	bl	34180fc8 <HAL_GetTick>
34182030:	4602      	mov	r2, r0
34182032:	68fb      	ldr	r3, [r7, #12]
34182034:	1ad3      	subs	r3, r2, r3
34182036:	f241 3288 	movw	r2, #5000	@ 0x1388
3418203a:	4293      	cmp	r3, r2
3418203c:	d901      	bls.n	34182042 <HAL_RCC_ClockConfig+0x1b2>
      {
        return HAL_TIMEOUT;
3418203e:	2303      	movs	r3, #3
34182040:	e122      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
34182042:	f7ff f9fb 	bl	3418143c <LL_RCC_GetCpuClkSource>
34182046:	4602      	mov	r2, r0
34182048:	687b      	ldr	r3, [r7, #4]
3418204a:	685b      	ldr	r3, [r3, #4]
3418204c:	011b      	lsls	r3, r3, #4
3418204e:	429a      	cmp	r2, r3
34182050:	d1ec      	bne.n	3418202c <HAL_RCC_ClockConfig+0x19c>
      }
    }

    /* Update the SystemCoreClock global variable with CPU clock */
    SystemCoreClock = HAL_RCC_GetCpuClockFreq();
34182052:	f000 f921 	bl	34182298 <HAL_RCC_GetCpuClockFreq>
34182056:	4603      	mov	r3, r0
34182058:	4a3a      	ldr	r2, [pc, #232]	@ (34182144 <HAL_RCC_ClockConfig+0x2b4>)
3418205a:	6013      	str	r3, [r2, #0]

  }

  /*------------------------- SYSCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
3418205c:	687b      	ldr	r3, [r7, #4]
3418205e:	681b      	ldr	r3, [r3, #0]
34182060:	f003 0302 	and.w	r3, r3, #2
34182064:	2b00      	cmp	r3, #0
34182066:	f000 8096 	beq.w	34182196 <HAL_RCC_ClockConfig+0x306>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System bus clock source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
3418206a:	687b      	ldr	r3, [r7, #4]
3418206c:	689b      	ldr	r3, [r3, #8]
3418206e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34182072:	d106      	bne.n	34182082 <HAL_RCC_ClockConfig+0x1f2>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
34182074:	f7ff f8c2 	bl	341811fc <LL_RCC_HSE_IsReady>
34182078:	4603      	mov	r3, r0
3418207a:	2b00      	cmp	r3, #0
3418207c:	d16b      	bne.n	34182156 <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3418207e:	2301      	movs	r3, #1
34182080:	e102      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL output is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11)
34182082:	687b      	ldr	r3, [r7, #4]
34182084:	689b      	ldr	r3, [r3, #8]
34182086:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3418208a:	d14d      	bne.n	34182128 <HAL_RCC_ClockConfig+0x298>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC11Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC11Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC2/IC6/IC11 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC2_GetSource(), pRCC_ClkInitStruct->IC2Selection.ClockSelection) != 1U)
3418208c:	f7ff faf6 	bl	3418167c <LL_RCC_IC2_GetSource>
34182090:	4602      	mov	r2, r0
34182092:	687b      	ldr	r3, [r7, #4]
34182094:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34182096:	4619      	mov	r1, r3
34182098:	4610      	mov	r0, r2
3418209a:	f000 fc01 	bl	341828a0 <RCC_IC_CheckPLLSources>
3418209e:	4603      	mov	r3, r0
341820a0:	2b01      	cmp	r3, #1
341820a2:	d001      	beq.n	341820a8 <HAL_RCC_ClockConfig+0x218>
      {
        return HAL_ERROR;
341820a4:	2301      	movs	r3, #1
341820a6:	e0ef      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC6_GetSource(), pRCC_ClkInitStruct->IC6Selection.ClockSelection) != 1U)
341820a8:	f7ff faf6 	bl	34181698 <LL_RCC_IC6_GetSource>
341820ac:	4602      	mov	r2, r0
341820ae:	687b      	ldr	r3, [r7, #4]
341820b0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341820b2:	4619      	mov	r1, r3
341820b4:	4610      	mov	r0, r2
341820b6:	f000 fbf3 	bl	341828a0 <RCC_IC_CheckPLLSources>
341820ba:	4603      	mov	r3, r0
341820bc:	2b01      	cmp	r3, #1
341820be:	d001      	beq.n	341820c4 <HAL_RCC_ClockConfig+0x234>
      {
        return HAL_ERROR;
341820c0:	2301      	movs	r3, #1
341820c2:	e0e1      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC11_GetSource(), pRCC_ClkInitStruct->IC11Selection.ClockSelection) != 1U)
341820c4:	f7ff faf6 	bl	341816b4 <LL_RCC_IC11_GetSource>
341820c8:	4602      	mov	r2, r0
341820ca:	687b      	ldr	r3, [r7, #4]
341820cc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
341820ce:	4619      	mov	r1, r3
341820d0:	4610      	mov	r0, r2
341820d2:	f000 fbe5 	bl	341828a0 <RCC_IC_CheckPLLSources>
341820d6:	4603      	mov	r3, r0
341820d8:	2b01      	cmp	r3, #1
341820da:	d001      	beq.n	341820e0 <HAL_RCC_ClockConfig+0x250>
      {
        return HAL_ERROR;
341820dc:	2301      	movs	r3, #1
341820de:	e0d3      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC2, IC6 and IC11 sources and dividers */
      WRITE_REG(RCC->IC2CFGR, pRCC_ClkInitStruct->IC2Selection.ClockSelection | \
341820e0:	687b      	ldr	r3, [r7, #4]
341820e2:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
341820e4:	687b      	ldr	r3, [r7, #4]
341820e6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
341820e8:	3b01      	subs	r3, #1
341820ea:	041b      	lsls	r3, r3, #16
341820ec:	4914      	ldr	r1, [pc, #80]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
341820ee:	4313      	orrs	r3, r2
341820f0:	f8c1 30c8 	str.w	r3, [r1, #200]	@ 0xc8
                ((pRCC_ClkInitStruct->IC2Selection.ClockDivider - 1U) << RCC_IC2CFGR_IC2INT_Pos));
      WRITE_REG(RCC->IC6CFGR, pRCC_ClkInitStruct->IC6Selection.ClockSelection | \
341820f4:	687b      	ldr	r3, [r7, #4]
341820f6:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
341820f8:	687b      	ldr	r3, [r7, #4]
341820fa:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
341820fc:	3b01      	subs	r3, #1
341820fe:	041b      	lsls	r3, r3, #16
34182100:	490f      	ldr	r1, [pc, #60]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34182102:	4313      	orrs	r3, r2
34182104:	f8c1 30d8 	str.w	r3, [r1, #216]	@ 0xd8
                ((pRCC_ClkInitStruct->IC6Selection.ClockDivider - 1U) << RCC_IC6CFGR_IC6INT_Pos));
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
34182108:	687b      	ldr	r3, [r7, #4]
3418210a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418210c:	687b      	ldr	r3, [r7, #4]
3418210e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34182110:	3b01      	subs	r3, #1
34182112:	041b      	lsls	r3, r3, #16
34182114:	490a      	ldr	r1, [pc, #40]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
34182116:	4313      	orrs	r3, r2
34182118:	f8c1 30ec 	str.w	r3, [r1, #236]	@ 0xec
                ((pRCC_ClkInitStruct->IC11Selection.ClockDivider - 1U) << RCC_IC11CFGR_IC11INT_Pos));

      /* Require to have IC2, IC6 and IC11 outputs enabled */
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
3418211c:	4b08      	ldr	r3, [pc, #32]	@ (34182140 <HAL_RCC_ClockConfig+0x2b0>)
3418211e:	f240 4222 	movw	r2, #1058	@ 0x422
34182122:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
34182126:	e016      	b.n	34182156 <HAL_RCC_ClockConfig+0x2c6>
    }
    /* HSI is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
34182128:	687b      	ldr	r3, [r7, #4]
3418212a:	689b      	ldr	r3, [r3, #8]
3418212c:	2b00      	cmp	r3, #0
3418212e:	d10b      	bne.n	34182148 <HAL_RCC_ClockConfig+0x2b8>
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
34182130:	f7ff f894 	bl	3418125c <LL_RCC_HSI_IsReady>
34182134:	4603      	mov	r3, r0
34182136:	2b00      	cmp	r3, #0
34182138:	d10d      	bne.n	34182156 <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3418213a:	2301      	movs	r3, #1
3418213c:	e0a4      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
3418213e:	bf00      	nop
34182140:	56028000 	.word	0x56028000
34182144:	341c0000 	.word	0x341c0000
    }
    /* MSI is selected as System bus clock source */
    else
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
34182148:	f7ff f8f0 	bl	3418132c <LL_RCC_MSI_IsReady>
3418214c:	4603      	mov	r3, r0
3418214e:	2b00      	cmp	r3, #0
34182150:	d101      	bne.n	34182156 <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
34182152:	2301      	movs	r3, #1
34182154:	e098      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the system bus clocks */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
34182156:	4b4e      	ldr	r3, [pc, #312]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
34182158:	6a1b      	ldr	r3, [r3, #32]
3418215a:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3418215e:	687b      	ldr	r3, [r7, #4]
34182160:	689b      	ldr	r3, [r3, #8]
34182162:	494b      	ldr	r1, [pc, #300]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
34182164:	4313      	orrs	r3, r2
34182166:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34182168:	f7fe ff2e 	bl	34180fc8 <HAL_GetTick>
3418216c:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
3418216e:	e00a      	b.n	34182186 <HAL_RCC_ClockConfig+0x2f6>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34182170:	f7fe ff2a 	bl	34180fc8 <HAL_GetTick>
34182174:	4602      	mov	r2, r0
34182176:	68fb      	ldr	r3, [r7, #12]
34182178:	1ad3      	subs	r3, r2, r3
3418217a:	f241 3288 	movw	r2, #5000	@ 0x1388
3418217e:	4293      	cmp	r3, r2
34182180:	d901      	bls.n	34182186 <HAL_RCC_ClockConfig+0x2f6>
      {
        return HAL_TIMEOUT;
34182182:	2303      	movs	r3, #3
34182184:	e080      	b.n	34182288 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
34182186:	f7ff f967 	bl	34181458 <LL_RCC_GetSysClkSource>
3418218a:	4602      	mov	r2, r0
3418218c:	687b      	ldr	r3, [r7, #4]
3418218e:	689b      	ldr	r3, [r3, #8]
34182190:	011b      	lsls	r3, r3, #4
34182192:	429a      	cmp	r2, r3
34182194:	d1ec      	bne.n	34182170 <HAL_RCC_ClockConfig+0x2e0>
  }

  /* Decreasing the BUS frequency divider ? */

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
34182196:	687b      	ldr	r3, [r7, #4]
34182198:	681b      	ldr	r3, [r3, #0]
3418219a:	f003 0304 	and.w	r3, r3, #4
3418219e:	2b00      	cmp	r3, #0
341821a0:	d010      	beq.n	341821c4 <HAL_RCC_ClockConfig+0x334>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
341821a2:	687b      	ldr	r3, [r7, #4]
341821a4:	68da      	ldr	r2, [r3, #12]
341821a6:	4b3a      	ldr	r3, [pc, #232]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
341821a8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341821aa:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
341821ae:	429a      	cmp	r2, r3
341821b0:	d208      	bcs.n	341821c4 <HAL_RCC_ClockConfig+0x334>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
341821b2:	4b37      	ldr	r3, [pc, #220]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
341821b4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341821b6:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
341821ba:	687b      	ldr	r3, [r7, #4]
341821bc:	68db      	ldr	r3, [r3, #12]
341821be:	4934      	ldr	r1, [pc, #208]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
341821c0:	4313      	orrs	r3, r2
341821c2:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
341821c4:	687b      	ldr	r3, [r7, #4]
341821c6:	681b      	ldr	r3, [r3, #0]
341821c8:	f003 0308 	and.w	r3, r3, #8
341821cc:	2b00      	cmp	r3, #0
341821ce:	d010      	beq.n	341821f2 <HAL_RCC_ClockConfig+0x362>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
341821d0:	687b      	ldr	r3, [r7, #4]
341821d2:	691a      	ldr	r2, [r3, #16]
341821d4:	4b2e      	ldr	r3, [pc, #184]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
341821d6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341821d8:	f003 0307 	and.w	r3, r3, #7
341821dc:	429a      	cmp	r2, r3
341821de:	d208      	bcs.n	341821f2 <HAL_RCC_ClockConfig+0x362>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
341821e0:	4b2b      	ldr	r3, [pc, #172]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
341821e2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341821e4:	f023 0207 	bic.w	r2, r3, #7
341821e8:	687b      	ldr	r3, [r7, #4]
341821ea:	691b      	ldr	r3, [r3, #16]
341821ec:	4928      	ldr	r1, [pc, #160]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
341821ee:	4313      	orrs	r3, r2
341821f0:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
341821f2:	687b      	ldr	r3, [r7, #4]
341821f4:	681b      	ldr	r3, [r3, #0]
341821f6:	f003 0310 	and.w	r3, r3, #16
341821fa:	2b00      	cmp	r3, #0
341821fc:	d010      	beq.n	34182220 <HAL_RCC_ClockConfig+0x390>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE2))
341821fe:	687b      	ldr	r3, [r7, #4]
34182200:	695a      	ldr	r2, [r3, #20]
34182202:	4b23      	ldr	r3, [pc, #140]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
34182204:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182206:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3418220a:	429a      	cmp	r2, r3
3418220c:	d208      	bcs.n	34182220 <HAL_RCC_ClockConfig+0x390>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3418220e:	4b20      	ldr	r3, [pc, #128]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
34182210:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182212:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
34182216:	687b      	ldr	r3, [r7, #4]
34182218:	695b      	ldr	r3, [r3, #20]
3418221a:	491d      	ldr	r1, [pc, #116]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
3418221c:	4313      	orrs	r3, r2
3418221e:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
34182220:	687b      	ldr	r3, [r7, #4]
34182222:	681b      	ldr	r3, [r3, #0]
34182224:	f003 0320 	and.w	r3, r3, #32
34182228:	2b00      	cmp	r3, #0
3418222a:	d010      	beq.n	3418224e <HAL_RCC_ClockConfig+0x3be>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3418222c:	687b      	ldr	r3, [r7, #4]
3418222e:	699a      	ldr	r2, [r3, #24]
34182230:	4b17      	ldr	r3, [pc, #92]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
34182232:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182234:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
34182238:	429a      	cmp	r2, r3
3418223a:	d208      	bcs.n	3418224e <HAL_RCC_ClockConfig+0x3be>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3418223c:	4b14      	ldr	r3, [pc, #80]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
3418223e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182240:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
34182244:	687b      	ldr	r3, [r7, #4]
34182246:	699b      	ldr	r3, [r3, #24]
34182248:	4911      	ldr	r1, [pc, #68]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
3418224a:	4313      	orrs	r3, r2
3418224c:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3418224e:	687b      	ldr	r3, [r7, #4]
34182250:	681b      	ldr	r3, [r3, #0]
34182252:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34182256:	2b00      	cmp	r3, #0
34182258:	d010      	beq.n	3418227c <HAL_RCC_ClockConfig+0x3ec>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3418225a:	687b      	ldr	r3, [r7, #4]
3418225c:	69da      	ldr	r2, [r3, #28]
3418225e:	4b0c      	ldr	r3, [pc, #48]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
34182260:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182262:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
34182266:	429a      	cmp	r2, r3
34182268:	d208      	bcs.n	3418227c <HAL_RCC_ClockConfig+0x3ec>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3418226a:	4b09      	ldr	r3, [pc, #36]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
3418226c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418226e:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34182272:	687b      	ldr	r3, [r7, #4]
34182274:	69db      	ldr	r3, [r3, #28]
34182276:	4906      	ldr	r1, [pc, #24]	@ (34182290 <HAL_RCC_ClockConfig+0x400>)
34182278:	4313      	orrs	r3, r2
3418227a:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(uwTickPrio);
3418227c:	4b05      	ldr	r3, [pc, #20]	@ (34182294 <HAL_RCC_ClockConfig+0x404>)
3418227e:	681b      	ldr	r3, [r3, #0]
34182280:	4618      	mov	r0, r3
34182282:	f7fe fe57 	bl	34180f34 <HAL_InitTick>
34182286:	4603      	mov	r3, r0
}
34182288:	4618      	mov	r0, r3
3418228a:	3710      	adds	r7, #16
3418228c:	46bd      	mov	sp, r7
3418228e:	bd80      	pop	{r7, pc}
34182290:	56028000 	.word	0x56028000
34182294:	341c0004 	.word	0x341c0004

34182298 <HAL_RCC_GetCpuClockFreq>:
  *         will be incorrect.
  *
  * @retval CPUCLK frequency
  */
uint32_t HAL_RCC_GetCpuClockFreq(void)
{
34182298:	b580      	push	{r7, lr}
3418229a:	b082      	sub	sp, #8
3418229c:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
3418229e:	2300      	movs	r3, #0
341822a0:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetCpuClkSource())
341822a2:	f7ff f8cb 	bl	3418143c <LL_RCC_GetCpuClkSource>
341822a6:	4603      	mov	r3, r0
341822a8:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
341822ac:	d025      	beq.n	341822fa <HAL_RCC_GetCpuClockFreq+0x62>
341822ae:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
341822b2:	d860      	bhi.n	34182376 <HAL_RCC_GetCpuClockFreq+0xde>
341822b4:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
341822b8:	d01c      	beq.n	341822f4 <HAL_RCC_GetCpuClockFreq+0x5c>
341822ba:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
341822be:	d85a      	bhi.n	34182376 <HAL_RCC_GetCpuClockFreq+0xde>
341822c0:	2b00      	cmp	r3, #0
341822c2:	d003      	beq.n	341822cc <HAL_RCC_GetCpuClockFreq+0x34>
341822c4:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
341822c8:	d009      	beq.n	341822de <HAL_RCC_GetCpuClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
341822ca:	e054      	b.n	34182376 <HAL_RCC_GetCpuClockFreq+0xde>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
341822cc:	f7fe ffec 	bl	341812a8 <LL_RCC_HSI_GetDivider>
341822d0:	4603      	mov	r3, r0
341822d2:	09db      	lsrs	r3, r3, #7
341822d4:	4a2b      	ldr	r2, [pc, #172]	@ (34182384 <HAL_RCC_GetCpuClockFreq+0xec>)
341822d6:	fa22 f303 	lsr.w	r3, r2, r3
341822da:	607b      	str	r3, [r7, #4]
      break;
341822dc:	e04c      	b.n	34182378 <HAL_RCC_GetCpuClockFreq+0xe0>
      if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
341822de:	f7ff f84b 	bl	34181378 <LL_RCC_MSI_GetFrequency>
341822e2:	4603      	mov	r3, r0
341822e4:	2b00      	cmp	r3, #0
341822e6:	d102      	bne.n	341822ee <HAL_RCC_GetCpuClockFreq+0x56>
        frequency = MSI_VALUE;
341822e8:	4b27      	ldr	r3, [pc, #156]	@ (34182388 <HAL_RCC_GetCpuClockFreq+0xf0>)
341822ea:	607b      	str	r3, [r7, #4]
      break;
341822ec:	e044      	b.n	34182378 <HAL_RCC_GetCpuClockFreq+0xe0>
        frequency = 16000000UL;
341822ee:	4b27      	ldr	r3, [pc, #156]	@ (3418238c <HAL_RCC_GetCpuClockFreq+0xf4>)
341822f0:	607b      	str	r3, [r7, #4]
      break;
341822f2:	e041      	b.n	34182378 <HAL_RCC_GetCpuClockFreq+0xe0>
      frequency = HSE_VALUE;
341822f4:	4b26      	ldr	r3, [pc, #152]	@ (34182390 <HAL_RCC_GetCpuClockFreq+0xf8>)
341822f6:	607b      	str	r3, [r7, #4]
      break;
341822f8:	e03e      	b.n	34182378 <HAL_RCC_GetCpuClockFreq+0xe0>
      ic_divider = LL_RCC_IC1_GetDivider();
341822fa:	f7ff f9af 	bl	3418165c <LL_RCC_IC1_GetDivider>
341822fe:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC1_GetSource())
34182300:	f7ff f99e 	bl	34181640 <LL_RCC_IC1_GetSource>
34182304:	4603      	mov	r3, r0
34182306:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418230a:	d029      	beq.n	34182360 <HAL_RCC_GetCpuClockFreq+0xc8>
3418230c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34182310:	d82f      	bhi.n	34182372 <HAL_RCC_GetCpuClockFreq+0xda>
34182312:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34182316:	d01a      	beq.n	3418234e <HAL_RCC_GetCpuClockFreq+0xb6>
34182318:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418231c:	d829      	bhi.n	34182372 <HAL_RCC_GetCpuClockFreq+0xda>
3418231e:	2b00      	cmp	r3, #0
34182320:	d003      	beq.n	3418232a <HAL_RCC_GetCpuClockFreq+0x92>
34182322:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34182326:	d009      	beq.n	3418233c <HAL_RCC_GetCpuClockFreq+0xa4>
          break;
34182328:	e023      	b.n	34182372 <HAL_RCC_GetCpuClockFreq+0xda>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418232a:	f000 fe23 	bl	34182f74 <HAL_RCCEx_GetPLL1CLKFreq>
3418232e:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34182330:	687a      	ldr	r2, [r7, #4]
34182332:	683b      	ldr	r3, [r7, #0]
34182334:	fbb2 f3f3 	udiv	r3, r2, r3
34182338:	607b      	str	r3, [r7, #4]
          break;
3418233a:	e01b      	b.n	34182374 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418233c:	f000 fe60 	bl	34183000 <HAL_RCCEx_GetPLL2CLKFreq>
34182340:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34182342:	687a      	ldr	r2, [r7, #4]
34182344:	683b      	ldr	r3, [r7, #0]
34182346:	fbb2 f3f3 	udiv	r3, r2, r3
3418234a:	607b      	str	r3, [r7, #4]
          break;
3418234c:	e012      	b.n	34182374 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418234e:	f000 fe9d 	bl	3418308c <HAL_RCCEx_GetPLL3CLKFreq>
34182352:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34182354:	687a      	ldr	r2, [r7, #4]
34182356:	683b      	ldr	r3, [r7, #0]
34182358:	fbb2 f3f3 	udiv	r3, r2, r3
3418235c:	607b      	str	r3, [r7, #4]
          break;
3418235e:	e009      	b.n	34182374 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
34182360:	f000 feda 	bl	34183118 <HAL_RCCEx_GetPLL4CLKFreq>
34182364:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34182366:	687a      	ldr	r2, [r7, #4]
34182368:	683b      	ldr	r3, [r7, #0]
3418236a:	fbb2 f3f3 	udiv	r3, r2, r3
3418236e:	607b      	str	r3, [r7, #4]
          break;
34182370:	e000      	b.n	34182374 <HAL_RCC_GetCpuClockFreq+0xdc>
          break;
34182372:	bf00      	nop
      break;
34182374:	e000      	b.n	34182378 <HAL_RCC_GetCpuClockFreq+0xe0>
      break;
34182376:	bf00      	nop
  }

  return frequency;
34182378:	687b      	ldr	r3, [r7, #4]
}
3418237a:	4618      	mov	r0, r3
3418237c:	3708      	adds	r7, #8
3418237e:	46bd      	mov	sp, r7
34182380:	bd80      	pop	{r7, pc}
34182382:	bf00      	nop
34182384:	03d09000 	.word	0x03d09000
34182388:	003d0900 	.word	0x003d0900
3418238c:	00f42400 	.word	0x00f42400
34182390:	02dc6c00 	.word	0x02dc6c00

34182394 <HAL_RCC_GetClockConfig>:
  * @param  pRCC_ClkInitStruct  Pointer to an RCC_ClkInitTypeDef structure that
  *         will return the configuration.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
34182394:	b480      	push	{r7}
34182396:	b085      	sub	sp, #20
34182398:	af00      	add	r7, sp, #0
3418239a:	6078      	str	r0, [r7, #4]
  uint32_t cfgr_value;

  /* Set all possible values for the Clock type parameter --------------------*/
  pRCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK | \
3418239c:	687b      	ldr	r3, [r7, #4]
3418239e:	227f      	movs	r2, #127	@ 0x7f
341823a0:	601a      	str	r2, [r3, #0]
                                  RCC_CLOCKTYPE_HCLK   | \
                                  RCC_CLOCKTYPE_PCLK1  | RCC_CLOCKTYPE_PCLK2 | \
                                  RCC_CLOCKTYPE_PCLK4  | RCC_CLOCKTYPE_PCLK5;

  /* Get the configuration register 1 value */
  cfgr_value = RCC->CFGR1;
341823a2:	4b36      	ldr	r3, [pc, #216]	@ (3418247c <HAL_RCC_GetClockConfig+0xe8>)
341823a4:	6a1b      	ldr	r3, [r3, #32]
341823a6:	60fb      	str	r3, [r7, #12]

  /* Get the active CPU source -----------------------------------------------*/
  pRCC_ClkInitStruct->CPUCLKSource = (cfgr_value & RCC_CFGR1_CPUSWS) >> 4U;
341823a8:	68fb      	ldr	r3, [r7, #12]
341823aa:	091b      	lsrs	r3, r3, #4
341823ac:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
341823b0:	687b      	ldr	r3, [r7, #4]
341823b2:	605a      	str	r2, [r3, #4]

  /* Get the active SYSCLK bus source ----------------------------------------*/
  pRCC_ClkInitStruct->SYSCLKSource = (cfgr_value & RCC_CFGR1_SYSSWS) >> 4U;
341823b4:	68fb      	ldr	r3, [r7, #12]
341823b6:	091b      	lsrs	r3, r3, #4
341823b8:	f003 7240 	and.w	r2, r3, #50331648	@ 0x3000000
341823bc:	687b      	ldr	r3, [r7, #4]
341823be:	609a      	str	r2, [r3, #8]

  /* Get the configuration register 2 value */
  cfgr_value = RCC->CFGR2;
341823c0:	4b2e      	ldr	r3, [pc, #184]	@ (3418247c <HAL_RCC_GetClockConfig+0xe8>)
341823c2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341823c4:	60fb      	str	r3, [r7, #12]

  /* Get the HCLK configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->AHBCLKDivider = (cfgr_value & RCC_CFGR2_HPRE);
341823c6:	68fb      	ldr	r3, [r7, #12]
341823c8:	f403 02e0 	and.w	r2, r3, #7340032	@ 0x700000
341823cc:	687b      	ldr	r3, [r7, #4]
341823ce:	60da      	str	r2, [r3, #12]

  /* Get the APB1 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB1CLKDivider = (cfgr_value & RCC_CFGR2_PPRE1);
341823d0:	68fb      	ldr	r3, [r7, #12]
341823d2:	f003 0207 	and.w	r2, r3, #7
341823d6:	687b      	ldr	r3, [r7, #4]
341823d8:	611a      	str	r2, [r3, #16]

  /* Get the APB2 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB2CLKDivider = (cfgr_value & RCC_CFGR2_PPRE2);
341823da:	68fb      	ldr	r3, [r7, #12]
341823dc:	f003 0270 	and.w	r2, r3, #112	@ 0x70
341823e0:	687b      	ldr	r3, [r7, #4]
341823e2:	615a      	str	r2, [r3, #20]

  /* Get the APB4 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB4CLKDivider = (cfgr_value & RCC_CFGR2_PPRE4);
341823e4:	68fb      	ldr	r3, [r7, #12]
341823e6:	f403 42e0 	and.w	r2, r3, #28672	@ 0x7000
341823ea:	687b      	ldr	r3, [r7, #4]
341823ec:	619a      	str	r2, [r3, #24]

  /* Get the APB5 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB5CLKDivider = (cfgr_value & RCC_CFGR2_PPRE5);
341823ee:	68fb      	ldr	r3, [r7, #12]
341823f0:	f403 22e0 	and.w	r2, r3, #458752	@ 0x70000
341823f4:	687b      	ldr	r3, [r7, #4]
341823f6:	61da      	str	r2, [r3, #28]

  /* Get the IC1 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC1CFGR;
341823f8:	4b20      	ldr	r3, [pc, #128]	@ (3418247c <HAL_RCC_GetClockConfig+0xe8>)
341823fa:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
341823fe:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC1Selection.ClockSelection = cfgr_value & RCC_IC1CFGR_IC1SEL;
34182400:	68fb      	ldr	r3, [r7, #12]
34182402:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
34182406:	687b      	ldr	r3, [r7, #4]
34182408:	621a      	str	r2, [r3, #32]
  pRCC_ClkInitStruct->IC1Selection.ClockDivider = ((cfgr_value & RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1U;
3418240a:	68fb      	ldr	r3, [r7, #12]
3418240c:	0c1b      	lsrs	r3, r3, #16
3418240e:	b2db      	uxtb	r3, r3
34182410:	1c5a      	adds	r2, r3, #1
34182412:	687b      	ldr	r3, [r7, #4]
34182414:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Get the IC2 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC2CFGR;
34182416:	4b19      	ldr	r3, [pc, #100]	@ (3418247c <HAL_RCC_GetClockConfig+0xe8>)
34182418:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3418241c:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC2Selection.ClockSelection = cfgr_value & RCC_IC2CFGR_IC2SEL;
3418241e:	68fb      	ldr	r3, [r7, #12]
34182420:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
34182424:	687b      	ldr	r3, [r7, #4]
34182426:	629a      	str	r2, [r3, #40]	@ 0x28
  pRCC_ClkInitStruct->IC2Selection.ClockDivider = ((cfgr_value & RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1U;
34182428:	68fb      	ldr	r3, [r7, #12]
3418242a:	0c1b      	lsrs	r3, r3, #16
3418242c:	b2db      	uxtb	r3, r3
3418242e:	1c5a      	adds	r2, r3, #1
34182430:	687b      	ldr	r3, [r7, #4]
34182432:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Get the IC6 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC6CFGR;
34182434:	4b11      	ldr	r3, [pc, #68]	@ (3418247c <HAL_RCC_GetClockConfig+0xe8>)
34182436:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3418243a:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC6Selection.ClockSelection = cfgr_value & RCC_IC6CFGR_IC6SEL;
3418243c:	68fb      	ldr	r3, [r7, #12]
3418243e:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
34182442:	687b      	ldr	r3, [r7, #4]
34182444:	631a      	str	r2, [r3, #48]	@ 0x30
  pRCC_ClkInitStruct->IC6Selection.ClockDivider = ((cfgr_value & RCC_IC6CFGR_IC6INT) >> RCC_IC6CFGR_IC6INT_Pos) + 1U;
34182446:	68fb      	ldr	r3, [r7, #12]
34182448:	0c1b      	lsrs	r3, r3, #16
3418244a:	b2db      	uxtb	r3, r3
3418244c:	1c5a      	adds	r2, r3, #1
3418244e:	687b      	ldr	r3, [r7, #4]
34182450:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Get the IC11 configuration ----------------------------------------------*/
  cfgr_value = RCC->IC11CFGR;
34182452:	4b0a      	ldr	r3, [pc, #40]	@ (3418247c <HAL_RCC_GetClockConfig+0xe8>)
34182454:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34182458:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC11Selection.ClockSelection = cfgr_value & RCC_IC11CFGR_IC11SEL;
3418245a:	68fb      	ldr	r3, [r7, #12]
3418245c:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
34182460:	687b      	ldr	r3, [r7, #4]
34182462:	639a      	str	r2, [r3, #56]	@ 0x38
  pRCC_ClkInitStruct->IC11Selection.ClockDivider = ((cfgr_value & RCC_IC11CFGR_IC11INT) >> RCC_IC11CFGR_IC11INT_Pos) + 1U;
34182464:	68fb      	ldr	r3, [r7, #12]
34182466:	0c1b      	lsrs	r3, r3, #16
34182468:	b2db      	uxtb	r3, r3
3418246a:	1c5a      	adds	r2, r3, #1
3418246c:	687b      	ldr	r3, [r7, #4]
3418246e:	63da      	str	r2, [r3, #60]	@ 0x3c
}
34182470:	bf00      	nop
34182472:	3714      	adds	r7, #20
34182474:	46bd      	mov	sp, r7
34182476:	f85d 7b04 	ldr.w	r7, [sp], #4
3418247a:	4770      	bx	lr
3418247c:	56028000 	.word	0x56028000

34182480 <RCC_PLL_Config>:
  * @note   PLL is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Config(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
34182480:	b580      	push	{r7, lr}
34182482:	b088      	sub	sp, #32
34182484:	af00      	add	r7, sp, #0
34182486:	6078      	str	r0, [r7, #4]
34182488:	6039      	str	r1, [r7, #0]
  __IO uint32_t *p_rcc_pll_cfgr1_reg;
  __IO uint32_t *p_rcc_pll_cfgr2_reg;
  __IO uint32_t *p_rcc_pll_cfgr3_reg;
  HAL_StatusTypeDef ret = HAL_OK;
3418248a:	2300      	movs	r3, #0
3418248c:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart;

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3418248e:	687b      	ldr	r3, [r7, #4]
34182490:	011a      	lsls	r2, r3, #4
34182492:	4b8e      	ldr	r3, [pc, #568]	@ (341826cc <RCC_PLL_Config+0x24c>)
34182494:	4413      	add	r3, r2
34182496:	61bb      	str	r3, [r7, #24]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
34182498:	687b      	ldr	r3, [r7, #4]
3418249a:	011a      	lsls	r2, r3, #4
3418249c:	4b8c      	ldr	r3, [pc, #560]	@ (341826d0 <RCC_PLL_Config+0x250>)
3418249e:	4413      	add	r3, r2
341824a0:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
341824a2:	687b      	ldr	r3, [r7, #4]
341824a4:	011a      	lsls	r2, r3, #4
341824a6:	4b8b      	ldr	r3, [pc, #556]	@ (341826d4 <RCC_PLL_Config+0x254>)
341824a8:	4413      	add	r3, r2
341824aa:	613b      	str	r3, [r7, #16]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */
  if (pPLLInit->PLLState == RCC_PLL_ON)
341824ac:	683b      	ldr	r3, [r7, #0]
341824ae:	681b      	ldr	r3, [r3, #0]
341824b0:	2b02      	cmp	r3, #2
341824b2:	f040 8091 	bne.w	341825d8 <RCC_PLL_Config+0x158>
    assert_param(IS_RCC_PLLN_VALUE(pPLLInit->PLLN));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP1));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP2));

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
341824b6:	4a88      	ldr	r2, [pc, #544]	@ (341826d8 <RCC_PLL_Config+0x258>)
341824b8:	f44f 7180 	mov.w	r1, #256	@ 0x100
341824bc:	687b      	ldr	r3, [r7, #4]
341824be:	fa01 f303 	lsl.w	r3, r1, r3
341824c2:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
341824c6:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
341824c8:	f7fe fd7e 	bl	34180fc8 <HAL_GetTick>
341824cc:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
341824ce:	e008      	b.n	341824e2 <RCC_PLL_Config+0x62>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
341824d0:	f7fe fd7a 	bl	34180fc8 <HAL_GetTick>
341824d4:	4602      	mov	r2, r0
341824d6:	68fb      	ldr	r3, [r7, #12]
341824d8:	1ad3      	subs	r3, r2, r3
341824da:	2b01      	cmp	r3, #1
341824dc:	d901      	bls.n	341824e2 <RCC_PLL_Config+0x62>
      {
        return HAL_TIMEOUT;
341824de:	2303      	movs	r3, #3
341824e0:	e0f0      	b.n	341826c4 <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
341824e2:	4b7d      	ldr	r3, [pc, #500]	@ (341826d8 <RCC_PLL_Config+0x258>)
341824e4:	685a      	ldr	r2, [r3, #4]
341824e6:	f44f 7180 	mov.w	r1, #256	@ 0x100
341824ea:	687b      	ldr	r3, [r7, #4]
341824ec:	fa01 f303 	lsl.w	r3, r1, r3
341824f0:	401a      	ands	r2, r3
341824f2:	f44f 7180 	mov.w	r1, #256	@ 0x100
341824f6:	687b      	ldr	r3, [r7, #4]
341824f8:	fa01 f303 	lsl.w	r3, r1, r3
341824fc:	429a      	cmp	r2, r3
341824fe:	d0e7      	beq.n	341824d0 <RCC_PLL_Config+0x50>
      }
    }

    /* Ensure PLLxMODSSDIS='1' */
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
34182500:	693b      	ldr	r3, [r7, #16]
34182502:	681b      	ldr	r3, [r3, #0]
34182504:	f043 0204 	orr.w	r2, r3, #4
34182508:	693b      	ldr	r3, [r7, #16]
3418250a:	601a      	str	r2, [r3, #0]

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3418250c:	69bb      	ldr	r3, [r7, #24]
3418250e:	681b      	ldr	r3, [r3, #0]
34182510:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
34182514:	69bb      	ldr	r3, [r7, #24]
34182516:	601a      	str	r2, [r3, #0]

    /* Configure the PLLx clock source, multiplication and division factors. */
    MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN), \
34182518:	69bb      	ldr	r3, [r7, #24]
3418251a:	681a      	ldr	r2, [r3, #0]
3418251c:	4b6f      	ldr	r3, [pc, #444]	@ (341826dc <RCC_PLL_Config+0x25c>)
3418251e:	4013      	ands	r3, r2
34182520:	683a      	ldr	r2, [r7, #0]
34182522:	6851      	ldr	r1, [r2, #4]
34182524:	683a      	ldr	r2, [r7, #0]
34182526:	6892      	ldr	r2, [r2, #8]
34182528:	0512      	lsls	r2, r2, #20
3418252a:	4311      	orrs	r1, r2
3418252c:	683a      	ldr	r2, [r7, #0]
3418252e:	6912      	ldr	r2, [r2, #16]
34182530:	0212      	lsls	r2, r2, #8
34182532:	430a      	orrs	r2, r1
34182534:	431a      	orrs	r2, r3
34182536:	69bb      	ldr	r3, [r7, #24]
34182538:	601a      	str	r2, [r3, #0]
               (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
                | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)));
    MODIFY_REG(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2), \
3418253a:	693b      	ldr	r3, [r7, #16]
3418253c:	681b      	ldr	r3, [r3, #0]
3418253e:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
34182542:	683b      	ldr	r3, [r7, #0]
34182544:	695b      	ldr	r3, [r3, #20]
34182546:	06d9      	lsls	r1, r3, #27
34182548:	683b      	ldr	r3, [r7, #0]
3418254a:	699b      	ldr	r3, [r3, #24]
3418254c:	061b      	lsls	r3, r3, #24
3418254e:	430b      	orrs	r3, r1
34182550:	431a      	orrs	r2, r3
34182552:	693b      	ldr	r3, [r7, #16]
34182554:	601a      	str	r2, [r3, #0]
               ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)));

    /* Configure PLLx DIVNFRAC */
    MODIFY_REG(*p_rcc_pll_cfgr2_reg, RCC_PLL1CFGR2_PLL1DIVNFRAC, \
34182556:	697b      	ldr	r3, [r7, #20]
34182558:	681b      	ldr	r3, [r3, #0]
3418255a:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
3418255e:	683b      	ldr	r3, [r7, #0]
34182560:	68db      	ldr	r3, [r3, #12]
34182562:	431a      	orrs	r2, r3
34182564:	697b      	ldr	r3, [r7, #20]
34182566:	601a      	str	r2, [r3, #0]
               pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);

    /* Clear PLLxMODDSEN (Also clear in Fractional Mode to ensure the latch of updated FRAC value when set again) */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODDSEN);
34182568:	693b      	ldr	r3, [r7, #16]
3418256a:	681b      	ldr	r3, [r3, #0]
3418256c:	f023 0208 	bic.w	r2, r3, #8
34182570:	693b      	ldr	r3, [r7, #16]
34182572:	601a      	str	r2, [r3, #0]

    /* Fractional Mode specificities Management */
    if (pPLLInit->PLLFractional != 0U)
34182574:	683b      	ldr	r3, [r7, #0]
34182576:	68db      	ldr	r3, [r3, #12]
34182578:	2b00      	cmp	r3, #0
3418257a:	d005      	beq.n	34182588 <RCC_PLL_Config+0x108>
    {
      /* Set PLLxMODDSEN and DACEN */
      SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODDSEN | RCC_PLL1CFGR3_PLL1DACEN));
3418257c:	693b      	ldr	r3, [r7, #16]
3418257e:	681b      	ldr	r3, [r3, #0]
34182580:	f043 020a 	orr.w	r2, r3, #10
34182584:	693b      	ldr	r3, [r7, #16]
34182586:	601a      	str	r2, [r3, #0]
    }

    /* Ensure PLLxMODSSRST='1' and Enable PLLx post divider output */
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
34182588:	693b      	ldr	r3, [r7, #16]
3418258a:	681b      	ldr	r3, [r3, #0]
3418258c:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34182590:	f043 0301 	orr.w	r3, r3, #1
34182594:	693a      	ldr	r2, [r7, #16]
34182596:	6013      	str	r3, [r2, #0]

    /* Enable the PLLx */
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
34182598:	4a4f      	ldr	r2, [pc, #316]	@ (341826d8 <RCC_PLL_Config+0x258>)
3418259a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418259e:	687b      	ldr	r3, [r7, #4]
341825a0:	fa01 f303 	lsl.w	r3, r1, r3
341825a4:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
341825a8:	f7fe fd0e 	bl	34180fc8 <HAL_GetTick>
341825ac:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is ready */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
341825ae:	e008      	b.n	341825c2 <RCC_PLL_Config+0x142>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
341825b0:	f7fe fd0a 	bl	34180fc8 <HAL_GetTick>
341825b4:	4602      	mov	r2, r0
341825b6:	68fb      	ldr	r3, [r7, #12]
341825b8:	1ad3      	subs	r3, r2, r3
341825ba:	2b01      	cmp	r3, #1
341825bc:	d901      	bls.n	341825c2 <RCC_PLL_Config+0x142>
      {
        return HAL_TIMEOUT;
341825be:	2303      	movs	r3, #3
341825c0:	e080      	b.n	341826c4 <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
341825c2:	4b45      	ldr	r3, [pc, #276]	@ (341826d8 <RCC_PLL_Config+0x258>)
341825c4:	685a      	ldr	r2, [r3, #4]
341825c6:	f44f 7180 	mov.w	r1, #256	@ 0x100
341825ca:	687b      	ldr	r3, [r7, #4]
341825cc:	fa01 f303 	lsl.w	r3, r1, r3
341825d0:	4013      	ands	r3, r2
341825d2:	2b00      	cmp	r3, #0
341825d4:	d0ec      	beq.n	341825b0 <RCC_PLL_Config+0x130>
341825d6:	e074      	b.n	341826c2 <RCC_PLL_Config+0x242>
      }
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_BYPASS)
341825d8:	683b      	ldr	r3, [r7, #0]
341825da:	681b      	ldr	r3, [r3, #0]
341825dc:	2b03      	cmp	r3, #3
341825de:	d13b      	bne.n	34182658 <RCC_PLL_Config+0x1d8>
  {
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));

    /* Check selected source is ready */
    if (RCC_PLL_Source_IsReady(pPLLInit->PLLSource) == 1U)
341825e0:	683b      	ldr	r3, [r7, #0]
341825e2:	685b      	ldr	r3, [r3, #4]
341825e4:	4618      	mov	r0, r3
341825e6:	f000 f921 	bl	3418282c <RCC_PLL_Source_IsReady>
341825ea:	4603      	mov	r3, r0
341825ec:	2b01      	cmp	r3, #1
341825ee:	d130      	bne.n	34182652 <RCC_PLL_Config+0x1d2>
    {
      /* Ensure PLLx is disabled */
      WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
341825f0:	4a39      	ldr	r2, [pc, #228]	@ (341826d8 <RCC_PLL_Config+0x258>)
341825f2:	f44f 7180 	mov.w	r1, #256	@ 0x100
341825f6:	687b      	ldr	r3, [r7, #4]
341825f8:	fa01 f303 	lsl.w	r3, r1, r3
341825fc:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34182600:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34182602:	f7fe fce1 	bl	34180fc8 <HAL_GetTick>
34182606:	60f8      	str	r0, [r7, #12]

      /* Wait till PLLx is disabled */
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34182608:	e008      	b.n	3418261c <RCC_PLL_Config+0x19c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418260a:	f7fe fcdd 	bl	34180fc8 <HAL_GetTick>
3418260e:	4602      	mov	r2, r0
34182610:	68fb      	ldr	r3, [r7, #12]
34182612:	1ad3      	subs	r3, r2, r3
34182614:	2b01      	cmp	r3, #1
34182616:	d901      	bls.n	3418261c <RCC_PLL_Config+0x19c>
        {
          return HAL_TIMEOUT;
34182618:	2303      	movs	r3, #3
3418261a:	e053      	b.n	341826c4 <RCC_PLL_Config+0x244>
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418261c:	4b2e      	ldr	r3, [pc, #184]	@ (341826d8 <RCC_PLL_Config+0x258>)
3418261e:	685a      	ldr	r2, [r3, #4]
34182620:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182624:	687b      	ldr	r3, [r7, #4]
34182626:	fa01 f303 	lsl.w	r3, r1, r3
3418262a:	401a      	ands	r2, r3
3418262c:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182630:	687b      	ldr	r3, [r7, #4]
34182632:	fa01 f303 	lsl.w	r3, r1, r3
34182636:	429a      	cmp	r2, r3
34182638:	d0e7      	beq.n	3418260a <RCC_PLL_Config+0x18a>
        }
      }

      /* Set bypass mode with selected source */
      MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1BYP | RCC_PLL1CFGR1_PLL1SEL), \
3418263a:	69bb      	ldr	r3, [r7, #24]
3418263c:	681b      	ldr	r3, [r3, #0]
3418263e:	f023 42f0 	bic.w	r2, r3, #2013265920	@ 0x78000000
34182642:	683b      	ldr	r3, [r7, #0]
34182644:	685b      	ldr	r3, [r3, #4]
34182646:	4313      	orrs	r3, r2
34182648:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
3418264c:	69bb      	ldr	r3, [r7, #24]
3418264e:	601a      	str	r2, [r3, #0]
34182650:	e037      	b.n	341826c2 <RCC_PLL_Config+0x242>
                 (RCC_PLL1CFGR1_PLL1BYP | pPLLInit->PLLSource));
    }
    else
    {
      ret = HAL_ERROR;
34182652:	2301      	movs	r3, #1
34182654:	77fb      	strb	r3, [r7, #31]
34182656:	e034      	b.n	341826c2 <RCC_PLL_Config+0x242>
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_OFF)
34182658:	683b      	ldr	r3, [r7, #0]
3418265a:	681b      	ldr	r3, [r3, #0]
3418265c:	2b01      	cmp	r3, #1
3418265e:	d130      	bne.n	341826c2 <RCC_PLL_Config+0x242>
  {
    /* Disable PLLx post divider output */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
34182660:	693b      	ldr	r3, [r7, #16]
34182662:	681b      	ldr	r3, [r3, #0]
34182664:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
34182668:	693b      	ldr	r3, [r7, #16]
3418266a:	601a      	str	r2, [r3, #0]

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3418266c:	4a1a      	ldr	r2, [pc, #104]	@ (341826d8 <RCC_PLL_Config+0x258>)
3418266e:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182672:	687b      	ldr	r3, [r7, #4]
34182674:	fa01 f303 	lsl.w	r3, r1, r3
34182678:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418267c:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418267e:	f7fe fca3 	bl	34180fc8 <HAL_GetTick>
34182682:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34182684:	e008      	b.n	34182698 <RCC_PLL_Config+0x218>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34182686:	f7fe fc9f 	bl	34180fc8 <HAL_GetTick>
3418268a:	4602      	mov	r2, r0
3418268c:	68fb      	ldr	r3, [r7, #12]
3418268e:	1ad3      	subs	r3, r2, r3
34182690:	2b01      	cmp	r3, #1
34182692:	d901      	bls.n	34182698 <RCC_PLL_Config+0x218>
      {
        return HAL_TIMEOUT;
34182694:	2303      	movs	r3, #3
34182696:	e015      	b.n	341826c4 <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34182698:	4b0f      	ldr	r3, [pc, #60]	@ (341826d8 <RCC_PLL_Config+0x258>)
3418269a:	685a      	ldr	r2, [r3, #4]
3418269c:	f44f 7180 	mov.w	r1, #256	@ 0x100
341826a0:	687b      	ldr	r3, [r7, #4]
341826a2:	fa01 f303 	lsl.w	r3, r1, r3
341826a6:	401a      	ands	r2, r3
341826a8:	f44f 7180 	mov.w	r1, #256	@ 0x100
341826ac:	687b      	ldr	r3, [r7, #4]
341826ae:	fa01 f303 	lsl.w	r3, r1, r3
341826b2:	429a      	cmp	r2, r3
341826b4:	d0e7      	beq.n	34182686 <RCC_PLL_Config+0x206>
      }
    }

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
341826b6:	69bb      	ldr	r3, [r7, #24]
341826b8:	681b      	ldr	r3, [r3, #0]
341826ba:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
341826be:	69bb      	ldr	r3, [r7, #24]
341826c0:	601a      	str	r2, [r3, #0]
  else
  {
    /* Nothing to do */
  }

  return ret;
341826c2:	7ffb      	ldrb	r3, [r7, #31]
}
341826c4:	4618      	mov	r0, r3
341826c6:	3720      	adds	r7, #32
341826c8:	46bd      	mov	sp, r7
341826ca:	bd80      	pop	{r7, pc}
341826cc:	56028080 	.word	0x56028080
341826d0:	56028084 	.word	0x56028084
341826d4:	56028088 	.word	0x56028088
341826d8:	56028000 	.word	0x56028000
341826dc:	8c0000ff 	.word	0x8c0000ff

341826e0 <RCC_PLL_Enable>:
  * @param  PLLnumber PLL number to enable
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Enable(uint32_t PLLnumber)
{
341826e0:	b580      	push	{r7, lr}
341826e2:	b084      	sub	sp, #16
341826e4:	af00      	add	r7, sp, #0
341826e6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
341826e8:	2300      	movs	r3, #0
341826ea:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Enable the PLLx */
  WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
341826ec:	4a11      	ldr	r2, [pc, #68]	@ (34182734 <RCC_PLL_Enable+0x54>)
341826ee:	f44f 7180 	mov.w	r1, #256	@ 0x100
341826f2:	687b      	ldr	r3, [r7, #4]
341826f4:	fa01 f303 	lsl.w	r3, r1, r3
341826f8:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
341826fc:	f7fe fc64 	bl	34180fc8 <HAL_GetTick>
34182700:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLx is ready */
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
34182702:	e008      	b.n	34182716 <RCC_PLL_Enable+0x36>
  {
    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34182704:	f7fe fc60 	bl	34180fc8 <HAL_GetTick>
34182708:	4602      	mov	r2, r0
3418270a:	68bb      	ldr	r3, [r7, #8]
3418270c:	1ad3      	subs	r3, r2, r3
3418270e:	2b01      	cmp	r3, #1
34182710:	d901      	bls.n	34182716 <RCC_PLL_Enable+0x36>
    {
      return HAL_TIMEOUT;
34182712:	2303      	movs	r3, #3
34182714:	e00a      	b.n	3418272c <RCC_PLL_Enable+0x4c>
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
34182716:	4b07      	ldr	r3, [pc, #28]	@ (34182734 <RCC_PLL_Enable+0x54>)
34182718:	685a      	ldr	r2, [r3, #4]
3418271a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418271e:	687b      	ldr	r3, [r7, #4]
34182720:	fa01 f303 	lsl.w	r3, r1, r3
34182724:	4013      	ands	r3, r2
34182726:	2b00      	cmp	r3, #0
34182728:	d0ec      	beq.n	34182704 <RCC_PLL_Enable+0x24>
    }
  }

  return ret;
3418272a:	7bfb      	ldrb	r3, [r7, #15]
}
3418272c:	4618      	mov	r0, r3
3418272e:	3710      	adds	r7, #16
34182730:	46bd      	mov	sp, r7
34182732:	bd80      	pop	{r7, pc}
34182734:	56028000 	.word	0x56028000

34182738 <RCC_PLL_IsNewConfig>:
  * @param  pPLLInit Pointer to an RCC_PLLInitTypeDef structure that
  *                  contains the configuration parameters.  *
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_IsNewConfig(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
34182738:	b480      	push	{r7}
3418273a:	b089      	sub	sp, #36	@ 0x24
3418273c:	af00      	add	r7, sp, #0
3418273e:	6078      	str	r0, [r7, #4]
34182740:	6039      	str	r1, [r7, #0]
  __IO const uint32_t *p_rcc_pll_cfgr1_reg, *p_rcc_pll_cfgr2_reg, *p_rcc_pll_cfgr3_reg;
  uint32_t ret = 0U;
34182742:	2300      	movs	r3, #0
34182744:	61fb      	str	r3, [r7, #28]

  /* No assert since done in calling function */

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
34182746:	687b      	ldr	r3, [r7, #4]
34182748:	011a      	lsls	r2, r3, #4
3418274a:	4b34      	ldr	r3, [pc, #208]	@ (3418281c <RCC_PLL_IsNewConfig+0xe4>)
3418274c:	4413      	add	r3, r2
3418274e:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
34182750:	687b      	ldr	r3, [r7, #4]
34182752:	011a      	lsls	r2, r3, #4
34182754:	4b32      	ldr	r3, [pc, #200]	@ (34182820 <RCC_PLL_IsNewConfig+0xe8>)
34182756:	4413      	add	r3, r2
34182758:	613b      	str	r3, [r7, #16]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3418275a:	687b      	ldr	r3, [r7, #4]
3418275c:	011a      	lsls	r2, r3, #4
3418275e:	4b31      	ldr	r3, [pc, #196]	@ (34182824 <RCC_PLL_IsNewConfig+0xec>)
34182760:	4413      	add	r3, r2
34182762:	60fb      	str	r3, [r7, #12]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */

  /* Check for PLLCFGR1, PLLCFGR2 and PLLCFGR3 parameters updates */
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
34182764:	697b      	ldr	r3, [r7, #20]
34182766:	681b      	ldr	r3, [r3, #0]
34182768:	f023 430c 	bic.w	r3, r3, #2348810240	@ 0x8c000000
3418276c:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
34182770:	683a      	ldr	r2, [r7, #0]
34182772:	6851      	ldr	r1, [r2, #4]
34182774:	683a      	ldr	r2, [r7, #0]
34182776:	6892      	ldr	r2, [r2, #8]
34182778:	0512      	lsls	r2, r2, #20
3418277a:	4311      	orrs	r1, r2
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
3418277c:	683a      	ldr	r2, [r7, #0]
3418277e:	6912      	ldr	r2, [r2, #16]
34182780:	0212      	lsls	r2, r2, #8
34182782:	430a      	orrs	r2, r1
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
34182784:	4293      	cmp	r3, r2
34182786:	d002      	beq.n	3418278e <RCC_PLL_IsNewConfig+0x56>
  {
    ret = 1U; /* New PLL configuration */
34182788:	2301      	movs	r3, #1
3418278a:	61fb      	str	r3, [r7, #28]
3418278c:	e03e      	b.n	3418280c <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
3418278e:	693b      	ldr	r3, [r7, #16]
34182790:	681b      	ldr	r3, [r3, #0]
34182792:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
           (pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos))
34182796:	683b      	ldr	r3, [r7, #0]
34182798:	68db      	ldr	r3, [r3, #12]
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
3418279a:	429a      	cmp	r2, r3
3418279c:	d002      	beq.n	341827a4 <RCC_PLL_IsNewConfig+0x6c>
  {
    ret = 1U; /* New PLL configuration */
3418279e:	2301      	movs	r3, #1
341827a0:	61fb      	str	r3, [r7, #28]
341827a2:	e033      	b.n	3418280c <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
341827a4:	68fb      	ldr	r3, [r7, #12]
341827a6:	681b      	ldr	r3, [r3, #0]
341827a8:	f003 527c 	and.w	r2, r3, #1056964608	@ 0x3f000000
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
341827ac:	683b      	ldr	r3, [r7, #0]
341827ae:	695b      	ldr	r3, [r3, #20]
341827b0:	06d9      	lsls	r1, r3, #27
341827b2:	683b      	ldr	r3, [r7, #0]
341827b4:	699b      	ldr	r3, [r3, #24]
341827b6:	061b      	lsls	r3, r3, #24
341827b8:	430b      	orrs	r3, r1
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
341827ba:	429a      	cmp	r2, r3
341827bc:	d002      	beq.n	341827c4 <RCC_PLL_IsNewConfig+0x8c>
  {
    ret = 1U; /* New PLL configuration */
341827be:	2301      	movs	r3, #1
341827c0:	61fb      	str	r3, [r7, #28]
341827c2:	e023      	b.n	3418280c <RCC_PLL_IsNewConfig+0xd4>
  {
    /* Mode change detection*/
    uint32_t pllState;

    /* Get current Mode*/
    if (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
341827c4:	4b18      	ldr	r3, [pc, #96]	@ (34182828 <RCC_PLL_IsNewConfig+0xf0>)
341827c6:	685a      	ldr	r2, [r3, #4]
341827c8:	f44f 7180 	mov.w	r1, #256	@ 0x100
341827cc:	687b      	ldr	r3, [r7, #4]
341827ce:	fa01 f303 	lsl.w	r3, r1, r3
341827d2:	401a      	ands	r2, r3
341827d4:	f44f 7180 	mov.w	r1, #256	@ 0x100
341827d8:	687b      	ldr	r3, [r7, #4]
341827da:	fa01 f303 	lsl.w	r3, r1, r3
341827de:	429a      	cmp	r2, r3
341827e0:	d102      	bne.n	341827e8 <RCC_PLL_IsNewConfig+0xb0>
    {
      pllState = RCC_PLL_ON;
341827e2:	2302      	movs	r3, #2
341827e4:	61bb      	str	r3, [r7, #24]
341827e6:	e00a      	b.n	341827fe <RCC_PLL_IsNewConfig+0xc6>
    }
    else
    {
      if ((*p_rcc_pll_cfgr1_reg & RCC_PLL1CFGR1_PLL1BYP) != 0UL)
341827e8:	697b      	ldr	r3, [r7, #20]
341827ea:	681b      	ldr	r3, [r3, #0]
341827ec:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
341827f0:	2b00      	cmp	r3, #0
341827f2:	d002      	beq.n	341827fa <RCC_PLL_IsNewConfig+0xc2>
      {
        pllState = RCC_PLL_BYPASS;
341827f4:	2303      	movs	r3, #3
341827f6:	61bb      	str	r3, [r7, #24]
341827f8:	e001      	b.n	341827fe <RCC_PLL_IsNewConfig+0xc6>
      }
      else
      {
        pllState = RCC_PLL_OFF;
341827fa:	2301      	movs	r3, #1
341827fc:	61bb      	str	r3, [r7, #24]
      }
    }

    /* Compare with new mode */
    if (pllState != pPLLInit->PLLState)
341827fe:	683b      	ldr	r3, [r7, #0]
34182800:	681b      	ldr	r3, [r3, #0]
34182802:	69ba      	ldr	r2, [r7, #24]
34182804:	429a      	cmp	r2, r3
34182806:	d001      	beq.n	3418280c <RCC_PLL_IsNewConfig+0xd4>
    {
      ret = 1U; /* New PLL configuration */
34182808:	2301      	movs	r3, #1
3418280a:	61fb      	str	r3, [r7, #28]
    }
  }

  return ret;
3418280c:	69fb      	ldr	r3, [r7, #28]
}
3418280e:	4618      	mov	r0, r3
34182810:	3724      	adds	r7, #36	@ 0x24
34182812:	46bd      	mov	sp, r7
34182814:	f85d 7b04 	ldr.w	r7, [sp], #4
34182818:	4770      	bx	lr
3418281a:	bf00      	nop
3418281c:	56028080 	.word	0x56028080
34182820:	56028084 	.word	0x56028084
34182824:	56028088 	.word	0x56028088
34182828:	56028000 	.word	0x56028000

3418282c <RCC_PLL_Source_IsReady>:
  * @brief  Check whether the PLL source is ready
  * @param  PLLSource PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_Source_IsReady(uint32_t PLLSource)
{
3418282c:	b580      	push	{r7, lr}
3418282e:	b084      	sub	sp, #16
34182830:	af00      	add	r7, sp, #0
34182832:	6078      	str	r0, [r7, #4]
  uint32_t ret = 1U;
34182834:	2301      	movs	r3, #1
34182836:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  switch (PLLSource)
34182838:	687b      	ldr	r3, [r7, #4]
3418283a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418283e:	d01b      	beq.n	34182878 <RCC_PLL_Source_IsReady+0x4c>
34182840:	687b      	ldr	r3, [r7, #4]
34182842:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34182846:	d81f      	bhi.n	34182888 <RCC_PLL_Source_IsReady+0x5c>
34182848:	687b      	ldr	r3, [r7, #4]
3418284a:	2b00      	cmp	r3, #0
3418284c:	d004      	beq.n	34182858 <RCC_PLL_Source_IsReady+0x2c>
3418284e:	687b      	ldr	r3, [r7, #4]
34182850:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34182854:	d008      	beq.n	34182868 <RCC_PLL_Source_IsReady+0x3c>
        ret = 0U;
      }
      break;
    case RCC_PLLSOURCE_PIN:
    default:
      break;
34182856:	e017      	b.n	34182888 <RCC_PLL_Source_IsReady+0x5c>
      if (LL_RCC_HSI_IsReady() == 0U)
34182858:	f7fe fd00 	bl	3418125c <LL_RCC_HSI_IsReady>
3418285c:	4603      	mov	r3, r0
3418285e:	2b00      	cmp	r3, #0
34182860:	d114      	bne.n	3418288c <RCC_PLL_Source_IsReady+0x60>
        ret = 0U;
34182862:	2300      	movs	r3, #0
34182864:	60fb      	str	r3, [r7, #12]
      break;
34182866:	e011      	b.n	3418288c <RCC_PLL_Source_IsReady+0x60>
      if (LL_RCC_MSI_IsReady() == 0U)
34182868:	f7fe fd60 	bl	3418132c <LL_RCC_MSI_IsReady>
3418286c:	4603      	mov	r3, r0
3418286e:	2b00      	cmp	r3, #0
34182870:	d10e      	bne.n	34182890 <RCC_PLL_Source_IsReady+0x64>
        ret = 0U;
34182872:	2300      	movs	r3, #0
34182874:	60fb      	str	r3, [r7, #12]
      break;
34182876:	e00b      	b.n	34182890 <RCC_PLL_Source_IsReady+0x64>
      if (LL_RCC_HSE_IsReady() == 0U)
34182878:	f7fe fcc0 	bl	341811fc <LL_RCC_HSE_IsReady>
3418287c:	4603      	mov	r3, r0
3418287e:	2b00      	cmp	r3, #0
34182880:	d108      	bne.n	34182894 <RCC_PLL_Source_IsReady+0x68>
        ret = 0U;
34182882:	2300      	movs	r3, #0
34182884:	60fb      	str	r3, [r7, #12]
      break;
34182886:	e005      	b.n	34182894 <RCC_PLL_Source_IsReady+0x68>
      break;
34182888:	bf00      	nop
3418288a:	e004      	b.n	34182896 <RCC_PLL_Source_IsReady+0x6a>
      break;
3418288c:	bf00      	nop
3418288e:	e002      	b.n	34182896 <RCC_PLL_Source_IsReady+0x6a>
      break;
34182890:	bf00      	nop
34182892:	e000      	b.n	34182896 <RCC_PLL_Source_IsReady+0x6a>
      break;
34182894:	bf00      	nop
  }

  return ret;
34182896:	68fb      	ldr	r3, [r7, #12]
}
34182898:	4618      	mov	r0, r3
3418289a:	3710      	adds	r7, #16
3418289c:	46bd      	mov	sp, r7
3418289e:	bd80      	pop	{r7, pc}

341828a0 <RCC_IC_CheckPLLSources>:
  * @param  PLLSource1 First PLL source
  * @param  PLLSource2 Second PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_IC_CheckPLLSources(uint32_t PLLSource1, uint32_t PLLSource2)
{
341828a0:	b580      	push	{r7, lr}
341828a2:	b084      	sub	sp, #16
341828a4:	af00      	add	r7, sp, #0
341828a6:	6078      	str	r0, [r7, #4]
341828a8:	6039      	str	r1, [r7, #0]
  uint32_t ret = 1U;
341828aa:	2301      	movs	r3, #1
341828ac:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  /* Check PLLSource1 clock source */
  switch (PLLSource1)
341828ae:	687b      	ldr	r3, [r7, #4]
341828b0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341828b4:	d03a      	beq.n	3418292c <RCC_IC_CheckPLLSources+0x8c>
341828b6:	687b      	ldr	r3, [r7, #4]
341828b8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341828bc:	d843      	bhi.n	34182946 <RCC_IC_CheckPLLSources+0xa6>
341828be:	687b      	ldr	r3, [r7, #4]
341828c0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341828c4:	d025      	beq.n	34182912 <RCC_IC_CheckPLLSources+0x72>
341828c6:	687b      	ldr	r3, [r7, #4]
341828c8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341828cc:	d83b      	bhi.n	34182946 <RCC_IC_CheckPLLSources+0xa6>
341828ce:	687b      	ldr	r3, [r7, #4]
341828d0:	2b00      	cmp	r3, #0
341828d2:	d004      	beq.n	341828de <RCC_IC_CheckPLLSources+0x3e>
341828d4:	687b      	ldr	r3, [r7, #4]
341828d6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341828da:	d00d      	beq.n	341828f8 <RCC_IC_CheckPLLSources+0x58>
341828dc:	e033      	b.n	34182946 <RCC_IC_CheckPLLSources+0xa6>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
341828de:	f7fe fdd7 	bl	34181490 <LL_RCC_PLL1_IsReady>
341828e2:	4603      	mov	r3, r0
341828e4:	2b00      	cmp	r3, #0
341828e6:	d131      	bne.n	3418294c <RCC_IC_CheckPLLSources+0xac>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
341828e8:	f7fe fde6 	bl	341814b8 <LL_RCC_PLL1_IsEnabledBypass>
341828ec:	4603      	mov	r3, r0
341828ee:	2b00      	cmp	r3, #0
341828f0:	d12c      	bne.n	3418294c <RCC_IC_CheckPLLSources+0xac>
        {
          ret = 0U;
341828f2:	2300      	movs	r3, #0
341828f4:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
341828f6:	e029      	b.n	3418294c <RCC_IC_CheckPLLSources+0xac>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
341828f8:	f7fe fe00 	bl	341814fc <LL_RCC_PLL2_IsReady>
341828fc:	4603      	mov	r3, r0
341828fe:	2b00      	cmp	r3, #0
34182900:	d126      	bne.n	34182950 <RCC_IC_CheckPLLSources+0xb0>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
34182902:	f7fe fe0f 	bl	34181524 <LL_RCC_PLL2_IsEnabledBypass>
34182906:	4603      	mov	r3, r0
34182908:	2b00      	cmp	r3, #0
3418290a:	d121      	bne.n	34182950 <RCC_IC_CheckPLLSources+0xb0>
        {
          ret = 0U;
3418290c:	2300      	movs	r3, #0
3418290e:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
34182910:	e01e      	b.n	34182950 <RCC_IC_CheckPLLSources+0xb0>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
34182912:	f7fe fe29 	bl	34181568 <LL_RCC_PLL3_IsReady>
34182916:	4603      	mov	r3, r0
34182918:	2b00      	cmp	r3, #0
3418291a:	d11b      	bne.n	34182954 <RCC_IC_CheckPLLSources+0xb4>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
3418291c:	f7fe fe38 	bl	34181590 <LL_RCC_PLL3_IsEnabledBypass>
34182920:	4603      	mov	r3, r0
34182922:	2b00      	cmp	r3, #0
34182924:	d116      	bne.n	34182954 <RCC_IC_CheckPLLSources+0xb4>
        {
          ret = 0U;
34182926:	2300      	movs	r3, #0
34182928:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418292a:	e013      	b.n	34182954 <RCC_IC_CheckPLLSources+0xb4>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
3418292c:	f7fe fe52 	bl	341815d4 <LL_RCC_PLL4_IsReady>
34182930:	4603      	mov	r3, r0
34182932:	2b00      	cmp	r3, #0
34182934:	d110      	bne.n	34182958 <RCC_IC_CheckPLLSources+0xb8>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
34182936:	f7fe fe61 	bl	341815fc <LL_RCC_PLL4_IsEnabledBypass>
3418293a:	4603      	mov	r3, r0
3418293c:	2b00      	cmp	r3, #0
3418293e:	d10b      	bne.n	34182958 <RCC_IC_CheckPLLSources+0xb8>
        {
          ret = 0U;
34182940:	2300      	movs	r3, #0
34182942:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
34182944:	e008      	b.n	34182958 <RCC_IC_CheckPLLSources+0xb8>
    default:
      /* Unexpected */
      ret = 0U;
34182946:	2300      	movs	r3, #0
34182948:	60fb      	str	r3, [r7, #12]
      break;
3418294a:	e006      	b.n	3418295a <RCC_IC_CheckPLLSources+0xba>
      break;
3418294c:	bf00      	nop
3418294e:	e004      	b.n	3418295a <RCC_IC_CheckPLLSources+0xba>
      break;
34182950:	bf00      	nop
34182952:	e002      	b.n	3418295a <RCC_IC_CheckPLLSources+0xba>
      break;
34182954:	bf00      	nop
34182956:	e000      	b.n	3418295a <RCC_IC_CheckPLLSources+0xba>
      break;
34182958:	bf00      	nop
  }

  /* Check PLLSource2 clock source */
  switch (PLLSource2)
3418295a:	683b      	ldr	r3, [r7, #0]
3418295c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34182960:	d03a      	beq.n	341829d8 <RCC_IC_CheckPLLSources+0x138>
34182962:	683b      	ldr	r3, [r7, #0]
34182964:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34182968:	d843      	bhi.n	341829f2 <RCC_IC_CheckPLLSources+0x152>
3418296a:	683b      	ldr	r3, [r7, #0]
3418296c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34182970:	d025      	beq.n	341829be <RCC_IC_CheckPLLSources+0x11e>
34182972:	683b      	ldr	r3, [r7, #0]
34182974:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34182978:	d83b      	bhi.n	341829f2 <RCC_IC_CheckPLLSources+0x152>
3418297a:	683b      	ldr	r3, [r7, #0]
3418297c:	2b00      	cmp	r3, #0
3418297e:	d004      	beq.n	3418298a <RCC_IC_CheckPLLSources+0xea>
34182980:	683b      	ldr	r3, [r7, #0]
34182982:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34182986:	d00d      	beq.n	341829a4 <RCC_IC_CheckPLLSources+0x104>
34182988:	e033      	b.n	341829f2 <RCC_IC_CheckPLLSources+0x152>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
3418298a:	f7fe fd81 	bl	34181490 <LL_RCC_PLL1_IsReady>
3418298e:	4603      	mov	r3, r0
34182990:	2b00      	cmp	r3, #0
34182992:	d131      	bne.n	341829f8 <RCC_IC_CheckPLLSources+0x158>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
34182994:	f7fe fd90 	bl	341814b8 <LL_RCC_PLL1_IsEnabledBypass>
34182998:	4603      	mov	r3, r0
3418299a:	2b00      	cmp	r3, #0
3418299c:	d12c      	bne.n	341829f8 <RCC_IC_CheckPLLSources+0x158>
        {
          ret = 0U;
3418299e:	2300      	movs	r3, #0
341829a0:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
341829a2:	e029      	b.n	341829f8 <RCC_IC_CheckPLLSources+0x158>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
341829a4:	f7fe fdaa 	bl	341814fc <LL_RCC_PLL2_IsReady>
341829a8:	4603      	mov	r3, r0
341829aa:	2b00      	cmp	r3, #0
341829ac:	d126      	bne.n	341829fc <RCC_IC_CheckPLLSources+0x15c>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
341829ae:	f7fe fdb9 	bl	34181524 <LL_RCC_PLL2_IsEnabledBypass>
341829b2:	4603      	mov	r3, r0
341829b4:	2b00      	cmp	r3, #0
341829b6:	d121      	bne.n	341829fc <RCC_IC_CheckPLLSources+0x15c>
        {
          ret = 0U;
341829b8:	2300      	movs	r3, #0
341829ba:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
341829bc:	e01e      	b.n	341829fc <RCC_IC_CheckPLLSources+0x15c>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
341829be:	f7fe fdd3 	bl	34181568 <LL_RCC_PLL3_IsReady>
341829c2:	4603      	mov	r3, r0
341829c4:	2b00      	cmp	r3, #0
341829c6:	d11b      	bne.n	34182a00 <RCC_IC_CheckPLLSources+0x160>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
341829c8:	f7fe fde2 	bl	34181590 <LL_RCC_PLL3_IsEnabledBypass>
341829cc:	4603      	mov	r3, r0
341829ce:	2b00      	cmp	r3, #0
341829d0:	d116      	bne.n	34182a00 <RCC_IC_CheckPLLSources+0x160>
        {
          ret = 0U;
341829d2:	2300      	movs	r3, #0
341829d4:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
341829d6:	e013      	b.n	34182a00 <RCC_IC_CheckPLLSources+0x160>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
341829d8:	f7fe fdfc 	bl	341815d4 <LL_RCC_PLL4_IsReady>
341829dc:	4603      	mov	r3, r0
341829de:	2b00      	cmp	r3, #0
341829e0:	d110      	bne.n	34182a04 <RCC_IC_CheckPLLSources+0x164>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
341829e2:	f7fe fe0b 	bl	341815fc <LL_RCC_PLL4_IsEnabledBypass>
341829e6:	4603      	mov	r3, r0
341829e8:	2b00      	cmp	r3, #0
341829ea:	d10b      	bne.n	34182a04 <RCC_IC_CheckPLLSources+0x164>
        {
          ret = 0U;
341829ec:	2300      	movs	r3, #0
341829ee:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
341829f0:	e008      	b.n	34182a04 <RCC_IC_CheckPLLSources+0x164>
    default:
      /* Unexpected */
      ret = 0U;
341829f2:	2300      	movs	r3, #0
341829f4:	60fb      	str	r3, [r7, #12]
      break;
341829f6:	e006      	b.n	34182a06 <RCC_IC_CheckPLLSources+0x166>
      break;
341829f8:	bf00      	nop
341829fa:	e004      	b.n	34182a06 <RCC_IC_CheckPLLSources+0x166>
      break;
341829fc:	bf00      	nop
341829fe:	e002      	b.n	34182a06 <RCC_IC_CheckPLLSources+0x166>
      break;
34182a00:	bf00      	nop
34182a02:	e000      	b.n	34182a06 <RCC_IC_CheckPLLSources+0x166>
      break;
34182a04:	bf00      	nop
  }

  return ret;
34182a06:	68fb      	ldr	r3, [r7, #12]
}
34182a08:	4618      	mov	r0, r3
34182a0a:	3710      	adds	r7, #16
34182a0c:	46bd      	mov	sp, r7
34182a0e:	bd80      	pop	{r7, pc}

34182a10 <LL_RCC_HSE_IsReady>:
{
34182a10:	b480      	push	{r7}
34182a12:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34182a14:	4b06      	ldr	r3, [pc, #24]	@ (34182a30 <LL_RCC_HSE_IsReady+0x20>)
34182a16:	685b      	ldr	r3, [r3, #4]
34182a18:	f003 0310 	and.w	r3, r3, #16
34182a1c:	2b00      	cmp	r3, #0
34182a1e:	d001      	beq.n	34182a24 <LL_RCC_HSE_IsReady+0x14>
34182a20:	2301      	movs	r3, #1
34182a22:	e000      	b.n	34182a26 <LL_RCC_HSE_IsReady+0x16>
34182a24:	2300      	movs	r3, #0
}
34182a26:	4618      	mov	r0, r3
34182a28:	46bd      	mov	sp, r7
34182a2a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182a2e:	4770      	bx	lr
34182a30:	56028000 	.word	0x56028000

34182a34 <LL_RCC_HSI_IsReady>:
{
34182a34:	b480      	push	{r7}
34182a36:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
34182a38:	4b06      	ldr	r3, [pc, #24]	@ (34182a54 <LL_RCC_HSI_IsReady+0x20>)
34182a3a:	685b      	ldr	r3, [r3, #4]
34182a3c:	f003 0308 	and.w	r3, r3, #8
34182a40:	2b00      	cmp	r3, #0
34182a42:	d001      	beq.n	34182a48 <LL_RCC_HSI_IsReady+0x14>
34182a44:	2301      	movs	r3, #1
34182a46:	e000      	b.n	34182a4a <LL_RCC_HSI_IsReady+0x16>
34182a48:	2300      	movs	r3, #0
}
34182a4a:	4618      	mov	r0, r3
34182a4c:	46bd      	mov	sp, r7
34182a4e:	f85d 7b04 	ldr.w	r7, [sp], #4
34182a52:	4770      	bx	lr
34182a54:	56028000 	.word	0x56028000

34182a58 <LL_RCC_HSI_GetDivider>:
{
34182a58:	b480      	push	{r7}
34182a5a:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34182a5c:	4b04      	ldr	r3, [pc, #16]	@ (34182a70 <LL_RCC_HSI_GetDivider+0x18>)
34182a5e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34182a60:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
34182a64:	4618      	mov	r0, r3
34182a66:	46bd      	mov	sp, r7
34182a68:	f85d 7b04 	ldr.w	r7, [sp], #4
34182a6c:	4770      	bx	lr
34182a6e:	bf00      	nop
34182a70:	56028000 	.word	0x56028000

34182a74 <LL_RCC_MSI_IsReady>:
{
34182a74:	b480      	push	{r7}
34182a76:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
34182a78:	4b06      	ldr	r3, [pc, #24]	@ (34182a94 <LL_RCC_MSI_IsReady+0x20>)
34182a7a:	685b      	ldr	r3, [r3, #4]
34182a7c:	f003 0304 	and.w	r3, r3, #4
34182a80:	2b00      	cmp	r3, #0
34182a82:	d001      	beq.n	34182a88 <LL_RCC_MSI_IsReady+0x14>
34182a84:	2301      	movs	r3, #1
34182a86:	e000      	b.n	34182a8a <LL_RCC_MSI_IsReady+0x16>
34182a88:	2300      	movs	r3, #0
}
34182a8a:	4618      	mov	r0, r3
34182a8c:	46bd      	mov	sp, r7
34182a8e:	f85d 7b04 	ldr.w	r7, [sp], #4
34182a92:	4770      	bx	lr
34182a94:	56028000 	.word	0x56028000

34182a98 <LL_RCC_MSI_GetFrequency>:
{
34182a98:	b480      	push	{r7}
34182a9a:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
34182a9c:	4b04      	ldr	r3, [pc, #16]	@ (34182ab0 <LL_RCC_MSI_GetFrequency+0x18>)
34182a9e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34182aa0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
34182aa4:	4618      	mov	r0, r3
34182aa6:	46bd      	mov	sp, r7
34182aa8:	f85d 7b04 	ldr.w	r7, [sp], #4
34182aac:	4770      	bx	lr
34182aae:	bf00      	nop
34182ab0:	56028000 	.word	0x56028000

34182ab4 <LL_RCC_PLL1_GetSource>:
{
34182ab4:	b480      	push	{r7}
34182ab6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
34182ab8:	4b04      	ldr	r3, [pc, #16]	@ (34182acc <LL_RCC_PLL1_GetSource+0x18>)
34182aba:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34182abe:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34182ac2:	4618      	mov	r0, r3
34182ac4:	46bd      	mov	sp, r7
34182ac6:	f85d 7b04 	ldr.w	r7, [sp], #4
34182aca:	4770      	bx	lr
34182acc:	56028000 	.word	0x56028000

34182ad0 <LL_RCC_PLL1_IsReady>:
{
34182ad0:	b480      	push	{r7}
34182ad2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
34182ad4:	4b07      	ldr	r3, [pc, #28]	@ (34182af4 <LL_RCC_PLL1_IsReady+0x24>)
34182ad6:	685b      	ldr	r3, [r3, #4]
34182ad8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34182adc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34182ae0:	d101      	bne.n	34182ae6 <LL_RCC_PLL1_IsReady+0x16>
34182ae2:	2301      	movs	r3, #1
34182ae4:	e000      	b.n	34182ae8 <LL_RCC_PLL1_IsReady+0x18>
34182ae6:	2300      	movs	r3, #0
}
34182ae8:	4618      	mov	r0, r3
34182aea:	46bd      	mov	sp, r7
34182aec:	f85d 7b04 	ldr.w	r7, [sp], #4
34182af0:	4770      	bx	lr
34182af2:	bf00      	nop
34182af4:	56028000 	.word	0x56028000

34182af8 <LL_RCC_PLL1_IsEnabledBypass>:
{
34182af8:	b480      	push	{r7}
34182afa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
34182afc:	4b07      	ldr	r3, [pc, #28]	@ (34182b1c <LL_RCC_PLL1_IsEnabledBypass+0x24>)
34182afe:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34182b02:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34182b06:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34182b0a:	d101      	bne.n	34182b10 <LL_RCC_PLL1_IsEnabledBypass+0x18>
34182b0c:	2301      	movs	r3, #1
34182b0e:	e000      	b.n	34182b12 <LL_RCC_PLL1_IsEnabledBypass+0x1a>
34182b10:	2300      	movs	r3, #0
}
34182b12:	4618      	mov	r0, r3
34182b14:	46bd      	mov	sp, r7
34182b16:	f85d 7b04 	ldr.w	r7, [sp], #4
34182b1a:	4770      	bx	lr
34182b1c:	56028000 	.word	0x56028000

34182b20 <LL_RCC_PLL1_GetN>:
{
34182b20:	b480      	push	{r7}
34182b22:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
34182b24:	4b05      	ldr	r3, [pc, #20]	@ (34182b3c <LL_RCC_PLL1_GetN+0x1c>)
34182b26:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34182b2a:	0a1b      	lsrs	r3, r3, #8
34182b2c:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34182b30:	4618      	mov	r0, r3
34182b32:	46bd      	mov	sp, r7
34182b34:	f85d 7b04 	ldr.w	r7, [sp], #4
34182b38:	4770      	bx	lr
34182b3a:	bf00      	nop
34182b3c:	56028000 	.word	0x56028000

34182b40 <LL_RCC_PLL1_GetM>:
{
34182b40:	b480      	push	{r7}
34182b42:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
34182b44:	4b05      	ldr	r3, [pc, #20]	@ (34182b5c <LL_RCC_PLL1_GetM+0x1c>)
34182b46:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34182b4a:	0d1b      	lsrs	r3, r3, #20
34182b4c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34182b50:	4618      	mov	r0, r3
34182b52:	46bd      	mov	sp, r7
34182b54:	f85d 7b04 	ldr.w	r7, [sp], #4
34182b58:	4770      	bx	lr
34182b5a:	bf00      	nop
34182b5c:	56028000 	.word	0x56028000

34182b60 <LL_RCC_PLL1_GetP1>:
{
34182b60:	b480      	push	{r7}
34182b62:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
34182b64:	4b05      	ldr	r3, [pc, #20]	@ (34182b7c <LL_RCC_PLL1_GetP1+0x1c>)
34182b66:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34182b6a:	0edb      	lsrs	r3, r3, #27
34182b6c:	f003 0307 	and.w	r3, r3, #7
}
34182b70:	4618      	mov	r0, r3
34182b72:	46bd      	mov	sp, r7
34182b74:	f85d 7b04 	ldr.w	r7, [sp], #4
34182b78:	4770      	bx	lr
34182b7a:	bf00      	nop
34182b7c:	56028000 	.word	0x56028000

34182b80 <LL_RCC_PLL1_GetP2>:
{
34182b80:	b480      	push	{r7}
34182b82:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
34182b84:	4b05      	ldr	r3, [pc, #20]	@ (34182b9c <LL_RCC_PLL1_GetP2+0x1c>)
34182b86:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34182b8a:	0e1b      	lsrs	r3, r3, #24
34182b8c:	f003 0307 	and.w	r3, r3, #7
}
34182b90:	4618      	mov	r0, r3
34182b92:	46bd      	mov	sp, r7
34182b94:	f85d 7b04 	ldr.w	r7, [sp], #4
34182b98:	4770      	bx	lr
34182b9a:	bf00      	nop
34182b9c:	56028000 	.word	0x56028000

34182ba0 <LL_RCC_PLL1P_IsEnabled>:
{
34182ba0:	b480      	push	{r7}
34182ba2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
34182ba4:	4b07      	ldr	r3, [pc, #28]	@ (34182bc4 <LL_RCC_PLL1P_IsEnabled+0x24>)
34182ba6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34182baa:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34182bae:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34182bb2:	d101      	bne.n	34182bb8 <LL_RCC_PLL1P_IsEnabled+0x18>
34182bb4:	2301      	movs	r3, #1
34182bb6:	e000      	b.n	34182bba <LL_RCC_PLL1P_IsEnabled+0x1a>
34182bb8:	2300      	movs	r3, #0
}
34182bba:	4618      	mov	r0, r3
34182bbc:	46bd      	mov	sp, r7
34182bbe:	f85d 7b04 	ldr.w	r7, [sp], #4
34182bc2:	4770      	bx	lr
34182bc4:	56028000 	.word	0x56028000

34182bc8 <LL_RCC_PLL1_GetFRACN>:
{
34182bc8:	b480      	push	{r7}
34182bca:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
34182bcc:	4b04      	ldr	r3, [pc, #16]	@ (34182be0 <LL_RCC_PLL1_GetFRACN+0x18>)
34182bce:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34182bd2:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
34182bd6:	4618      	mov	r0, r3
34182bd8:	46bd      	mov	sp, r7
34182bda:	f85d 7b04 	ldr.w	r7, [sp], #4
34182bde:	4770      	bx	lr
34182be0:	56028000 	.word	0x56028000

34182be4 <LL_RCC_PLL2_GetSource>:
{
34182be4:	b480      	push	{r7}
34182be6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
34182be8:	4b04      	ldr	r3, [pc, #16]	@ (34182bfc <LL_RCC_PLL2_GetSource+0x18>)
34182bea:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34182bee:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34182bf2:	4618      	mov	r0, r3
34182bf4:	46bd      	mov	sp, r7
34182bf6:	f85d 7b04 	ldr.w	r7, [sp], #4
34182bfa:	4770      	bx	lr
34182bfc:	56028000 	.word	0x56028000

34182c00 <LL_RCC_PLL2_IsReady>:
{
34182c00:	b480      	push	{r7}
34182c02:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34182c04:	4b07      	ldr	r3, [pc, #28]	@ (34182c24 <LL_RCC_PLL2_IsReady+0x24>)
34182c06:	685b      	ldr	r3, [r3, #4]
34182c08:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34182c0c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34182c10:	d101      	bne.n	34182c16 <LL_RCC_PLL2_IsReady+0x16>
34182c12:	2301      	movs	r3, #1
34182c14:	e000      	b.n	34182c18 <LL_RCC_PLL2_IsReady+0x18>
34182c16:	2300      	movs	r3, #0
}
34182c18:	4618      	mov	r0, r3
34182c1a:	46bd      	mov	sp, r7
34182c1c:	f85d 7b04 	ldr.w	r7, [sp], #4
34182c20:	4770      	bx	lr
34182c22:	bf00      	nop
34182c24:	56028000 	.word	0x56028000

34182c28 <LL_RCC_PLL2_IsEnabledBypass>:
{
34182c28:	b480      	push	{r7}
34182c2a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34182c2c:	4b07      	ldr	r3, [pc, #28]	@ (34182c4c <LL_RCC_PLL2_IsEnabledBypass+0x24>)
34182c2e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34182c32:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34182c36:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34182c3a:	d101      	bne.n	34182c40 <LL_RCC_PLL2_IsEnabledBypass+0x18>
34182c3c:	2301      	movs	r3, #1
34182c3e:	e000      	b.n	34182c42 <LL_RCC_PLL2_IsEnabledBypass+0x1a>
34182c40:	2300      	movs	r3, #0
}
34182c42:	4618      	mov	r0, r3
34182c44:	46bd      	mov	sp, r7
34182c46:	f85d 7b04 	ldr.w	r7, [sp], #4
34182c4a:	4770      	bx	lr
34182c4c:	56028000 	.word	0x56028000

34182c50 <LL_RCC_PLL2_GetN>:
{
34182c50:	b480      	push	{r7}
34182c52:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
34182c54:	4b05      	ldr	r3, [pc, #20]	@ (34182c6c <LL_RCC_PLL2_GetN+0x1c>)
34182c56:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34182c5a:	0a1b      	lsrs	r3, r3, #8
34182c5c:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34182c60:	4618      	mov	r0, r3
34182c62:	46bd      	mov	sp, r7
34182c64:	f85d 7b04 	ldr.w	r7, [sp], #4
34182c68:	4770      	bx	lr
34182c6a:	bf00      	nop
34182c6c:	56028000 	.word	0x56028000

34182c70 <LL_RCC_PLL2_GetM>:
{
34182c70:	b480      	push	{r7}
34182c72:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
34182c74:	4b05      	ldr	r3, [pc, #20]	@ (34182c8c <LL_RCC_PLL2_GetM+0x1c>)
34182c76:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34182c7a:	0d1b      	lsrs	r3, r3, #20
34182c7c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34182c80:	4618      	mov	r0, r3
34182c82:	46bd      	mov	sp, r7
34182c84:	f85d 7b04 	ldr.w	r7, [sp], #4
34182c88:	4770      	bx	lr
34182c8a:	bf00      	nop
34182c8c:	56028000 	.word	0x56028000

34182c90 <LL_RCC_PLL2_GetP1>:
{
34182c90:	b480      	push	{r7}
34182c92:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
34182c94:	4b05      	ldr	r3, [pc, #20]	@ (34182cac <LL_RCC_PLL2_GetP1+0x1c>)
34182c96:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34182c9a:	0edb      	lsrs	r3, r3, #27
34182c9c:	f003 0307 	and.w	r3, r3, #7
}
34182ca0:	4618      	mov	r0, r3
34182ca2:	46bd      	mov	sp, r7
34182ca4:	f85d 7b04 	ldr.w	r7, [sp], #4
34182ca8:	4770      	bx	lr
34182caa:	bf00      	nop
34182cac:	56028000 	.word	0x56028000

34182cb0 <LL_RCC_PLL2_GetP2>:
{
34182cb0:	b480      	push	{r7}
34182cb2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
34182cb4:	4b05      	ldr	r3, [pc, #20]	@ (34182ccc <LL_RCC_PLL2_GetP2+0x1c>)
34182cb6:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34182cba:	0e1b      	lsrs	r3, r3, #24
34182cbc:	f003 0307 	and.w	r3, r3, #7
}
34182cc0:	4618      	mov	r0, r3
34182cc2:	46bd      	mov	sp, r7
34182cc4:	f85d 7b04 	ldr.w	r7, [sp], #4
34182cc8:	4770      	bx	lr
34182cca:	bf00      	nop
34182ccc:	56028000 	.word	0x56028000

34182cd0 <LL_RCC_PLL2P_IsEnabled>:
{
34182cd0:	b480      	push	{r7}
34182cd2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
34182cd4:	4b07      	ldr	r3, [pc, #28]	@ (34182cf4 <LL_RCC_PLL2P_IsEnabled+0x24>)
34182cd6:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34182cda:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34182cde:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34182ce2:	d101      	bne.n	34182ce8 <LL_RCC_PLL2P_IsEnabled+0x18>
34182ce4:	2301      	movs	r3, #1
34182ce6:	e000      	b.n	34182cea <LL_RCC_PLL2P_IsEnabled+0x1a>
34182ce8:	2300      	movs	r3, #0
}
34182cea:	4618      	mov	r0, r3
34182cec:	46bd      	mov	sp, r7
34182cee:	f85d 7b04 	ldr.w	r7, [sp], #4
34182cf2:	4770      	bx	lr
34182cf4:	56028000 	.word	0x56028000

34182cf8 <LL_RCC_PLL2_GetFRACN>:
{
34182cf8:	b480      	push	{r7}
34182cfa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
34182cfc:	4b04      	ldr	r3, [pc, #16]	@ (34182d10 <LL_RCC_PLL2_GetFRACN+0x18>)
34182cfe:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34182d02:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
34182d06:	4618      	mov	r0, r3
34182d08:	46bd      	mov	sp, r7
34182d0a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182d0e:	4770      	bx	lr
34182d10:	56028000 	.word	0x56028000

34182d14 <LL_RCC_PLL3_GetSource>:
{
34182d14:	b480      	push	{r7}
34182d16:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
34182d18:	4b04      	ldr	r3, [pc, #16]	@ (34182d2c <LL_RCC_PLL3_GetSource+0x18>)
34182d1a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34182d1e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34182d22:	4618      	mov	r0, r3
34182d24:	46bd      	mov	sp, r7
34182d26:	f85d 7b04 	ldr.w	r7, [sp], #4
34182d2a:	4770      	bx	lr
34182d2c:	56028000 	.word	0x56028000

34182d30 <LL_RCC_PLL3_IsReady>:
{
34182d30:	b480      	push	{r7}
34182d32:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
34182d34:	4b07      	ldr	r3, [pc, #28]	@ (34182d54 <LL_RCC_PLL3_IsReady+0x24>)
34182d36:	685b      	ldr	r3, [r3, #4]
34182d38:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34182d3c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34182d40:	d101      	bne.n	34182d46 <LL_RCC_PLL3_IsReady+0x16>
34182d42:	2301      	movs	r3, #1
34182d44:	e000      	b.n	34182d48 <LL_RCC_PLL3_IsReady+0x18>
34182d46:	2300      	movs	r3, #0
}
34182d48:	4618      	mov	r0, r3
34182d4a:	46bd      	mov	sp, r7
34182d4c:	f85d 7b04 	ldr.w	r7, [sp], #4
34182d50:	4770      	bx	lr
34182d52:	bf00      	nop
34182d54:	56028000 	.word	0x56028000

34182d58 <LL_RCC_PLL3_IsEnabledBypass>:
{
34182d58:	b480      	push	{r7}
34182d5a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
34182d5c:	4b07      	ldr	r3, [pc, #28]	@ (34182d7c <LL_RCC_PLL3_IsEnabledBypass+0x24>)
34182d5e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34182d62:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34182d66:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34182d6a:	d101      	bne.n	34182d70 <LL_RCC_PLL3_IsEnabledBypass+0x18>
34182d6c:	2301      	movs	r3, #1
34182d6e:	e000      	b.n	34182d72 <LL_RCC_PLL3_IsEnabledBypass+0x1a>
34182d70:	2300      	movs	r3, #0
}
34182d72:	4618      	mov	r0, r3
34182d74:	46bd      	mov	sp, r7
34182d76:	f85d 7b04 	ldr.w	r7, [sp], #4
34182d7a:	4770      	bx	lr
34182d7c:	56028000 	.word	0x56028000

34182d80 <LL_RCC_PLL3_GetN>:
{
34182d80:	b480      	push	{r7}
34182d82:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
34182d84:	4b05      	ldr	r3, [pc, #20]	@ (34182d9c <LL_RCC_PLL3_GetN+0x1c>)
34182d86:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34182d8a:	0a1b      	lsrs	r3, r3, #8
34182d8c:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34182d90:	4618      	mov	r0, r3
34182d92:	46bd      	mov	sp, r7
34182d94:	f85d 7b04 	ldr.w	r7, [sp], #4
34182d98:	4770      	bx	lr
34182d9a:	bf00      	nop
34182d9c:	56028000 	.word	0x56028000

34182da0 <LL_RCC_PLL3_GetM>:
{
34182da0:	b480      	push	{r7}
34182da2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
34182da4:	4b05      	ldr	r3, [pc, #20]	@ (34182dbc <LL_RCC_PLL3_GetM+0x1c>)
34182da6:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34182daa:	0d1b      	lsrs	r3, r3, #20
34182dac:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34182db0:	4618      	mov	r0, r3
34182db2:	46bd      	mov	sp, r7
34182db4:	f85d 7b04 	ldr.w	r7, [sp], #4
34182db8:	4770      	bx	lr
34182dba:	bf00      	nop
34182dbc:	56028000 	.word	0x56028000

34182dc0 <LL_RCC_PLL3_GetP1>:
{
34182dc0:	b480      	push	{r7}
34182dc2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
34182dc4:	4b05      	ldr	r3, [pc, #20]	@ (34182ddc <LL_RCC_PLL3_GetP1+0x1c>)
34182dc6:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34182dca:	0edb      	lsrs	r3, r3, #27
34182dcc:	f003 0307 	and.w	r3, r3, #7
}
34182dd0:	4618      	mov	r0, r3
34182dd2:	46bd      	mov	sp, r7
34182dd4:	f85d 7b04 	ldr.w	r7, [sp], #4
34182dd8:	4770      	bx	lr
34182dda:	bf00      	nop
34182ddc:	56028000 	.word	0x56028000

34182de0 <LL_RCC_PLL3_GetP2>:
{
34182de0:	b480      	push	{r7}
34182de2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
34182de4:	4b05      	ldr	r3, [pc, #20]	@ (34182dfc <LL_RCC_PLL3_GetP2+0x1c>)
34182de6:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34182dea:	0e1b      	lsrs	r3, r3, #24
34182dec:	f003 0307 	and.w	r3, r3, #7
}
34182df0:	4618      	mov	r0, r3
34182df2:	46bd      	mov	sp, r7
34182df4:	f85d 7b04 	ldr.w	r7, [sp], #4
34182df8:	4770      	bx	lr
34182dfa:	bf00      	nop
34182dfc:	56028000 	.word	0x56028000

34182e00 <LL_RCC_PLL3P_IsEnabled>:
{
34182e00:	b480      	push	{r7}
34182e02:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
34182e04:	4b07      	ldr	r3, [pc, #28]	@ (34182e24 <LL_RCC_PLL3P_IsEnabled+0x24>)
34182e06:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34182e0a:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34182e0e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34182e12:	d101      	bne.n	34182e18 <LL_RCC_PLL3P_IsEnabled+0x18>
34182e14:	2301      	movs	r3, #1
34182e16:	e000      	b.n	34182e1a <LL_RCC_PLL3P_IsEnabled+0x1a>
34182e18:	2300      	movs	r3, #0
}
34182e1a:	4618      	mov	r0, r3
34182e1c:	46bd      	mov	sp, r7
34182e1e:	f85d 7b04 	ldr.w	r7, [sp], #4
34182e22:	4770      	bx	lr
34182e24:	56028000 	.word	0x56028000

34182e28 <LL_RCC_PLL3_GetFRACN>:
{
34182e28:	b480      	push	{r7}
34182e2a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
34182e2c:	4b04      	ldr	r3, [pc, #16]	@ (34182e40 <LL_RCC_PLL3_GetFRACN+0x18>)
34182e2e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34182e32:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
34182e36:	4618      	mov	r0, r3
34182e38:	46bd      	mov	sp, r7
34182e3a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182e3e:	4770      	bx	lr
34182e40:	56028000 	.word	0x56028000

34182e44 <LL_RCC_PLL4_GetSource>:
{
34182e44:	b480      	push	{r7}
34182e46:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
34182e48:	4b04      	ldr	r3, [pc, #16]	@ (34182e5c <LL_RCC_PLL4_GetSource+0x18>)
34182e4a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34182e4e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34182e52:	4618      	mov	r0, r3
34182e54:	46bd      	mov	sp, r7
34182e56:	f85d 7b04 	ldr.w	r7, [sp], #4
34182e5a:	4770      	bx	lr
34182e5c:	56028000 	.word	0x56028000

34182e60 <LL_RCC_PLL4_IsReady>:
{
34182e60:	b480      	push	{r7}
34182e62:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34182e64:	4b07      	ldr	r3, [pc, #28]	@ (34182e84 <LL_RCC_PLL4_IsReady+0x24>)
34182e66:	685b      	ldr	r3, [r3, #4]
34182e68:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34182e6c:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34182e70:	d101      	bne.n	34182e76 <LL_RCC_PLL4_IsReady+0x16>
34182e72:	2301      	movs	r3, #1
34182e74:	e000      	b.n	34182e78 <LL_RCC_PLL4_IsReady+0x18>
34182e76:	2300      	movs	r3, #0
}
34182e78:	4618      	mov	r0, r3
34182e7a:	46bd      	mov	sp, r7
34182e7c:	f85d 7b04 	ldr.w	r7, [sp], #4
34182e80:	4770      	bx	lr
34182e82:	bf00      	nop
34182e84:	56028000 	.word	0x56028000

34182e88 <LL_RCC_PLL4_IsEnabledBypass>:
{
34182e88:	b480      	push	{r7}
34182e8a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34182e8c:	4b07      	ldr	r3, [pc, #28]	@ (34182eac <LL_RCC_PLL4_IsEnabledBypass+0x24>)
34182e8e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34182e92:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34182e96:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34182e9a:	d101      	bne.n	34182ea0 <LL_RCC_PLL4_IsEnabledBypass+0x18>
34182e9c:	2301      	movs	r3, #1
34182e9e:	e000      	b.n	34182ea2 <LL_RCC_PLL4_IsEnabledBypass+0x1a>
34182ea0:	2300      	movs	r3, #0
}
34182ea2:	4618      	mov	r0, r3
34182ea4:	46bd      	mov	sp, r7
34182ea6:	f85d 7b04 	ldr.w	r7, [sp], #4
34182eaa:	4770      	bx	lr
34182eac:	56028000 	.word	0x56028000

34182eb0 <LL_RCC_PLL4_GetN>:
{
34182eb0:	b480      	push	{r7}
34182eb2:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
34182eb4:	4b05      	ldr	r3, [pc, #20]	@ (34182ecc <LL_RCC_PLL4_GetN+0x1c>)
34182eb6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34182eba:	0a1b      	lsrs	r3, r3, #8
34182ebc:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34182ec0:	4618      	mov	r0, r3
34182ec2:	46bd      	mov	sp, r7
34182ec4:	f85d 7b04 	ldr.w	r7, [sp], #4
34182ec8:	4770      	bx	lr
34182eca:	bf00      	nop
34182ecc:	56028000 	.word	0x56028000

34182ed0 <LL_RCC_PLL4_GetM>:
{
34182ed0:	b480      	push	{r7}
34182ed2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
34182ed4:	4b05      	ldr	r3, [pc, #20]	@ (34182eec <LL_RCC_PLL4_GetM+0x1c>)
34182ed6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34182eda:	0d1b      	lsrs	r3, r3, #20
34182edc:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34182ee0:	4618      	mov	r0, r3
34182ee2:	46bd      	mov	sp, r7
34182ee4:	f85d 7b04 	ldr.w	r7, [sp], #4
34182ee8:	4770      	bx	lr
34182eea:	bf00      	nop
34182eec:	56028000 	.word	0x56028000

34182ef0 <LL_RCC_PLL4_GetP1>:
{
34182ef0:	b480      	push	{r7}
34182ef2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
34182ef4:	4b05      	ldr	r3, [pc, #20]	@ (34182f0c <LL_RCC_PLL4_GetP1+0x1c>)
34182ef6:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34182efa:	0edb      	lsrs	r3, r3, #27
34182efc:	f003 0307 	and.w	r3, r3, #7
}
34182f00:	4618      	mov	r0, r3
34182f02:	46bd      	mov	sp, r7
34182f04:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f08:	4770      	bx	lr
34182f0a:	bf00      	nop
34182f0c:	56028000 	.word	0x56028000

34182f10 <LL_RCC_PLL4_GetP2>:
{
34182f10:	b480      	push	{r7}
34182f12:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
34182f14:	4b05      	ldr	r3, [pc, #20]	@ (34182f2c <LL_RCC_PLL4_GetP2+0x1c>)
34182f16:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34182f1a:	0e1b      	lsrs	r3, r3, #24
34182f1c:	f003 0307 	and.w	r3, r3, #7
}
34182f20:	4618      	mov	r0, r3
34182f22:	46bd      	mov	sp, r7
34182f24:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f28:	4770      	bx	lr
34182f2a:	bf00      	nop
34182f2c:	56028000 	.word	0x56028000

34182f30 <LL_RCC_PLL4P_IsEnabled>:
{
34182f30:	b480      	push	{r7}
34182f32:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
34182f34:	4b07      	ldr	r3, [pc, #28]	@ (34182f54 <LL_RCC_PLL4P_IsEnabled+0x24>)
34182f36:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34182f3a:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34182f3e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34182f42:	d101      	bne.n	34182f48 <LL_RCC_PLL4P_IsEnabled+0x18>
34182f44:	2301      	movs	r3, #1
34182f46:	e000      	b.n	34182f4a <LL_RCC_PLL4P_IsEnabled+0x1a>
34182f48:	2300      	movs	r3, #0
}
34182f4a:	4618      	mov	r0, r3
34182f4c:	46bd      	mov	sp, r7
34182f4e:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f52:	4770      	bx	lr
34182f54:	56028000 	.word	0x56028000

34182f58 <LL_RCC_PLL4_GetFRACN>:
{
34182f58:	b480      	push	{r7}
34182f5a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
34182f5c:	4b04      	ldr	r3, [pc, #16]	@ (34182f70 <LL_RCC_PLL4_GetFRACN+0x18>)
34182f5e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34182f62:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
34182f66:	4618      	mov	r0, r3
34182f68:	46bd      	mov	sp, r7
34182f6a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f6e:	4770      	bx	lr
34182f70:	56028000 	.word	0x56028000

34182f74 <HAL_RCCEx_GetPLL1CLKFreq>:
  * @brief  Return PLL1 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL1 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL1CLKFreq(void)
{
34182f74:	b5f0      	push	{r4, r5, r6, r7, lr}
34182f76:	b087      	sub	sp, #28
34182f78:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34182f7a:	2300      	movs	r3, #0
34182f7c:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL1_IsReady() != 0U)
34182f7e:	f7ff fda7 	bl	34182ad0 <LL_RCC_PLL1_IsReady>
34182f82:	4603      	mov	r3, r0
34182f84:	2b00      	cmp	r3, #0
34182f86:	d02a      	beq.n	34182fde <HAL_RCCEx_GetPLL1CLKFreq+0x6a>
  {
    if (LL_RCC_PLL1P_IsEnabled() != 0U)
34182f88:	f7ff fe0a 	bl	34182ba0 <LL_RCC_PLL1P_IsEnabled>
34182f8c:	4603      	mov	r3, r0
34182f8e:	2b00      	cmp	r3, #0
34182f90:	d031      	beq.n	34182ff6 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34182f92:	f7ff fd8f 	bl	34182ab4 <LL_RCC_PLL1_GetSource>
34182f96:	4603      	mov	r3, r0
34182f98:	4618      	mov	r0, r3
34182f9a:	f000 f903 	bl	341831a4 <RCCEx_GetPLLSourceFreq>
34182f9e:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34182fa0:	68bb      	ldr	r3, [r7, #8]
34182fa2:	2b00      	cmp	r3, #0
34182fa4:	d027      	beq.n	34182ff6 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
      {
        divm = LL_RCC_PLL1_GetM();
34182fa6:	f7ff fdcb 	bl	34182b40 <LL_RCC_PLL1_GetM>
34182faa:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34182fac:	687b      	ldr	r3, [r7, #4]
34182fae:	2b00      	cmp	r3, #0
34182fb0:	d021      	beq.n	34182ff6 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
34182fb2:	f7ff fdb5 	bl	34182b20 <LL_RCC_PLL1_GetN>
34182fb6:	4605      	mov	r5, r0
34182fb8:	f7ff fe06 	bl	34182bc8 <LL_RCC_PLL1_GetFRACN>
34182fbc:	4606      	mov	r6, r0
34182fbe:	f7ff fdcf 	bl	34182b60 <LL_RCC_PLL1_GetP1>
34182fc2:	4604      	mov	r4, r0
34182fc4:	f7ff fddc 	bl	34182b80 <LL_RCC_PLL1_GetP2>
34182fc8:	4603      	mov	r3, r0
34182fca:	9301      	str	r3, [sp, #4]
34182fcc:	9400      	str	r4, [sp, #0]
34182fce:	4633      	mov	r3, r6
34182fd0:	462a      	mov	r2, r5
34182fd2:	6879      	ldr	r1, [r7, #4]
34182fd4:	68b8      	ldr	r0, [r7, #8]
34182fd6:	f000 f943 	bl	34183260 <RCCEx_CalcPLLFreq>
34182fda:	60f8      	str	r0, [r7, #12]
34182fdc:	e00b      	b.n	34182ff6 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
                                            LL_RCC_PLL1_GetP1(), LL_RCC_PLL1_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL1_IsEnabledBypass() != 0U)
34182fde:	f7ff fd8b 	bl	34182af8 <LL_RCC_PLL1_IsEnabledBypass>
34182fe2:	4603      	mov	r3, r0
34182fe4:	2b00      	cmp	r3, #0
34182fe6:	d006      	beq.n	34182ff6 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34182fe8:	f7ff fd64 	bl	34182ab4 <LL_RCC_PLL1_GetSource>
34182fec:	4603      	mov	r3, r0
34182fee:	4618      	mov	r0, r3
34182ff0:	f000 f8d8 	bl	341831a4 <RCCEx_GetPLLSourceFreq>
34182ff4:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34182ff6:	68fb      	ldr	r3, [r7, #12]
}
34182ff8:	4618      	mov	r0, r3
34182ffa:	3714      	adds	r7, #20
34182ffc:	46bd      	mov	sp, r7
34182ffe:	bdf0      	pop	{r4, r5, r6, r7, pc}

34183000 <HAL_RCCEx_GetPLL2CLKFreq>:
  * @brief  Return PLL2 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL2 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL2CLKFreq(void)
{
34183000:	b5f0      	push	{r4, r5, r6, r7, lr}
34183002:	b087      	sub	sp, #28
34183004:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34183006:	2300      	movs	r3, #0
34183008:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL2_IsReady() != 0U)
3418300a:	f7ff fdf9 	bl	34182c00 <LL_RCC_PLL2_IsReady>
3418300e:	4603      	mov	r3, r0
34183010:	2b00      	cmp	r3, #0
34183012:	d02a      	beq.n	3418306a <HAL_RCCEx_GetPLL2CLKFreq+0x6a>
  {
    if (LL_RCC_PLL2P_IsEnabled() != 0U)
34183014:	f7ff fe5c 	bl	34182cd0 <LL_RCC_PLL2P_IsEnabled>
34183018:	4603      	mov	r3, r0
3418301a:	2b00      	cmp	r3, #0
3418301c:	d031      	beq.n	34183082 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3418301e:	f7ff fde1 	bl	34182be4 <LL_RCC_PLL2_GetSource>
34183022:	4603      	mov	r3, r0
34183024:	4618      	mov	r0, r3
34183026:	f000 f8bd 	bl	341831a4 <RCCEx_GetPLLSourceFreq>
3418302a:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3418302c:	68bb      	ldr	r3, [r7, #8]
3418302e:	2b00      	cmp	r3, #0
34183030:	d027      	beq.n	34183082 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
      {

        divm = LL_RCC_PLL2_GetM();
34183032:	f7ff fe1d 	bl	34182c70 <LL_RCC_PLL2_GetM>
34183036:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34183038:	687b      	ldr	r3, [r7, #4]
3418303a:	2b00      	cmp	r3, #0
3418303c:	d021      	beq.n	34183082 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
3418303e:	f7ff fe07 	bl	34182c50 <LL_RCC_PLL2_GetN>
34183042:	4605      	mov	r5, r0
34183044:	f7ff fe58 	bl	34182cf8 <LL_RCC_PLL2_GetFRACN>
34183048:	4606      	mov	r6, r0
3418304a:	f7ff fe21 	bl	34182c90 <LL_RCC_PLL2_GetP1>
3418304e:	4604      	mov	r4, r0
34183050:	f7ff fe2e 	bl	34182cb0 <LL_RCC_PLL2_GetP2>
34183054:	4603      	mov	r3, r0
34183056:	9301      	str	r3, [sp, #4]
34183058:	9400      	str	r4, [sp, #0]
3418305a:	4633      	mov	r3, r6
3418305c:	462a      	mov	r2, r5
3418305e:	6879      	ldr	r1, [r7, #4]
34183060:	68b8      	ldr	r0, [r7, #8]
34183062:	f000 f8fd 	bl	34183260 <RCCEx_CalcPLLFreq>
34183066:	60f8      	str	r0, [r7, #12]
34183068:	e00b      	b.n	34183082 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
                                            LL_RCC_PLL2_GetP1(), LL_RCC_PLL2_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL2_IsEnabledBypass() != 0U)
3418306a:	f7ff fddd 	bl	34182c28 <LL_RCC_PLL2_IsEnabledBypass>
3418306e:	4603      	mov	r3, r0
34183070:	2b00      	cmp	r3, #0
34183072:	d006      	beq.n	34183082 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34183074:	f7ff fdb6 	bl	34182be4 <LL_RCC_PLL2_GetSource>
34183078:	4603      	mov	r3, r0
3418307a:	4618      	mov	r0, r3
3418307c:	f000 f892 	bl	341831a4 <RCCEx_GetPLLSourceFreq>
34183080:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34183082:	68fb      	ldr	r3, [r7, #12]
}
34183084:	4618      	mov	r0, r3
34183086:	3714      	adds	r7, #20
34183088:	46bd      	mov	sp, r7
3418308a:	bdf0      	pop	{r4, r5, r6, r7, pc}

3418308c <HAL_RCCEx_GetPLL3CLKFreq>:
  * @brief  Return PLL3 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL3 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL3CLKFreq(void)
{
3418308c:	b5f0      	push	{r4, r5, r6, r7, lr}
3418308e:	b087      	sub	sp, #28
34183090:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34183092:	2300      	movs	r3, #0
34183094:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL3_IsReady() != 0U)
34183096:	f7ff fe4b 	bl	34182d30 <LL_RCC_PLL3_IsReady>
3418309a:	4603      	mov	r3, r0
3418309c:	2b00      	cmp	r3, #0
3418309e:	d02a      	beq.n	341830f6 <HAL_RCCEx_GetPLL3CLKFreq+0x6a>
  {
    if (LL_RCC_PLL3P_IsEnabled() != 0U)
341830a0:	f7ff feae 	bl	34182e00 <LL_RCC_PLL3P_IsEnabled>
341830a4:	4603      	mov	r3, r0
341830a6:	2b00      	cmp	r3, #0
341830a8:	d031      	beq.n	3418310e <HAL_RCCEx_GetPLL3CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
341830aa:	f7ff fe33 	bl	34182d14 <LL_RCC_PLL3_GetSource>
341830ae:	4603      	mov	r3, r0
341830b0:	4618      	mov	r0, r3
341830b2:	f000 f877 	bl	341831a4 <RCCEx_GetPLLSourceFreq>
341830b6:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
341830b8:	68bb      	ldr	r3, [r7, #8]
341830ba:	2b00      	cmp	r3, #0
341830bc:	d027      	beq.n	3418310e <HAL_RCCEx_GetPLL3CLKFreq+0x82>
      {
        divm = LL_RCC_PLL3_GetM();
341830be:	f7ff fe6f 	bl	34182da0 <LL_RCC_PLL3_GetM>
341830c2:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
341830c4:	687b      	ldr	r3, [r7, #4]
341830c6:	2b00      	cmp	r3, #0
341830c8:	d021      	beq.n	3418310e <HAL_RCCEx_GetPLL3CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
341830ca:	f7ff fe59 	bl	34182d80 <LL_RCC_PLL3_GetN>
341830ce:	4605      	mov	r5, r0
341830d0:	f7ff feaa 	bl	34182e28 <LL_RCC_PLL3_GetFRACN>
341830d4:	4606      	mov	r6, r0
341830d6:	f7ff fe73 	bl	34182dc0 <LL_RCC_PLL3_GetP1>
341830da:	4604      	mov	r4, r0
341830dc:	f7ff fe80 	bl	34182de0 <LL_RCC_PLL3_GetP2>
341830e0:	4603      	mov	r3, r0
341830e2:	9301      	str	r3, [sp, #4]
341830e4:	9400      	str	r4, [sp, #0]
341830e6:	4633      	mov	r3, r6
341830e8:	462a      	mov	r2, r5
341830ea:	6879      	ldr	r1, [r7, #4]
341830ec:	68b8      	ldr	r0, [r7, #8]
341830ee:	f000 f8b7 	bl	34183260 <RCCEx_CalcPLLFreq>
341830f2:	60f8      	str	r0, [r7, #12]
341830f4:	e00b      	b.n	3418310e <HAL_RCCEx_GetPLL3CLKFreq+0x82>
                                            LL_RCC_PLL3_GetP1(), LL_RCC_PLL3_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL3_IsEnabledBypass() != 0U)
341830f6:	f7ff fe2f 	bl	34182d58 <LL_RCC_PLL3_IsEnabledBypass>
341830fa:	4603      	mov	r3, r0
341830fc:	2b00      	cmp	r3, #0
341830fe:	d006      	beq.n	3418310e <HAL_RCCEx_GetPLL3CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34183100:	f7ff fe08 	bl	34182d14 <LL_RCC_PLL3_GetSource>
34183104:	4603      	mov	r3, r0
34183106:	4618      	mov	r0, r3
34183108:	f000 f84c 	bl	341831a4 <RCCEx_GetPLLSourceFreq>
3418310c:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
3418310e:	68fb      	ldr	r3, [r7, #12]
}
34183110:	4618      	mov	r0, r3
34183112:	3714      	adds	r7, #20
34183114:	46bd      	mov	sp, r7
34183116:	bdf0      	pop	{r4, r5, r6, r7, pc}

34183118 <HAL_RCCEx_GetPLL4CLKFreq>:
  * @brief  Return PLL4 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL4 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL4CLKFreq(void)
{
34183118:	b5f0      	push	{r4, r5, r6, r7, lr}
3418311a:	b087      	sub	sp, #28
3418311c:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3418311e:	2300      	movs	r3, #0
34183120:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL4_IsReady() != 0U)
34183122:	f7ff fe9d 	bl	34182e60 <LL_RCC_PLL4_IsReady>
34183126:	4603      	mov	r3, r0
34183128:	2b00      	cmp	r3, #0
3418312a:	d02a      	beq.n	34183182 <HAL_RCCEx_GetPLL4CLKFreq+0x6a>
  {
    if (LL_RCC_PLL4P_IsEnabled() != 0U)
3418312c:	f7ff ff00 	bl	34182f30 <LL_RCC_PLL4P_IsEnabled>
34183130:	4603      	mov	r3, r0
34183132:	2b00      	cmp	r3, #0
34183134:	d031      	beq.n	3418319a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34183136:	f7ff fe85 	bl	34182e44 <LL_RCC_PLL4_GetSource>
3418313a:	4603      	mov	r3, r0
3418313c:	4618      	mov	r0, r3
3418313e:	f000 f831 	bl	341831a4 <RCCEx_GetPLLSourceFreq>
34183142:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34183144:	68bb      	ldr	r3, [r7, #8]
34183146:	2b00      	cmp	r3, #0
34183148:	d027      	beq.n	3418319a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
      {

        divm = LL_RCC_PLL4_GetM();
3418314a:	f7ff fec1 	bl	34182ed0 <LL_RCC_PLL4_GetM>
3418314e:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34183150:	687b      	ldr	r3, [r7, #4]
34183152:	2b00      	cmp	r3, #0
34183154:	d021      	beq.n	3418319a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
34183156:	f7ff feab 	bl	34182eb0 <LL_RCC_PLL4_GetN>
3418315a:	4605      	mov	r5, r0
3418315c:	f7ff fefc 	bl	34182f58 <LL_RCC_PLL4_GetFRACN>
34183160:	4606      	mov	r6, r0
34183162:	f7ff fec5 	bl	34182ef0 <LL_RCC_PLL4_GetP1>
34183166:	4604      	mov	r4, r0
34183168:	f7ff fed2 	bl	34182f10 <LL_RCC_PLL4_GetP2>
3418316c:	4603      	mov	r3, r0
3418316e:	9301      	str	r3, [sp, #4]
34183170:	9400      	str	r4, [sp, #0]
34183172:	4633      	mov	r3, r6
34183174:	462a      	mov	r2, r5
34183176:	6879      	ldr	r1, [r7, #4]
34183178:	68b8      	ldr	r0, [r7, #8]
3418317a:	f000 f871 	bl	34183260 <RCCEx_CalcPLLFreq>
3418317e:	60f8      	str	r0, [r7, #12]
34183180:	e00b      	b.n	3418319a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
                                            LL_RCC_PLL4_GetP1(), LL_RCC_PLL4_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL4_IsEnabledBypass() != 0U)
34183182:	f7ff fe81 	bl	34182e88 <LL_RCC_PLL4_IsEnabledBypass>
34183186:	4603      	mov	r3, r0
34183188:	2b00      	cmp	r3, #0
3418318a:	d006      	beq.n	3418319a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3418318c:	f7ff fe5a 	bl	34182e44 <LL_RCC_PLL4_GetSource>
34183190:	4603      	mov	r3, r0
34183192:	4618      	mov	r0, r3
34183194:	f000 f806 	bl	341831a4 <RCCEx_GetPLLSourceFreq>
34183198:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
3418319a:	68fb      	ldr	r3, [r7, #12]
}
3418319c:	4618      	mov	r0, r3
3418319e:	3714      	adds	r7, #20
341831a0:	46bd      	mov	sp, r7
341831a2:	bdf0      	pop	{r4, r5, r6, r7, pc}

341831a4 <RCCEx_GetPLLSourceFreq>:
  * @brief  Return PLL source clock frequency
  * @param  PLLsource PLL source clock
  * @retval PLL source clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
341831a4:	b580      	push	{r7, lr}
341831a6:	b084      	sub	sp, #16
341831a8:	af00      	add	r7, sp, #0
341831aa:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
341831ac:	2300      	movs	r3, #0
341831ae:	60fb      	str	r3, [r7, #12]

  switch (PLLsource)
341831b0:	687b      	ldr	r3, [r7, #4]
341831b2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341831b6:	d039      	beq.n	3418322c <RCCEx_GetPLLSourceFreq+0x88>
341831b8:	687b      	ldr	r3, [r7, #4]
341831ba:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341831be:	d838      	bhi.n	34183232 <RCCEx_GetPLLSourceFreq+0x8e>
341831c0:	687b      	ldr	r3, [r7, #4]
341831c2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341831c6:	d029      	beq.n	3418321c <RCCEx_GetPLLSourceFreq+0x78>
341831c8:	687b      	ldr	r3, [r7, #4]
341831ca:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341831ce:	d830      	bhi.n	34183232 <RCCEx_GetPLLSourceFreq+0x8e>
341831d0:	687b      	ldr	r3, [r7, #4]
341831d2:	2b00      	cmp	r3, #0
341831d4:	d004      	beq.n	341831e0 <RCCEx_GetPLLSourceFreq+0x3c>
341831d6:	687b      	ldr	r3, [r7, #4]
341831d8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341831dc:	d00e      	beq.n	341831fc <RCCEx_GetPLLSourceFreq+0x58>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
      break;

    default:
      /* unexpected case */
      break;
341831de:	e028      	b.n	34183232 <RCCEx_GetPLLSourceFreq+0x8e>
      if (LL_RCC_HSI_IsReady() != 0U)
341831e0:	f7ff fc28 	bl	34182a34 <LL_RCC_HSI_IsReady>
341831e4:	4603      	mov	r3, r0
341831e6:	2b00      	cmp	r3, #0
341831e8:	d025      	beq.n	34183236 <RCCEx_GetPLLSourceFreq+0x92>
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
341831ea:	f7ff fc35 	bl	34182a58 <LL_RCC_HSI_GetDivider>
341831ee:	4603      	mov	r3, r0
341831f0:	09db      	lsrs	r3, r3, #7
341831f2:	4a16      	ldr	r2, [pc, #88]	@ (3418324c <RCCEx_GetPLLSourceFreq+0xa8>)
341831f4:	fa22 f303 	lsr.w	r3, r2, r3
341831f8:	60fb      	str	r3, [r7, #12]
      break;
341831fa:	e01c      	b.n	34183236 <RCCEx_GetPLLSourceFreq+0x92>
      if (LL_RCC_MSI_IsReady() != 0U)
341831fc:	f7ff fc3a 	bl	34182a74 <LL_RCC_MSI_IsReady>
34183200:	4603      	mov	r3, r0
34183202:	2b00      	cmp	r3, #0
34183204:	d019      	beq.n	3418323a <RCCEx_GetPLLSourceFreq+0x96>
        if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
34183206:	f7ff fc47 	bl	34182a98 <LL_RCC_MSI_GetFrequency>
3418320a:	4603      	mov	r3, r0
3418320c:	2b00      	cmp	r3, #0
3418320e:	d102      	bne.n	34183216 <RCCEx_GetPLLSourceFreq+0x72>
          pllinputfreq = MSI_VALUE;
34183210:	4b0f      	ldr	r3, [pc, #60]	@ (34183250 <RCCEx_GetPLLSourceFreq+0xac>)
34183212:	60fb      	str	r3, [r7, #12]
      break;
34183214:	e011      	b.n	3418323a <RCCEx_GetPLLSourceFreq+0x96>
          pllinputfreq = 16000000UL;
34183216:	4b0f      	ldr	r3, [pc, #60]	@ (34183254 <RCCEx_GetPLLSourceFreq+0xb0>)
34183218:	60fb      	str	r3, [r7, #12]
      break;
3418321a:	e00e      	b.n	3418323a <RCCEx_GetPLLSourceFreq+0x96>
      if (LL_RCC_HSE_IsReady() != 0U)
3418321c:	f7ff fbf8 	bl	34182a10 <LL_RCC_HSE_IsReady>
34183220:	4603      	mov	r3, r0
34183222:	2b00      	cmp	r3, #0
34183224:	d00b      	beq.n	3418323e <RCCEx_GetPLLSourceFreq+0x9a>
        pllinputfreq = HSE_VALUE;
34183226:	4b0c      	ldr	r3, [pc, #48]	@ (34183258 <RCCEx_GetPLLSourceFreq+0xb4>)
34183228:	60fb      	str	r3, [r7, #12]
      break;
3418322a:	e008      	b.n	3418323e <RCCEx_GetPLLSourceFreq+0x9a>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
3418322c:	4b0b      	ldr	r3, [pc, #44]	@ (3418325c <RCCEx_GetPLLSourceFreq+0xb8>)
3418322e:	60fb      	str	r3, [r7, #12]
      break;
34183230:	e006      	b.n	34183240 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34183232:	bf00      	nop
34183234:	e004      	b.n	34183240 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34183236:	bf00      	nop
34183238:	e002      	b.n	34183240 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
3418323a:	bf00      	nop
3418323c:	e000      	b.n	34183240 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
3418323e:	bf00      	nop
  }

  return pllinputfreq;
34183240:	68fb      	ldr	r3, [r7, #12]
}
34183242:	4618      	mov	r0, r3
34183244:	3710      	adds	r7, #16
34183246:	46bd      	mov	sp, r7
34183248:	bd80      	pop	{r7, pc}
3418324a:	bf00      	nop
3418324c:	03d09000 	.word	0x03d09000
34183250:	003d0900 	.word	0x003d0900
34183254:	00f42400 	.word	0x00f42400
34183258:	02dc6c00 	.word	0x02dc6c00
3418325c:	00bb8000 	.word	0x00bb8000

34183260 <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
34183260:	b480      	push	{r7}
34183262:	b087      	sub	sp, #28
34183264:	af00      	add	r7, sp, #0
34183266:	60f8      	str	r0, [r7, #12]
34183268:	60b9      	str	r1, [r7, #8]
3418326a:	607a      	str	r2, [r7, #4]
3418326c:	603b      	str	r3, [r7, #0]
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
3418326e:	68fb      	ldr	r3, [r7, #12]
34183270:	ee07 3a90 	vmov	s15, r3
34183274:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34183278:	687b      	ldr	r3, [r7, #4]
3418327a:	ee07 3a90 	vmov	s15, r3
3418327e:	eef8 6a67 	vcvt.f32.u32	s13, s15
34183282:	683b      	ldr	r3, [r7, #0]
34183284:	ee07 3a90 	vmov	s15, r3
34183288:	eeb8 6a67 	vcvt.f32.u32	s12, s15
3418328c:	eddf 5a19 	vldr	s11, [pc, #100]	@ 341832f4 <RCCEx_CalcPLLFreq+0x94>
34183290:	eec6 7a25 	vdiv.f32	s15, s12, s11
34183294:	ee76 7aa7 	vadd.f32	s15, s13, s15
34183298:	ee67 6a27 	vmul.f32	s13, s14, s15
3418329c:	68bb      	ldr	r3, [r7, #8]
3418329e:	ee07 3a90 	vmov	s15, r3
341832a2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341832a6:	eec6 7a87 	vdiv.f32	s15, s13, s14
341832aa:	edc7 7a05 	vstr	s15, [r7, #20]

  freq = freq / (float_t)P1;
341832ae:	6a3b      	ldr	r3, [r7, #32]
341832b0:	ee07 3a90 	vmov	s15, r3
341832b4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341832b8:	edd7 6a05 	vldr	s13, [r7, #20]
341832bc:	eec6 7a87 	vdiv.f32	s15, s13, s14
341832c0:	edc7 7a05 	vstr	s15, [r7, #20]
  freq = freq / (float_t)P2;
341832c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341832c6:	ee07 3a90 	vmov	s15, r3
341832ca:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341832ce:	edd7 6a05 	vldr	s13, [r7, #20]
341832d2:	eec6 7a87 	vdiv.f32	s15, s13, s14
341832d6:	edc7 7a05 	vstr	s15, [r7, #20]

  return (uint32_t)freq;
341832da:	edd7 7a05 	vldr	s15, [r7, #20]
341832de:	eefc 7ae7 	vcvt.u32.f32	s15, s15
341832e2:	ee17 3a90 	vmov	r3, s15
}
341832e6:	4618      	mov	r0, r3
341832e8:	371c      	adds	r7, #28
341832ea:	46bd      	mov	sp, r7
341832ec:	f85d 7b04 	ldr.w	r7, [sp], #4
341832f0:	4770      	bx	lr
341832f2:	bf00      	nop
341832f4:	4b800000 	.word	0x4b800000

341832f8 <memset>:
341832f8:	4402      	add	r2, r0
341832fa:	4603      	mov	r3, r0
341832fc:	4293      	cmp	r3, r2
341832fe:	d100      	bne.n	34183302 <memset+0xa>
34183300:	4770      	bx	lr
34183302:	f803 1b01 	strb.w	r1, [r3], #1
34183306:	e7f9      	b.n	341832fc <memset+0x4>

34183308 <__libc_init_array>:
34183308:	b570      	push	{r4, r5, r6, lr}
3418330a:	4d0d      	ldr	r5, [pc, #52]	@ (34183340 <__libc_init_array+0x38>)
3418330c:	2600      	movs	r6, #0
3418330e:	4c0d      	ldr	r4, [pc, #52]	@ (34183344 <__libc_init_array+0x3c>)
34183310:	1b64      	subs	r4, r4, r5
34183312:	10a4      	asrs	r4, r4, #2
34183314:	42a6      	cmp	r6, r4
34183316:	d109      	bne.n	3418332c <__libc_init_array+0x24>
34183318:	4d0b      	ldr	r5, [pc, #44]	@ (34183348 <__libc_init_array+0x40>)
3418331a:	2600      	movs	r6, #0
3418331c:	4c0b      	ldr	r4, [pc, #44]	@ (3418334c <__libc_init_array+0x44>)
3418331e:	f000 f817 	bl	34183350 <_init>
34183322:	1b64      	subs	r4, r4, r5
34183324:	10a4      	asrs	r4, r4, #2
34183326:	42a6      	cmp	r6, r4
34183328:	d105      	bne.n	34183336 <__libc_init_array+0x2e>
3418332a:	bd70      	pop	{r4, r5, r6, pc}
3418332c:	f855 3b04 	ldr.w	r3, [r5], #4
34183330:	3601      	adds	r6, #1
34183332:	4798      	blx	r3
34183334:	e7ee      	b.n	34183314 <__libc_init_array+0xc>
34183336:	f855 3b04 	ldr.w	r3, [r5], #4
3418333a:	3601      	adds	r6, #1
3418333c:	4798      	blx	r3
3418333e:	e7f2      	b.n	34183326 <__libc_init_array+0x1e>
34183340:	34183368 	.word	0x34183368
34183344:	34183368 	.word	0x34183368
34183348:	34183368 	.word	0x34183368
3418334c:	3418336c 	.word	0x3418336c

34183350 <_init>:
34183350:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34183352:	bf00      	nop
34183354:	bcf8      	pop	{r3, r4, r5, r6, r7}
34183356:	bc08      	pop	{r3}
34183358:	469e      	mov	lr, r3
3418335a:	4770      	bx	lr

3418335c <_fini>:
3418335c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3418335e:	bf00      	nop
34183360:	bcf8      	pop	{r3, r4, r5, r6, r7}
34183362:	bc08      	pop	{r3}
34183364:	469e      	mov	lr, r3
34183366:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

34183380 <SECURE_SystemCoreClockUpdate>:
34183380:	e97f e97f 	sg
34183384:	f7fd bd7c 	b.w	34180e80 <__acle_se_SECURE_SystemCoreClockUpdate>
	...
