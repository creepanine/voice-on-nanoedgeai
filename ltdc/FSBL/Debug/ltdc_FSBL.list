
ltdc_FSBL.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34180400  34180400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000091c0  3418074c  3418074c  0000074c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00002b9c  3418990c  3418990c  0000990c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  3418c4a8  3418c4a8  0000d500  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  3418c4a8  3418c4a8  0000d500  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  3418c4a8  3418c4a8  0000d500  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  3418c4a8  3418c4a8  0000c4a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  3418c4ac  3418c4ac  0000c4ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         0000002c  341c0000  3418c4b0  0000d000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .noncacheable 00000004  341c002c  3418c4dc  0000d02c  2**0
                  ALLOC
 10 .gnu.sgstubs  00000020  3418c4e0  3418c4e0  0000d4e0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .bss          000001bc  341c0030  341c0030  0000e030  2**2
                  ALLOC
 12 ._user_heap_stack 00000a04  341c01ec  341c01ec  0000e030  2**0
                  ALLOC
 13 .ARM.attributes 0000003a  00000000  00000000  0000d500  2**0
                  CONTENTS, READONLY
 14 .debug_info   0001885b  00000000  00000000  0000d53a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 0000263b  00000000  00000000  00025d95  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00001ac0  00000000  00000000  000283d0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 0000142f  00000000  00000000  00029e90  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00052a5b  00000000  00000000  0002b2bf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   00016b09  00000000  00000000  0007dd1a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    0020d802  00000000  00000000  00094823  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  002a2025  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00007034  00000000  00000000  002a2068  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_line_str 00000074  00000000  00000000  002a909c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

3418074c <__do_global_dtors_aux>:
3418074c:	b510      	push	{r4, lr}
3418074e:	4c05      	ldr	r4, [pc, #20]	@ (34180764 <__do_global_dtors_aux+0x18>)
34180750:	7823      	ldrb	r3, [r4, #0]
34180752:	b933      	cbnz	r3, 34180762 <__do_global_dtors_aux+0x16>
34180754:	4b04      	ldr	r3, [pc, #16]	@ (34180768 <__do_global_dtors_aux+0x1c>)
34180756:	b113      	cbz	r3, 3418075e <__do_global_dtors_aux+0x12>
34180758:	4804      	ldr	r0, [pc, #16]	@ (3418076c <__do_global_dtors_aux+0x20>)
3418075a:	f3af 8000 	nop.w
3418075e:	2301      	movs	r3, #1
34180760:	7023      	strb	r3, [r4, #0]
34180762:	bd10      	pop	{r4, pc}
34180764:	341c0030 	.word	0x341c0030
34180768:	00000000 	.word	0x00000000
3418076c:	341898f4 	.word	0x341898f4

34180770 <frame_dummy>:
34180770:	b508      	push	{r3, lr}
34180772:	4b03      	ldr	r3, [pc, #12]	@ (34180780 <frame_dummy+0x10>)
34180774:	b11b      	cbz	r3, 3418077e <frame_dummy+0xe>
34180776:	4903      	ldr	r1, [pc, #12]	@ (34180784 <frame_dummy+0x14>)
34180778:	4803      	ldr	r0, [pc, #12]	@ (34180788 <frame_dummy+0x18>)
3418077a:	f3af 8000 	nop.w
3418077e:	bd08      	pop	{r3, pc}
34180780:	00000000 	.word	0x00000000
34180784:	341c0034 	.word	0x341c0034
34180788:	341898f4 	.word	0x341898f4

3418078c <LL_AHB4_GRP1_EnableClock>:
  *         @arg @ref LL_AHB4_GRP1_PERIPH_PWR
  *         @arg @ref LL_AHB4_GRP1_PERIPH_CRC
  * @retval None
  */
__STATIC_INLINE void LL_AHB4_GRP1_EnableClock(uint32_t Periphs)
{
3418078c:	b480      	push	{r7}
3418078e:	b085      	sub	sp, #20
34180790:	af00      	add	r7, sp, #0
34180792:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34180794:	4a07      	ldr	r2, [pc, #28]	@ (341807b4 <LL_AHB4_GRP1_EnableClock+0x28>)
34180796:	687b      	ldr	r3, [r7, #4]
34180798:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB4ENR);
3418079c:	4b05      	ldr	r3, [pc, #20]	@ (341807b4 <LL_AHB4_GRP1_EnableClock+0x28>)
3418079e:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
341807a2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341807a4:	68fb      	ldr	r3, [r7, #12]
}
341807a6:	bf00      	nop
341807a8:	3714      	adds	r7, #20
341807aa:	46bd      	mov	sp, r7
341807ac:	f85d 7b04 	ldr.w	r7, [sp], #4
341807b0:	4770      	bx	lr
341807b2:	bf00      	nop
341807b4:	56028000 	.word	0x56028000

341807b8 <BSP_LED_Init>:
  *            @arg  LED1
  *            @arg  LED2
  * @retval BSP status
  */
int32_t  BSP_LED_Init(Led_TypeDef Led)
{
341807b8:	b580      	push	{r7, lr}
341807ba:	b088      	sub	sp, #32
341807bc:	af00      	add	r7, sp, #0
341807be:	4603      	mov	r3, r0
341807c0:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
341807c2:	2300      	movs	r3, #0
341807c4:	61fb      	str	r3, [r7, #28]
  GPIO_InitTypeDef  gpio_init_structure;

  /* Enable the GPIO_LED clock */
  switch(Led)
341807c6:	79fb      	ldrb	r3, [r7, #7]
341807c8:	2b00      	cmp	r3, #0
341807ca:	d002      	beq.n	341807d2 <BSP_LED_Init+0x1a>
341807cc:	2b01      	cmp	r3, #1
341807ce:	d007      	beq.n	341807e0 <BSP_LED_Init+0x28>
341807d0:	e00a      	b.n	341807e8 <BSP_LED_Init+0x30>
  {
    case LED1:
      HAL_PWREx_EnableVddIO2();
341807d2:	f003 fc37 	bl	34184044 <HAL_PWREx_EnableVddIO2>
      LED1_GPIO_CLK_ENABLE();
341807d6:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
341807da:	f7ff ffd7 	bl	3418078c <LL_AHB4_GRP1_EnableClock>
      break;
341807de:	e007      	b.n	341807f0 <BSP_LED_Init+0x38>

    case LED2:

      LED2_GPIO_CLK_ENABLE();
341807e0:	2040      	movs	r0, #64	@ 0x40
341807e2:	f7ff ffd3 	bl	3418078c <LL_AHB4_GRP1_EnableClock>
      break;
341807e6:	e003      	b.n	341807f0 <BSP_LED_Init+0x38>

    default:
      ret = BSP_ERROR_WRONG_PARAM;
341807e8:	f06f 0301 	mvn.w	r3, #1
341807ec:	61fb      	str	r3, [r7, #28]
      break;
341807ee:	bf00      	nop
  }

  if (ret == BSP_ERROR_NONE)
341807f0:	69fb      	ldr	r3, [r7, #28]
341807f2:	2b00      	cmp	r3, #0
341807f4:	d118      	bne.n	34180828 <BSP_LED_Init+0x70>
  {
    /* configure the GPIO_LED pin */
    gpio_init_structure.Pin = LED_PIN [Led];
341807f6:	79fb      	ldrb	r3, [r7, #7]
341807f8:	4a0e      	ldr	r2, [pc, #56]	@ (34180834 <BSP_LED_Init+0x7c>)
341807fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
341807fe:	60bb      	str	r3, [r7, #8]
    gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
34180800:	2301      	movs	r3, #1
34180802:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Pull = GPIO_NOPULL;
34180804:	2300      	movs	r3, #0
34180806:	613b      	str	r3, [r7, #16]
    gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34180808:	2303      	movs	r3, #3
3418080a:	617b      	str	r3, [r7, #20]
    HAL_GPIO_Init (LED_PORT [Led], &gpio_init_structure);
3418080c:	79fb      	ldrb	r3, [r7, #7]
3418080e:	4a0a      	ldr	r2, [pc, #40]	@ (34180838 <BSP_LED_Init+0x80>)
34180810:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34180814:	f107 0208 	add.w	r2, r7, #8
34180818:	4611      	mov	r1, r2
3418081a:	4618      	mov	r0, r3
3418081c:	f002 f8cc 	bl	341829b8 <HAL_GPIO_Init>

    /* By default, turn off LED */
    BSP_LED_Off(Led);
34180820:	79fb      	ldrb	r3, [r7, #7]
34180822:	4618      	mov	r0, r3
34180824:	f000 f80a 	bl	3418083c <BSP_LED_Off>
  }

  return ret;
34180828:	69fb      	ldr	r3, [r7, #28]
}
3418082a:	4618      	mov	r0, r3
3418082c:	3720      	adds	r7, #32
3418082e:	46bd      	mov	sp, r7
34180830:	bd80      	pop	{r7, pc}
34180832:	bf00      	nop
34180834:	34189968 	.word	0x34189968
34180838:	341c0000 	.word	0x341c0000

3418083c <BSP_LED_Off>:
  *            @arg  LED1
  *            @arg  LED2
  * @retval None
  */
void BSP_LED_Off(Led_TypeDef Led)
{
3418083c:	b580      	push	{r7, lr}
3418083e:	b082      	sub	sp, #8
34180840:	af00      	add	r7, sp, #0
34180842:	4603      	mov	r3, r0
34180844:	71fb      	strb	r3, [r7, #7]
  if(Led == LED1)
34180846:	79fb      	ldrb	r3, [r7, #7]
34180848:	2b00      	cmp	r3, #0
3418084a:	d10d      	bne.n	34180868 <BSP_LED_Off+0x2c>
  {
    /* LED1 High active */
    HAL_GPIO_WritePin (LED_PORT [Led], (uint16_t)LED_PIN [Led], GPIO_PIN_RESET);
3418084c:	79fb      	ldrb	r3, [r7, #7]
3418084e:	4a0f      	ldr	r2, [pc, #60]	@ (3418088c <BSP_LED_Off+0x50>)
34180850:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
34180854:	79fb      	ldrb	r3, [r7, #7]
34180856:	4a0e      	ldr	r2, [pc, #56]	@ (34180890 <BSP_LED_Off+0x54>)
34180858:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3418085c:	b29b      	uxth	r3, r3
3418085e:	2200      	movs	r2, #0
34180860:	4619      	mov	r1, r3
34180862:	f002 fa5b 	bl	34182d1c <HAL_GPIO_WritePin>
  }else
  {
    /* LED2 Low active */
    HAL_GPIO_WritePin (LED_PORT [Led], (uint16_t)LED_PIN [Led], GPIO_PIN_SET);
  }
}
34180866:	e00c      	b.n	34180882 <BSP_LED_Off+0x46>
    HAL_GPIO_WritePin (LED_PORT [Led], (uint16_t)LED_PIN [Led], GPIO_PIN_SET);
34180868:	79fb      	ldrb	r3, [r7, #7]
3418086a:	4a08      	ldr	r2, [pc, #32]	@ (3418088c <BSP_LED_Off+0x50>)
3418086c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
34180870:	79fb      	ldrb	r3, [r7, #7]
34180872:	4a07      	ldr	r2, [pc, #28]	@ (34180890 <BSP_LED_Off+0x54>)
34180874:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34180878:	b29b      	uxth	r3, r3
3418087a:	2201      	movs	r2, #1
3418087c:	4619      	mov	r1, r3
3418087e:	f002 fa4d 	bl	34182d1c <HAL_GPIO_WritePin>
}
34180882:	bf00      	nop
34180884:	3708      	adds	r7, #8
34180886:	46bd      	mov	sp, r7
34180888:	bd80      	pop	{r7, pc}
3418088a:	bf00      	nop
3418088c:	341c0000 	.word	0x341c0000
34180890:	34189968 	.word	0x34189968

34180894 <LL_AHB4_GRP1_EnableClock>:
{
34180894:	b480      	push	{r7}
34180896:	b085      	sub	sp, #20
34180898:	af00      	add	r7, sp, #0
3418089a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3418089c:	4a07      	ldr	r2, [pc, #28]	@ (341808bc <LL_AHB4_GRP1_EnableClock+0x28>)
3418089e:	687b      	ldr	r3, [r7, #4]
341808a0:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
341808a4:	4b05      	ldr	r3, [pc, #20]	@ (341808bc <LL_AHB4_GRP1_EnableClock+0x28>)
341808a6:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
341808aa:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341808ac:	68fb      	ldr	r3, [r7, #12]
}
341808ae:	bf00      	nop
341808b0:	3714      	adds	r7, #20
341808b2:	46bd      	mov	sp, r7
341808b4:	f85d 7b04 	ldr.w	r7, [sp], #4
341808b8:	4770      	bx	lr
341808ba:	bf00      	nop
341808bc:	56028000 	.word	0x56028000

341808c0 <LL_AHB5_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClock(uint32_t Periphs)
{
341808c0:	b480      	push	{r7}
341808c2:	b085      	sub	sp, #20
341808c4:	af00      	add	r7, sp, #0
341808c6:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5ENSR, Periphs);
341808c8:	4a07      	ldr	r2, [pc, #28]	@ (341808e8 <LL_AHB5_GRP1_EnableClock+0x28>)
341808ca:	687b      	ldr	r3, [r7, #4]
341808cc:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5ENR);
341808d0:	4b05      	ldr	r3, [pc, #20]	@ (341808e8 <LL_AHB5_GRP1_EnableClock+0x28>)
341808d2:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
341808d6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341808d8:	68fb      	ldr	r3, [r7, #12]
}
341808da:	bf00      	nop
341808dc:	3714      	adds	r7, #20
341808de:	46bd      	mov	sp, r7
341808e0:	f85d 7b04 	ldr.w	r7, [sp], #4
341808e4:	4770      	bx	lr
341808e6:	bf00      	nop
341808e8:	56028000 	.word	0x56028000

341808ec <LL_AHB5_GRP1_ForceReset>:
  *         @arg @ref LL_AHB5_GRP1_PERIPH_CACHEAXI
  *         @arg @ref LL_AHB5_GRP1_PERIPH_NPU
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_ForceReset(uint32_t Periphs)
{
341808ec:	b480      	push	{r7}
341808ee:	b083      	sub	sp, #12
341808f0:	af00      	add	r7, sp, #0
341808f2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
341808f4:	4a04      	ldr	r2, [pc, #16]	@ (34180908 <LL_AHB5_GRP1_ForceReset+0x1c>)
341808f6:	687b      	ldr	r3, [r7, #4]
341808f8:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
341808fc:	bf00      	nop
341808fe:	370c      	adds	r7, #12
34180900:	46bd      	mov	sp, r7
34180902:	f85d 7b04 	ldr.w	r7, [sp], #4
34180906:	4770      	bx	lr
34180908:	56028000 	.word	0x56028000

3418090c <LL_AHB5_GRP1_ReleaseReset>:
  *         @arg @ref LL_AHB5_GRP1_PERIPH_CACHEAXI
  *         @arg @ref LL_AHB5_GRP1_PERIPH_NPU
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_ReleaseReset(uint32_t Periphs)
{
3418090c:	b480      	push	{r7}
3418090e:	b083      	sub	sp, #12
34180910:	af00      	add	r7, sp, #0
34180912:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34180914:	4b06      	ldr	r3, [pc, #24]	@ (34180930 <LL_AHB5_GRP1_ReleaseReset+0x24>)
34180916:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418091a:	461a      	mov	r2, r3
3418091c:	687b      	ldr	r3, [r7, #4]
3418091e:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
34180922:	bf00      	nop
34180924:	370c      	adds	r7, #12
34180926:	46bd      	mov	sp, r7
34180928:	f85d 7b04 	ldr.w	r7, [sp], #4
3418092c:	4770      	bx	lr
3418092e:	bf00      	nop
34180930:	56028000 	.word	0x56028000

34180934 <LL_APB5_GRP1_EnableClock>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClock(uint32_t Periphs)
{
34180934:	b480      	push	{r7}
34180936:	b085      	sub	sp, #20
34180938:	af00      	add	r7, sp, #0
3418093a:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5ENSR, Periphs);
3418093c:	4a07      	ldr	r2, [pc, #28]	@ (3418095c <LL_APB5_GRP1_EnableClock+0x28>)
3418093e:	687b      	ldr	r3, [r7, #4]
34180940:	f8c2 3a7c 	str.w	r3, [r2, #2684]	@ 0xa7c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5ENR);
34180944:	4b05      	ldr	r3, [pc, #20]	@ (3418095c <LL_APB5_GRP1_EnableClock+0x28>)
34180946:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
3418094a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3418094c:	68fb      	ldr	r3, [r7, #12]
}
3418094e:	bf00      	nop
34180950:	3714      	adds	r7, #20
34180952:	46bd      	mov	sp, r7
34180954:	f85d 7b04 	ldr.w	r7, [sp], #4
34180958:	4770      	bx	lr
3418095a:	bf00      	nop
3418095c:	56028000 	.word	0x56028000

34180960 <LL_APB5_GRP1_ForceReset>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_ForceReset(uint32_t Periphs)
{
34180960:	b480      	push	{r7}
34180962:	b083      	sub	sp, #12
34180964:	af00      	add	r7, sp, #0
34180966:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34180968:	4a04      	ldr	r2, [pc, #16]	@ (3418097c <LL_APB5_GRP1_ForceReset+0x1c>)
3418096a:	687b      	ldr	r3, [r7, #4]
3418096c:	f8c2 3a3c 	str.w	r3, [r2, #2620]	@ 0xa3c
}
34180970:	bf00      	nop
34180972:	370c      	adds	r7, #12
34180974:	46bd      	mov	sp, r7
34180976:	f85d 7b04 	ldr.w	r7, [sp], #4
3418097a:	4770      	bx	lr
3418097c:	56028000 	.word	0x56028000

34180980 <LL_APB5_GRP1_ReleaseReset>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_ReleaseReset(uint32_t Periphs)
{
34180980:	b480      	push	{r7}
34180982:	b083      	sub	sp, #12
34180984:	af00      	add	r7, sp, #0
34180986:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34180988:	4b06      	ldr	r3, [pc, #24]	@ (341809a4 <LL_APB5_GRP1_ReleaseReset+0x24>)
3418098a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418098e:	461a      	mov	r2, r3
34180990:	687b      	ldr	r3, [r7, #4]
34180992:	f8c2 323c 	str.w	r3, [r2, #572]	@ 0x23c
}
34180996:	bf00      	nop
34180998:	370c      	adds	r7, #12
3418099a:	46bd      	mov	sp, r7
3418099c:	f85d 7b04 	ldr.w	r7, [sp], #4
341809a0:	4770      	bx	lr
341809a2:	bf00      	nop
341809a4:	56028000 	.word	0x56028000

341809a8 <BSP_LCD_Init>:
  * @param  Orientation LCD_ORIENTATION_LANDSCAPE
  * @retval BSP status
  */

int32_t BSP_LCD_Init(uint32_t Instance, uint32_t Orientation)
{
341809a8:	b580      	push	{r7, lr}
341809aa:	b084      	sub	sp, #16
341809ac:	af02      	add	r7, sp, #8
341809ae:	6078      	str	r0, [r7, #4]
341809b0:	6039      	str	r1, [r7, #0]
  return BSP_LCD_InitEx(Instance, Orientation, LCD_PIXEL_FORMAT_RGB565, LCD_DEFAULT_WIDTH, LCD_DEFAULT_HEIGHT);
341809b2:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
341809b6:	9300      	str	r3, [sp, #0]
341809b8:	f44f 7348 	mov.w	r3, #800	@ 0x320
341809bc:	2202      	movs	r2, #2
341809be:	6839      	ldr	r1, [r7, #0]
341809c0:	6878      	ldr	r0, [r7, #4]
341809c2:	f000 f805 	bl	341809d0 <BSP_LCD_InitEx>
341809c6:	4603      	mov	r3, r0
}
341809c8:	4618      	mov	r0, r3
341809ca:	3708      	adds	r7, #8
341809cc:	46bd      	mov	sp, r7
341809ce:	bd80      	pop	{r7, pc}

341809d0 <BSP_LCD_InitEx>:
  * @param  Width       Display width
  * @param  Height      Display height
  * @retval BSP status
  */
int32_t BSP_LCD_InitEx(uint32_t Instance, uint32_t Orientation, uint32_t PixelFormat, uint32_t Width, uint32_t Height)
{
341809d0:	b580      	push	{r7, lr}
341809d2:	b08e      	sub	sp, #56	@ 0x38
341809d4:	af00      	add	r7, sp, #0
341809d6:	60f8      	str	r0, [r7, #12]
341809d8:	60b9      	str	r1, [r7, #8]
341809da:	607a      	str	r2, [r7, #4]
341809dc:	603b      	str	r3, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
341809de:	2300      	movs	r3, #0
341809e0:	637b      	str	r3, [r7, #52]	@ 0x34
  uint32_t ltdc_pixel_format;
  MX_LTDC_LayerConfig_t config = {0};
341809e2:	f107 0318 	add.w	r3, r7, #24
341809e6:	2200      	movs	r2, #0
341809e8:	601a      	str	r2, [r3, #0]
341809ea:	605a      	str	r2, [r3, #4]
341809ec:	609a      	str	r2, [r3, #8]
341809ee:	60da      	str	r2, [r3, #12]
341809f0:	611a      	str	r2, [r3, #16]
341809f2:	615a      	str	r2, [r3, #20]

  if ((Orientation > LCD_ORIENTATION_LANDSCAPE) || (Instance >= LCD_INSTANCES_NBR) || \
341809f4:	68bb      	ldr	r3, [r7, #8]
341809f6:	2b01      	cmp	r3, #1
341809f8:	d80e      	bhi.n	34180a18 <BSP_LCD_InitEx+0x48>
341809fa:	68fb      	ldr	r3, [r7, #12]
341809fc:	2b00      	cmp	r3, #0
341809fe:	d10b      	bne.n	34180a18 <BSP_LCD_InitEx+0x48>
34180a00:	687b      	ldr	r3, [r7, #4]
34180a02:	2b02      	cmp	r3, #2
34180a04:	d00c      	beq.n	34180a20 <BSP_LCD_InitEx+0x50>
     ((PixelFormat != LCD_PIXEL_FORMAT_RGB565) && (PixelFormat != LCD_PIXEL_FORMAT_RGB888) && \
34180a06:	687b      	ldr	r3, [r7, #4]
34180a08:	2b01      	cmp	r3, #1
34180a0a:	d009      	beq.n	34180a20 <BSP_LCD_InitEx+0x50>
34180a0c:	687b      	ldr	r3, [r7, #4]
34180a0e:	2b00      	cmp	r3, #0
34180a10:	d006      	beq.n	34180a20 <BSP_LCD_InitEx+0x50>
      (PixelFormat != LCD_PIXEL_FORMAT_ARGB8888) &&  (PixelFormat != LCD_PIXEL_FORMAT_ARGB4444)))
34180a12:	687b      	ldr	r3, [r7, #4]
34180a14:	2b04      	cmp	r3, #4
34180a16:	d003      	beq.n	34180a20 <BSP_LCD_InitEx+0x50>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34180a18:	f06f 0301 	mvn.w	r3, #1
34180a1c:	637b      	str	r3, [r7, #52]	@ 0x34
34180a1e:	e088      	b.n	34180b32 <BSP_LCD_InitEx+0x162>
  }
  else
  {
    if (PixelFormat == LCD_PIXEL_FORMAT_RGB565)
34180a20:	687b      	ldr	r3, [r7, #4]
34180a22:	2b02      	cmp	r3, #2
34180a24:	d109      	bne.n	34180a3a <BSP_LCD_InitEx+0x6a>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_RGB565;
34180a26:	2304      	movs	r3, #4
34180a28:	633b      	str	r3, [r7, #48]	@ 0x30
      Lcd_Ctx[Instance].BppFactor = 2U;
34180a2a:	4a5a      	ldr	r2, [pc, #360]	@ (34180b94 <BSP_LCD_InitEx+0x1c4>)
34180a2c:	68fb      	ldr	r3, [r7, #12]
34180a2e:	015b      	lsls	r3, r3, #5
34180a30:	4413      	add	r3, r2
34180a32:	3310      	adds	r3, #16
34180a34:	2202      	movs	r2, #2
34180a36:	601a      	str	r2, [r3, #0]
34180a38:	e022      	b.n	34180a80 <BSP_LCD_InitEx+0xb0>
    }
    else if  (PixelFormat == LCD_PIXEL_FORMAT_RGB888)
34180a3a:	687b      	ldr	r3, [r7, #4]
34180a3c:	2b01      	cmp	r3, #1
34180a3e:	d109      	bne.n	34180a54 <BSP_LCD_InitEx+0x84>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_RGB888;
34180a40:	2306      	movs	r3, #6
34180a42:	633b      	str	r3, [r7, #48]	@ 0x30
      Lcd_Ctx[Instance].BppFactor = 3U;
34180a44:	4a53      	ldr	r2, [pc, #332]	@ (34180b94 <BSP_LCD_InitEx+0x1c4>)
34180a46:	68fb      	ldr	r3, [r7, #12]
34180a48:	015b      	lsls	r3, r3, #5
34180a4a:	4413      	add	r3, r2
34180a4c:	3310      	adds	r3, #16
34180a4e:	2203      	movs	r2, #3
34180a50:	601a      	str	r2, [r3, #0]
34180a52:	e015      	b.n	34180a80 <BSP_LCD_InitEx+0xb0>
    }
    else if  (PixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
34180a54:	687b      	ldr	r3, [r7, #4]
34180a56:	2b04      	cmp	r3, #4
34180a58:	d109      	bne.n	34180a6e <BSP_LCD_InitEx+0x9e>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_ARGB4444;
34180a5a:	2308      	movs	r3, #8
34180a5c:	633b      	str	r3, [r7, #48]	@ 0x30
      Lcd_Ctx[Instance].BppFactor = 2U;
34180a5e:	4a4d      	ldr	r2, [pc, #308]	@ (34180b94 <BSP_LCD_InitEx+0x1c4>)
34180a60:	68fb      	ldr	r3, [r7, #12]
34180a62:	015b      	lsls	r3, r3, #5
34180a64:	4413      	add	r3, r2
34180a66:	3310      	adds	r3, #16
34180a68:	2202      	movs	r2, #2
34180a6a:	601a      	str	r2, [r3, #0]
34180a6c:	e008      	b.n	34180a80 <BSP_LCD_InitEx+0xb0>
    }
    else /* LCD_PIXEL_FORMAT_ARGB8888 */
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_ARGB8888;
34180a6e:	2300      	movs	r3, #0
34180a70:	633b      	str	r3, [r7, #48]	@ 0x30
      Lcd_Ctx[Instance].BppFactor = 4U;
34180a72:	4a48      	ldr	r2, [pc, #288]	@ (34180b94 <BSP_LCD_InitEx+0x1c4>)
34180a74:	68fb      	ldr	r3, [r7, #12]
34180a76:	015b      	lsls	r3, r3, #5
34180a78:	4413      	add	r3, r2
34180a7a:	3310      	adds	r3, #16
34180a7c:	2204      	movs	r2, #4
34180a7e:	601a      	str	r2, [r3, #0]
    }

    /* Store pixel format, xsize and ysize information */
    Lcd_Ctx[Instance].PixelFormat = PixelFormat;
34180a80:	4a44      	ldr	r2, [pc, #272]	@ (34180b94 <BSP_LCD_InitEx+0x1c4>)
34180a82:	68fb      	ldr	r3, [r7, #12]
34180a84:	015b      	lsls	r3, r3, #5
34180a86:	4413      	add	r3, r2
34180a88:	330c      	adds	r3, #12
34180a8a:	687a      	ldr	r2, [r7, #4]
34180a8c:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].XSize  = Width;
34180a8e:	4a41      	ldr	r2, [pc, #260]	@ (34180b94 <BSP_LCD_InitEx+0x1c4>)
34180a90:	68fb      	ldr	r3, [r7, #12]
34180a92:	015b      	lsls	r3, r3, #5
34180a94:	4413      	add	r3, r2
34180a96:	683a      	ldr	r2, [r7, #0]
34180a98:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].YSize  = Height;
34180a9a:	4a3e      	ldr	r2, [pc, #248]	@ (34180b94 <BSP_LCD_InitEx+0x1c4>)
34180a9c:	68fb      	ldr	r3, [r7, #12]
34180a9e:	015b      	lsls	r3, r3, #5
34180aa0:	4413      	add	r3, r2
34180aa2:	3304      	adds	r3, #4
34180aa4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34180aa6:	601a      	str	r2, [r3, #0]

    /* Initializes peripherals instance value */
    hlcd_ltdc.Instance = LTDC;
34180aa8:	4b3b      	ldr	r3, [pc, #236]	@ (34180b98 <BSP_LCD_InitEx+0x1c8>)
34180aaa:	4a3c      	ldr	r2, [pc, #240]	@ (34180b9c <BSP_LCD_InitEx+0x1cc>)
34180aac:	601a      	str	r2, [r3, #0]
    hlcd_dma2d.Instance = DMA2D;
34180aae:	4b3c      	ldr	r3, [pc, #240]	@ (34180ba0 <BSP_LCD_InitEx+0x1d0>)
34180ab0:	4a3c      	ldr	r2, [pc, #240]	@ (34180ba4 <BSP_LCD_InitEx+0x1d4>)
34180ab2:	601a      	str	r2, [r3, #0]
      {
        return BSP_ERROR_PERIPH_FAILURE;
      }
    }
#else
    LTDC_MspInit(&hlcd_ltdc);
34180ab4:	4838      	ldr	r0, [pc, #224]	@ (34180b98 <BSP_LCD_InitEx+0x1c8>)
34180ab6:	f000 fe57 	bl	34181768 <LTDC_MspInit>
#endif /* (USE_HAL_LTDC_REGISTER_CALLBACKS == 1) */

    DMA2D_MspInit(&hlcd_dma2d);
34180aba:	4839      	ldr	r0, [pc, #228]	@ (34180ba0 <BSP_LCD_InitEx+0x1d0>)
34180abc:	f000 ff10 	bl	341818e0 <DMA2D_MspInit>

    if (MX_LTDC_ClockConfig(&hlcd_ltdc) != HAL_OK)
34180ac0:	4835      	ldr	r0, [pc, #212]	@ (34180b98 <BSP_LCD_InitEx+0x1c8>)
34180ac2:	f000 f90c 	bl	34180cde <MX_LTDC_ClockConfig>
34180ac6:	4603      	mov	r3, r0
34180ac8:	2b00      	cmp	r3, #0
34180aca:	d003      	beq.n	34180ad4 <BSP_LCD_InitEx+0x104>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34180acc:	f06f 0303 	mvn.w	r3, #3
34180ad0:	637b      	str	r3, [r7, #52]	@ 0x34
34180ad2:	e00a      	b.n	34180aea <BSP_LCD_InitEx+0x11a>
    }
    else
    {
      if (MX_LTDC_Init(&hlcd_ltdc, Width, Height) != HAL_OK)
34180ad4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34180ad6:	6839      	ldr	r1, [r7, #0]
34180ad8:	482f      	ldr	r0, [pc, #188]	@ (34180b98 <BSP_LCD_InitEx+0x1c8>)
34180ada:	f000 f86d 	bl	34180bb8 <MX_LTDC_Init>
34180ade:	4603      	mov	r3, r0
34180ae0:	2b00      	cmp	r3, #0
34180ae2:	d002      	beq.n	34180aea <BSP_LCD_InitEx+0x11a>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
34180ae4:	f06f 0303 	mvn.w	r3, #3
34180ae8:	637b      	str	r3, [r7, #52]	@ 0x34
      }
    }

    if (ret == BSP_ERROR_NONE)
34180aea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34180aec:	2b00      	cmp	r3, #0
34180aee:	d120      	bne.n	34180b32 <BSP_LCD_InitEx+0x162>
      else
      {
#endif /* DATA_IN_ExtRAM */
        /* Configure default LTDC Layer 0. This configuration can be override by calling
        BSP_LCD_ConfigLayer() at application level */
        config.X0          = 0;
34180af0:	2300      	movs	r3, #0
34180af2:	61bb      	str	r3, [r7, #24]
        config.X1          = Width;
34180af4:	683b      	ldr	r3, [r7, #0]
34180af6:	61fb      	str	r3, [r7, #28]
        config.Y0          = 0;
34180af8:	2300      	movs	r3, #0
34180afa:	623b      	str	r3, [r7, #32]
        config.Y1          = Height;
34180afc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34180afe:	627b      	str	r3, [r7, #36]	@ 0x24
        config.PixelFormat = ltdc_pixel_format;
34180b00:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34180b02:	62bb      	str	r3, [r7, #40]	@ 0x28
        config.Address     = LCD_LAYER_0_ADDRESS;
34180b04:	f04f 5350 	mov.w	r3, #872415232	@ 0x34000000
34180b08:	62fb      	str	r3, [r7, #44]	@ 0x2c

        if (MX_LTDC_ConfigLayer(&hlcd_ltdc, 0, &config) != HAL_OK)
34180b0a:	f107 0318 	add.w	r3, r7, #24
34180b0e:	461a      	mov	r2, r3
34180b10:	2100      	movs	r1, #0
34180b12:	4821      	ldr	r0, [pc, #132]	@ (34180b98 <BSP_LCD_InitEx+0x1c8>)
34180b14:	f000 f89a 	bl	34180c4c <MX_LTDC_ConfigLayer>
34180b18:	4603      	mov	r3, r0
34180b1a:	2b00      	cmp	r3, #0
34180b1c:	d002      	beq.n	34180b24 <BSP_LCD_InitEx+0x154>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
34180b1e:	f06f 0303 	mvn.w	r3, #3
34180b22:	637b      	str	r3, [r7, #52]	@ 0x34
        }

        /* By default the reload is activated and executed immediately */
        Lcd_Ctx[Instance].ReloadEnable = 1U;
34180b24:	4a1b      	ldr	r2, [pc, #108]	@ (34180b94 <BSP_LCD_InitEx+0x1c4>)
34180b26:	68fb      	ldr	r3, [r7, #12]
34180b28:	015b      	lsls	r3, r3, #5
34180b2a:	4413      	add	r3, r2
34180b2c:	3318      	adds	r3, #24
34180b2e:	2201      	movs	r2, #1
34180b30:	601a      	str	r2, [r3, #0]
      }
#endif /* DATA_IN_ExtRAM */
    }
  }

  RIMC_MasterConfig_t RIMC_master = {0};
34180b32:	f107 0310 	add.w	r3, r7, #16
34180b36:	2200      	movs	r2, #0
34180b38:	601a      	str	r2, [r3, #0]
34180b3a:	605a      	str	r2, [r3, #4]
  RIMC_master.MasterCID = RIF_CID_1;
34180b3c:	2302      	movs	r3, #2
34180b3e:	613b      	str	r3, [r7, #16]
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34180b40:	2303      	movs	r3, #3
34180b42:	617b      	str	r3, [r7, #20]

  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1 , &RIMC_master);
34180b44:	f107 0310 	add.w	r3, r7, #16
34180b48:	4619      	mov	r1, r3
34180b4a:	200a      	movs	r0, #10
34180b4c:	f008 f92a 	bl	34188da4 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC2 , &RIMC_master);
34180b50:	f107 0310 	add.w	r3, r7, #16
34180b54:	4619      	mov	r1, r3
34180b56:	200b      	movs	r0, #11
34180b58:	f008 f924 	bl	34188da4 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DMA2D, &RIMC_master);
34180b5c:	f107 0310 	add.w	r3, r7, #16
34180b60:	4619      	mov	r1, r3
34180b62:	2008      	movs	r0, #8
34180b64:	f008 f91e 	bl	34188da4 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL1 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34180b68:	2103      	movs	r1, #3
34180b6a:	480f      	ldr	r0, [pc, #60]	@ (34180ba8 <BSP_LCD_InitEx+0x1d8>)
34180b6c:	f008 f956 	bl	34188e1c <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL2 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34180b70:	2103      	movs	r1, #3
34180b72:	480e      	ldr	r0, [pc, #56]	@ (34180bac <BSP_LCD_InitEx+0x1dc>)
34180b74:	f008 f952 	bl	34188e1c <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DMA2D  , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34180b78:	2103      	movs	r1, #3
34180b7a:	480d      	ldr	r0, [pc, #52]	@ (34180bb0 <BSP_LCD_InitEx+0x1e0>)
34180b7c:	f008 f94e 	bl	34188e1c <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDC   , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34180b80:	2103      	movs	r1, #3
34180b82:	480c      	ldr	r0, [pc, #48]	@ (34180bb4 <BSP_LCD_InitEx+0x1e4>)
34180b84:	f008 f94a 	bl	34188e1c <HAL_RIF_RISC_SetSlaveSecureAttributes>


  return ret;
34180b88:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
34180b8a:	4618      	mov	r0, r3
34180b8c:	3738      	adds	r7, #56	@ 0x38
34180b8e:	46bd      	mov	sp, r7
34180b90:	bd80      	pop	{r7, pc}
34180b92:	bf00      	nop
34180b94:	341c015c 	.word	0x341c015c
34180b98:	341c00b4 	.word	0x341c00b4
34180b9c:	58001000 	.word	0x58001000
34180ba0:	341c004c 	.word	0x341c004c
34180ba4:	58021000 	.word	0x58021000
34180ba8:	30000007 	.word	0x30000007
34180bac:	30000008 	.word	0x30000008
34180bb0:	30000005 	.word	0x30000005
34180bb4:	30000006 	.word	0x30000006

34180bb8 <MX_LTDC_Init>:
  * @param  Width  LTDC width
  * @param  Height LTDC height
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_LTDC_Init(LTDC_HandleTypeDef *hltdc, uint32_t Width, uint32_t Height)
{
34180bb8:	b580      	push	{r7, lr}
34180bba:	b084      	sub	sp, #16
34180bbc:	af00      	add	r7, sp, #0
34180bbe:	60f8      	str	r0, [r7, #12]
34180bc0:	60b9      	str	r1, [r7, #8]
34180bc2:	607a      	str	r2, [r7, #4]
  hltdc->Instance = LTDC;
34180bc4:	68fb      	ldr	r3, [r7, #12]
34180bc6:	4a20      	ldr	r2, [pc, #128]	@ (34180c48 <MX_LTDC_Init+0x90>)
34180bc8:	601a      	str	r2, [r3, #0]
  hltdc->Init.HSPolarity = LTDC_HSPOLARITY_AL;
34180bca:	68fb      	ldr	r3, [r7, #12]
34180bcc:	2200      	movs	r2, #0
34180bce:	605a      	str	r2, [r3, #4]
  hltdc->Init.VSPolarity = LTDC_VSPOLARITY_AL;
34180bd0:	68fb      	ldr	r3, [r7, #12]
34180bd2:	2200      	movs	r2, #0
34180bd4:	609a      	str	r2, [r3, #8]
  hltdc->Init.DEPolarity = LTDC_DEPOLARITY_AL;
34180bd6:	68fb      	ldr	r3, [r7, #12]
34180bd8:	2200      	movs	r2, #0
34180bda:	60da      	str	r2, [r3, #12]
  hltdc->Init.PCPolarity = LTDC_PCPOLARITY_IPC;
34180bdc:	68fb      	ldr	r3, [r7, #12]
34180bde:	2200      	movs	r2, #0
34180be0:	611a      	str	r2, [r3, #16]

  hltdc->Init.HorizontalSync     = (uint32_t)RK050HR18_HSYNC - 1U;
34180be2:	68fb      	ldr	r3, [r7, #12]
34180be4:	2203      	movs	r2, #3
34180be6:	615a      	str	r2, [r3, #20]
  hltdc->Init.AccumulatedHBP     = (uint32_t)RK050HR18_HSYNC + (uint32_t)RK050HR18_HBP - 1U;
34180be8:	68fb      	ldr	r3, [r7, #12]
34180bea:	2207      	movs	r2, #7
34180bec:	61da      	str	r2, [r3, #28]
  hltdc->Init.AccumulatedActiveW = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP -1U;
34180bee:	68bb      	ldr	r3, [r7, #8]
34180bf0:	1dda      	adds	r2, r3, #7
34180bf2:	68fb      	ldr	r3, [r7, #12]
34180bf4:	625a      	str	r2, [r3, #36]	@ 0x24
  hltdc->Init.TotalWidth         = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP + RK050HR18_HFP - 1U;
34180bf6:	68bb      	ldr	r3, [r7, #8]
34180bf8:	f103 020b 	add.w	r2, r3, #11
34180bfc:	68fb      	ldr	r3, [r7, #12]
34180bfe:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Init.VerticalSync       = (uint32_t)RK050HR18_VSYNC - 1U;
34180c00:	68fb      	ldr	r3, [r7, #12]
34180c02:	2203      	movs	r2, #3
34180c04:	619a      	str	r2, [r3, #24]
  hltdc->Init.AccumulatedVBP     = (uint32_t)RK050HR18_VSYNC + (uint32_t)RK050HR18_VBP - 1U;
34180c06:	68fb      	ldr	r3, [r7, #12]
34180c08:	2207      	movs	r2, #7
34180c0a:	621a      	str	r2, [r3, #32]
  hltdc->Init.AccumulatedActiveH = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP -1U;
34180c0c:	687b      	ldr	r3, [r7, #4]
34180c0e:	1dda      	adds	r2, r3, #7
34180c10:	68fb      	ldr	r3, [r7, #12]
34180c12:	629a      	str	r2, [r3, #40]	@ 0x28
  hltdc->Init.TotalHeigh         = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP + RK050HR18_VFP - 1U;
34180c14:	687b      	ldr	r3, [r7, #4]
34180c16:	f103 020b 	add.w	r2, r3, #11
34180c1a:	68fb      	ldr	r3, [r7, #12]
34180c1c:	631a      	str	r2, [r3, #48]	@ 0x30

  hltdc->Init.Backcolor.Blue  = 0x0;
34180c1e:	68fb      	ldr	r3, [r7, #12]
34180c20:	2200      	movs	r2, #0
34180c22:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  hltdc->Init.Backcolor.Green = 0x0;
34180c26:	68fb      	ldr	r3, [r7, #12]
34180c28:	2200      	movs	r2, #0
34180c2a:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
  hltdc->Init.Backcolor.Red   = 0x0;
34180c2e:	68fb      	ldr	r3, [r7, #12]
34180c30:	2200      	movs	r2, #0
34180c32:	f883 2036 	strb.w	r2, [r3, #54]	@ 0x36

  return HAL_LTDC_Init(hltdc);
34180c36:	68f8      	ldr	r0, [r7, #12]
34180c38:	f002 f888 	bl	34182d4c <HAL_LTDC_Init>
34180c3c:	4603      	mov	r3, r0
}
34180c3e:	4618      	mov	r0, r3
34180c40:	3710      	adds	r7, #16
34180c42:	46bd      	mov	sp, r7
34180c44:	bd80      	pop	{r7, pc}
34180c46:	bf00      	nop
34180c48:	58001000 	.word	0x58001000

34180c4c <MX_LTDC_ConfigLayer>:
  * @param  LayerIndex Layer 0 or 1
  * @param  Config     Layer configuration
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, uint32_t LayerIndex, MX_LTDC_LayerConfig_t *Config)
{
34180c4c:	b580      	push	{r7, lr}
34180c4e:	b092      	sub	sp, #72	@ 0x48
34180c50:	af00      	add	r7, sp, #0
34180c52:	60f8      	str	r0, [r7, #12]
34180c54:	60b9      	str	r1, [r7, #8]
34180c56:	607a      	str	r2, [r7, #4]
  LTDC_LayerCfgTypeDef pLayerCfg ={0};
34180c58:	f107 0314 	add.w	r3, r7, #20
34180c5c:	2234      	movs	r2, #52	@ 0x34
34180c5e:	2100      	movs	r1, #0
34180c60:	4618      	mov	r0, r3
34180c62:	f008 fe1b 	bl	3418989c <memset>

  pLayerCfg.WindowX0 = Config->X0;
34180c66:	687b      	ldr	r3, [r7, #4]
34180c68:	681b      	ldr	r3, [r3, #0]
34180c6a:	617b      	str	r3, [r7, #20]
  pLayerCfg.WindowX1 = Config->X1;
34180c6c:	687b      	ldr	r3, [r7, #4]
34180c6e:	685b      	ldr	r3, [r3, #4]
34180c70:	61bb      	str	r3, [r7, #24]
  pLayerCfg.WindowY0 = Config->Y0;
34180c72:	687b      	ldr	r3, [r7, #4]
34180c74:	689b      	ldr	r3, [r3, #8]
34180c76:	61fb      	str	r3, [r7, #28]
  pLayerCfg.WindowY1 = Config->Y1;
34180c78:	687b      	ldr	r3, [r7, #4]
34180c7a:	68db      	ldr	r3, [r3, #12]
34180c7c:	623b      	str	r3, [r7, #32]
  pLayerCfg.PixelFormat = Config->PixelFormat;
34180c7e:	687b      	ldr	r3, [r7, #4]
34180c80:	691b      	ldr	r3, [r3, #16]
34180c82:	627b      	str	r3, [r7, #36]	@ 0x24
  pLayerCfg.Alpha = LTDC_LxCACR_CONSTA;
34180c84:	23ff      	movs	r3, #255	@ 0xff
34180c86:	62bb      	str	r3, [r7, #40]	@ 0x28
  pLayerCfg.Alpha0 = 0;
34180c88:	2300      	movs	r3, #0
34180c8a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
34180c8c:	f44f 63c0 	mov.w	r3, #1536	@ 0x600
34180c90:	633b      	str	r3, [r7, #48]	@ 0x30
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
34180c92:	2307      	movs	r3, #7
34180c94:	637b      	str	r3, [r7, #52]	@ 0x34
  pLayerCfg.FBStartAdress = Config->Address;
34180c96:	687b      	ldr	r3, [r7, #4]
34180c98:	695b      	ldr	r3, [r3, #20]
34180c9a:	63bb      	str	r3, [r7, #56]	@ 0x38
  pLayerCfg.ImageWidth = (Config->X1 - Config->X0);
34180c9c:	687b      	ldr	r3, [r7, #4]
34180c9e:	685a      	ldr	r2, [r3, #4]
34180ca0:	687b      	ldr	r3, [r7, #4]
34180ca2:	681b      	ldr	r3, [r3, #0]
34180ca4:	1ad3      	subs	r3, r2, r3
34180ca6:	63fb      	str	r3, [r7, #60]	@ 0x3c
  pLayerCfg.ImageHeight = (Config->Y1 - Config->Y0);
34180ca8:	687b      	ldr	r3, [r7, #4]
34180caa:	68da      	ldr	r2, [r3, #12]
34180cac:	687b      	ldr	r3, [r7, #4]
34180cae:	689b      	ldr	r3, [r3, #8]
34180cb0:	1ad3      	subs	r3, r2, r3
34180cb2:	643b      	str	r3, [r7, #64]	@ 0x40
  pLayerCfg.Backcolor.Blue = 0;
34180cb4:	2300      	movs	r3, #0
34180cb6:	f887 3044 	strb.w	r3, [r7, #68]	@ 0x44
  pLayerCfg.Backcolor.Green = 0;
34180cba:	2300      	movs	r3, #0
34180cbc:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
  pLayerCfg.Backcolor.Red = 0;
34180cc0:	2300      	movs	r3, #0
34180cc2:	f887 3046 	strb.w	r3, [r7, #70]	@ 0x46
  return HAL_LTDC_ConfigLayer(hltdc, &pLayerCfg, LayerIndex);
34180cc6:	f107 0314 	add.w	r3, r7, #20
34180cca:	68ba      	ldr	r2, [r7, #8]
34180ccc:	4619      	mov	r1, r3
34180cce:	68f8      	ldr	r0, [r7, #12]
34180cd0:	f002 f8f1 	bl	34182eb6 <HAL_LTDC_ConfigLayer>
34180cd4:	4603      	mov	r3, r0
}
34180cd6:	4618      	mov	r0, r3
34180cd8:	3748      	adds	r7, #72	@ 0x48
34180cda:	46bd      	mov	sp, r7
34180cdc:	bd80      	pop	{r7, pc}

34180cde <MX_LTDC_ClockConfig>:
  * @param  hltdc  LTDC Handle
  *         Being __weak it can be overwritten by the application
  * @retval HAL_status
  */
__weak HAL_StatusTypeDef MX_LTDC_ClockConfig(LTDC_HandleTypeDef *hltdc)
{
34180cde:	b580      	push	{r7, lr}
34180ce0:	b0e8      	sub	sp, #416	@ 0x1a0
34180ce2:	af00      	add	r7, sp, #0
34180ce4:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34180ce8:	f5a3 73ce 	sub.w	r3, r3, #412	@ 0x19c
34180cec:	6018      	str	r0, [r3, #0]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hltdc);

  HAL_StatusTypeDef   status =  HAL_OK;
34180cee:	2300      	movs	r3, #0
34180cf0:	f887 319f 	strb.w	r3, [r7, #415]	@ 0x19f
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
34180cf4:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34180cf8:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
34180cfc:	4618      	mov	r0, r3
34180cfe:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34180d02:	461a      	mov	r2, r3
34180d04:	2100      	movs	r1, #0
34180d06:	f008 fdc9 	bl	3418989c <memset>
  /* PLL3_VCO Input = HSE_VALUE/PLLM = 48 Mhz / 192 = 0.25 */
  /* PLL3_VCO Output = PLL3_VCO Input * PLLN = 0.25 Mhz * 100 = 25 */
  /* PLLLCDCLK = PLL3_VCO Output/(PLLP1 * PLLP2) = 25/1 = 25Mhz */
  /* LTDC clock frequency = PLLLCDCLK = 25 Mhz */

  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
34180d0a:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34180d0e:	f5a3 71cc 	sub.w	r1, r3, #408	@ 0x198
34180d12:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34180d16:	f04f 0300 	mov.w	r3, #0
34180d1a:	e9c1 2300 	strd	r2, r3, [r1]
  RCC_PeriphCLKInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
34180d1e:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34180d22:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
34180d26:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34180d2a:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockSelection = RCC_ICCLKSOURCE_PLL1;
34180d2e:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34180d32:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
34180d36:	2200      	movs	r2, #0
34180d38:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 48;
34180d3c:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34180d40:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
34180d44:	2230      	movs	r2, #48	@ 0x30
34180d46:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34180d4a:	f107 0308 	add.w	r3, r7, #8
34180d4e:	4618      	mov	r0, r3
34180d50:	f005 fb82 	bl	34186458 <HAL_RCCEx_PeriphCLKConfig>
34180d54:	4603      	mov	r3, r0
34180d56:	2b00      	cmp	r3, #0
34180d58:	d002      	beq.n	34180d60 <MX_LTDC_ClockConfig+0x82>
  {
    status = HAL_ERROR;
34180d5a:	2301      	movs	r3, #1
34180d5c:	f887 319f 	strb.w	r3, [r7, #415]	@ 0x19f
  }

  return status;
34180d60:	f897 319f 	ldrb.w	r3, [r7, #415]	@ 0x19f
}
34180d64:	4618      	mov	r0, r3
34180d66:	f507 77d0 	add.w	r7, r7, #416	@ 0x1a0
34180d6a:	46bd      	mov	sp, r7
34180d6c:	bd80      	pop	{r7, pc}
	...

34180d70 <BSP_LCD_GetPixelFormat>:
  * @param  Instance    LCD Instance
  * @param  PixelFormat Active LCD Pixel Format
  * @retval BSP status
  */
int32_t BSP_LCD_GetPixelFormat(uint32_t Instance, uint32_t *PixelFormat)
{
34180d70:	b480      	push	{r7}
34180d72:	b085      	sub	sp, #20
34180d74:	af00      	add	r7, sp, #0
34180d76:	6078      	str	r0, [r7, #4]
34180d78:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34180d7a:	2300      	movs	r3, #0
34180d7c:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
34180d7e:	687b      	ldr	r3, [r7, #4]
34180d80:	2b00      	cmp	r3, #0
34180d82:	d003      	beq.n	34180d8c <BSP_LCD_GetPixelFormat+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34180d84:	f06f 0301 	mvn.w	r3, #1
34180d88:	60fb      	str	r3, [r7, #12]
34180d8a:	e007      	b.n	34180d9c <BSP_LCD_GetPixelFormat+0x2c>
  }
  else
  {
    /* Only RGB565 format is supported */
    *PixelFormat =  Lcd_Ctx[Instance].PixelFormat;
34180d8c:	4a07      	ldr	r2, [pc, #28]	@ (34180dac <BSP_LCD_GetPixelFormat+0x3c>)
34180d8e:	687b      	ldr	r3, [r7, #4]
34180d90:	015b      	lsls	r3, r3, #5
34180d92:	4413      	add	r3, r2
34180d94:	330c      	adds	r3, #12
34180d96:	681a      	ldr	r2, [r3, #0]
34180d98:	683b      	ldr	r3, [r7, #0]
34180d9a:	601a      	str	r2, [r3, #0]
  }

  return ret;
34180d9c:	68fb      	ldr	r3, [r7, #12]
}
34180d9e:	4618      	mov	r0, r3
34180da0:	3714      	adds	r7, #20
34180da2:	46bd      	mov	sp, r7
34180da4:	f85d 7b04 	ldr.w	r7, [sp], #4
34180da8:	4770      	bx	lr
34180daa:	bf00      	nop
34180dac:	341c015c 	.word	0x341c015c

34180db0 <BSP_LCD_SetActiveLayer>:
  * @param  Instance    LCD Instance
  * @param  LayerIndex  LCD layer index
  * @retval BSP status
  */
int32_t BSP_LCD_SetActiveLayer(uint32_t Instance, uint32_t LayerIndex)
{
34180db0:	b480      	push	{r7}
34180db2:	b085      	sub	sp, #20
34180db4:	af00      	add	r7, sp, #0
34180db6:	6078      	str	r0, [r7, #4]
34180db8:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34180dba:	2300      	movs	r3, #0
34180dbc:	60fb      	str	r3, [r7, #12]
  LTDC_LayerCfgTypeDef *pLayerCfg;

  if(Instance >= LCD_INSTANCES_NBR)
34180dbe:	687b      	ldr	r3, [r7, #4]
34180dc0:	2b00      	cmp	r3, #0
34180dc2:	d003      	beq.n	34180dcc <BSP_LCD_SetActiveLayer+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34180dc4:	f06f 0301 	mvn.w	r3, #1
34180dc8:	60fb      	str	r3, [r7, #12]
34180dca:	e064      	b.n	34180e96 <BSP_LCD_SetActiveLayer+0xe6>
  }
  else
  {
    pLayerCfg = &hlcd_ltdc.LayerCfg[LayerIndex];
34180dcc:	683b      	ldr	r3, [r7, #0]
34180dce:	2234      	movs	r2, #52	@ 0x34
34180dd0:	fb02 f303 	mul.w	r3, r2, r3
34180dd4:	3338      	adds	r3, #56	@ 0x38
34180dd6:	4a33      	ldr	r2, [pc, #204]	@ (34180ea4 <BSP_LCD_SetActiveLayer+0xf4>)
34180dd8:	4413      	add	r3, r2
34180dda:	60bb      	str	r3, [r7, #8]

    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
34180ddc:	4a32      	ldr	r2, [pc, #200]	@ (34180ea8 <BSP_LCD_SetActiveLayer+0xf8>)
34180dde:	687b      	ldr	r3, [r7, #4]
34180de0:	015b      	lsls	r3, r3, #5
34180de2:	4413      	add	r3, r2
34180de4:	3308      	adds	r3, #8
34180de6:	683a      	ldr	r2, [r7, #0]
34180de8:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].XSize = pLayerCfg->ImageWidth;
34180dea:	68bb      	ldr	r3, [r7, #8]
34180dec:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34180dee:	492e      	ldr	r1, [pc, #184]	@ (34180ea8 <BSP_LCD_SetActiveLayer+0xf8>)
34180df0:	687b      	ldr	r3, [r7, #4]
34180df2:	015b      	lsls	r3, r3, #5
34180df4:	440b      	add	r3, r1
34180df6:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].YSize = pLayerCfg->ImageHeight;
34180df8:	68bb      	ldr	r3, [r7, #8]
34180dfa:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34180dfc:	492a      	ldr	r1, [pc, #168]	@ (34180ea8 <BSP_LCD_SetActiveLayer+0xf8>)
34180dfe:	687b      	ldr	r3, [r7, #4]
34180e00:	015b      	lsls	r3, r3, #5
34180e02:	440b      	add	r3, r1
34180e04:	3304      	adds	r3, #4
34180e06:	601a      	str	r2, [r3, #0]

    if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_RGB565)
34180e08:	68bb      	ldr	r3, [r7, #8]
34180e0a:	691b      	ldr	r3, [r3, #16]
34180e0c:	2b04      	cmp	r3, #4
34180e0e:	d10e      	bne.n	34180e2e <BSP_LCD_SetActiveLayer+0x7e>
    {
      Lcd_Ctx[Instance].BppFactor = 2;
34180e10:	4a25      	ldr	r2, [pc, #148]	@ (34180ea8 <BSP_LCD_SetActiveLayer+0xf8>)
34180e12:	687b      	ldr	r3, [r7, #4]
34180e14:	015b      	lsls	r3, r3, #5
34180e16:	4413      	add	r3, r2
34180e18:	3310      	adds	r3, #16
34180e1a:	2202      	movs	r2, #2
34180e1c:	601a      	str	r2, [r3, #0]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_RGB565;
34180e1e:	4a22      	ldr	r2, [pc, #136]	@ (34180ea8 <BSP_LCD_SetActiveLayer+0xf8>)
34180e20:	687b      	ldr	r3, [r7, #4]
34180e22:	015b      	lsls	r3, r3, #5
34180e24:	4413      	add	r3, r2
34180e26:	330c      	adds	r3, #12
34180e28:	2202      	movs	r2, #2
34180e2a:	601a      	str	r2, [r3, #0]
34180e2c:	e033      	b.n	34180e96 <BSP_LCD_SetActiveLayer+0xe6>
    }
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_ARGB4444)
34180e2e:	68bb      	ldr	r3, [r7, #8]
34180e30:	691b      	ldr	r3, [r3, #16]
34180e32:	2b08      	cmp	r3, #8
34180e34:	d10e      	bne.n	34180e54 <BSP_LCD_SetActiveLayer+0xa4>
    {
      Lcd_Ctx[Instance].BppFactor = 2;
34180e36:	4a1c      	ldr	r2, [pc, #112]	@ (34180ea8 <BSP_LCD_SetActiveLayer+0xf8>)
34180e38:	687b      	ldr	r3, [r7, #4]
34180e3a:	015b      	lsls	r3, r3, #5
34180e3c:	4413      	add	r3, r2
34180e3e:	3310      	adds	r3, #16
34180e40:	2202      	movs	r2, #2
34180e42:	601a      	str	r2, [r3, #0]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
34180e44:	4a18      	ldr	r2, [pc, #96]	@ (34180ea8 <BSP_LCD_SetActiveLayer+0xf8>)
34180e46:	687b      	ldr	r3, [r7, #4]
34180e48:	015b      	lsls	r3, r3, #5
34180e4a:	4413      	add	r3, r2
34180e4c:	330c      	adds	r3, #12
34180e4e:	2204      	movs	r2, #4
34180e50:	601a      	str	r2, [r3, #0]
34180e52:	e020      	b.n	34180e96 <BSP_LCD_SetActiveLayer+0xe6>
    }
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_RGB888)
34180e54:	68bb      	ldr	r3, [r7, #8]
34180e56:	691b      	ldr	r3, [r3, #16]
34180e58:	2b06      	cmp	r3, #6
34180e5a:	d10e      	bne.n	34180e7a <BSP_LCD_SetActiveLayer+0xca>
    {
      Lcd_Ctx[Instance].BppFactor = 3;
34180e5c:	4a12      	ldr	r2, [pc, #72]	@ (34180ea8 <BSP_LCD_SetActiveLayer+0xf8>)
34180e5e:	687b      	ldr	r3, [r7, #4]
34180e60:	015b      	lsls	r3, r3, #5
34180e62:	4413      	add	r3, r2
34180e64:	3310      	adds	r3, #16
34180e66:	2203      	movs	r2, #3
34180e68:	601a      	str	r2, [r3, #0]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_RGB888;
34180e6a:	4a0f      	ldr	r2, [pc, #60]	@ (34180ea8 <BSP_LCD_SetActiveLayer+0xf8>)
34180e6c:	687b      	ldr	r3, [r7, #4]
34180e6e:	015b      	lsls	r3, r3, #5
34180e70:	4413      	add	r3, r2
34180e72:	330c      	adds	r3, #12
34180e74:	2201      	movs	r2, #1
34180e76:	601a      	str	r2, [r3, #0]
34180e78:	e00d      	b.n	34180e96 <BSP_LCD_SetActiveLayer+0xe6>
    }
    else
    {
      Lcd_Ctx[Instance].BppFactor = 4;
34180e7a:	4a0b      	ldr	r2, [pc, #44]	@ (34180ea8 <BSP_LCD_SetActiveLayer+0xf8>)
34180e7c:	687b      	ldr	r3, [r7, #4]
34180e7e:	015b      	lsls	r3, r3, #5
34180e80:	4413      	add	r3, r2
34180e82:	3310      	adds	r3, #16
34180e84:	2204      	movs	r2, #4
34180e86:	601a      	str	r2, [r3, #0]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB8888;
34180e88:	4a07      	ldr	r2, [pc, #28]	@ (34180ea8 <BSP_LCD_SetActiveLayer+0xf8>)
34180e8a:	687b      	ldr	r3, [r7, #4]
34180e8c:	015b      	lsls	r3, r3, #5
34180e8e:	4413      	add	r3, r2
34180e90:	330c      	adds	r3, #12
34180e92:	2200      	movs	r2, #0
34180e94:	601a      	str	r2, [r3, #0]
    }
  }

  return ret;
34180e96:	68fb      	ldr	r3, [r7, #12]
}
34180e98:	4618      	mov	r0, r3
34180e9a:	3714      	adds	r7, #20
34180e9c:	46bd      	mov	sp, r7
34180e9e:	f85d 7b04 	ldr.w	r7, [sp], #4
34180ea2:	4770      	bx	lr
34180ea4:	341c00b4 	.word	0x341c00b4
34180ea8:	341c015c 	.word	0x341c015c

34180eac <BSP_LCD_GetXSize>:
  * @param  Instance  LCD Instance
  * @param  XSize     LCD width
  * @retval BSP status
  */
int32_t BSP_LCD_GetXSize(uint32_t Instance, uint32_t *XSize)
{
34180eac:	b480      	push	{r7}
34180eae:	b085      	sub	sp, #20
34180eb0:	af00      	add	r7, sp, #0
34180eb2:	6078      	str	r0, [r7, #4]
34180eb4:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34180eb6:	2300      	movs	r3, #0
34180eb8:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
34180eba:	687b      	ldr	r3, [r7, #4]
34180ebc:	2b00      	cmp	r3, #0
34180ebe:	d003      	beq.n	34180ec8 <BSP_LCD_GetXSize+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34180ec0:	f06f 0301 	mvn.w	r3, #1
34180ec4:	60fb      	str	r3, [r7, #12]
34180ec6:	e006      	b.n	34180ed6 <BSP_LCD_GetXSize+0x2a>
  }
  else
  {
    *XSize = Lcd_Ctx[Instance].XSize;
34180ec8:	4a06      	ldr	r2, [pc, #24]	@ (34180ee4 <BSP_LCD_GetXSize+0x38>)
34180eca:	687b      	ldr	r3, [r7, #4]
34180ecc:	015b      	lsls	r3, r3, #5
34180ece:	4413      	add	r3, r2
34180ed0:	681a      	ldr	r2, [r3, #0]
34180ed2:	683b      	ldr	r3, [r7, #0]
34180ed4:	601a      	str	r2, [r3, #0]
  }

  return ret;
34180ed6:	68fb      	ldr	r3, [r7, #12]
}
34180ed8:	4618      	mov	r0, r3
34180eda:	3714      	adds	r7, #20
34180edc:	46bd      	mov	sp, r7
34180ede:	f85d 7b04 	ldr.w	r7, [sp], #4
34180ee2:	4770      	bx	lr
34180ee4:	341c015c 	.word	0x341c015c

34180ee8 <BSP_LCD_GetYSize>:
  * @param  Instance  LCD Instance
  * @param  YSize     LCD Height
  * @retval BSP status
  */
int32_t BSP_LCD_GetYSize(uint32_t Instance, uint32_t *YSize)
{
34180ee8:	b480      	push	{r7}
34180eea:	b085      	sub	sp, #20
34180eec:	af00      	add	r7, sp, #0
34180eee:	6078      	str	r0, [r7, #4]
34180ef0:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34180ef2:	2300      	movs	r3, #0
34180ef4:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
34180ef6:	687b      	ldr	r3, [r7, #4]
34180ef8:	2b00      	cmp	r3, #0
34180efa:	d003      	beq.n	34180f04 <BSP_LCD_GetYSize+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34180efc:	f06f 0301 	mvn.w	r3, #1
34180f00:	60fb      	str	r3, [r7, #12]
34180f02:	e007      	b.n	34180f14 <BSP_LCD_GetYSize+0x2c>
  }
  else
  {
    *YSize = Lcd_Ctx[Instance].YSize;
34180f04:	4a07      	ldr	r2, [pc, #28]	@ (34180f24 <BSP_LCD_GetYSize+0x3c>)
34180f06:	687b      	ldr	r3, [r7, #4]
34180f08:	015b      	lsls	r3, r3, #5
34180f0a:	4413      	add	r3, r2
34180f0c:	3304      	adds	r3, #4
34180f0e:	681a      	ldr	r2, [r3, #0]
34180f10:	683b      	ldr	r3, [r7, #0]
34180f12:	601a      	str	r2, [r3, #0]
  }

  return ret;
34180f14:	68fb      	ldr	r3, [r7, #12]
}
34180f16:	4618      	mov	r0, r3
34180f18:	3714      	adds	r7, #20
34180f1a:	46bd      	mov	sp, r7
34180f1c:	f85d 7b04 	ldr.w	r7, [sp], #4
34180f20:	4770      	bx	lr
34180f22:	bf00      	nop
34180f24:	341c015c 	.word	0x341c015c

34180f28 <BSP_LCD_DrawBitmap>:
  * @param  Ypos Bmp Y position in the LCD
  * @param  pBmp Pointer to Bmp picture address in the internal Flash.
  * @retval BSP status
  */
int32_t BSP_LCD_DrawBitmap(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint8_t *pBmp)
{
34180f28:	b580      	push	{r7, lr}
34180f2a:	b08e      	sub	sp, #56	@ 0x38
34180f2c:	af02      	add	r7, sp, #8
34180f2e:	60f8      	str	r0, [r7, #12]
34180f30:	60b9      	str	r1, [r7, #8]
34180f32:	607a      	str	r2, [r7, #4]
34180f34:	603b      	str	r3, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34180f36:	2300      	movs	r3, #0
34180f38:	61fb      	str	r3, [r7, #28]
  uint32_t Address;
  uint32_t input_color_mode;
  uint8_t *pbmp;

  /* Get bitmap data address offset */
  index = (uint32_t)pBmp[10] + ((uint32_t)pBmp[11] << 8) + ((uint32_t)pBmp[12] << 16)  + ((uint32_t)pBmp[13] << 24);
34180f3a:	683b      	ldr	r3, [r7, #0]
34180f3c:	330a      	adds	r3, #10
34180f3e:	781b      	ldrb	r3, [r3, #0]
34180f40:	461a      	mov	r2, r3
34180f42:	683b      	ldr	r3, [r7, #0]
34180f44:	330b      	adds	r3, #11
34180f46:	781b      	ldrb	r3, [r3, #0]
34180f48:	021b      	lsls	r3, r3, #8
34180f4a:	441a      	add	r2, r3
34180f4c:	683b      	ldr	r3, [r7, #0]
34180f4e:	330c      	adds	r3, #12
34180f50:	781b      	ldrb	r3, [r3, #0]
34180f52:	041b      	lsls	r3, r3, #16
34180f54:	441a      	add	r2, r3
34180f56:	683b      	ldr	r3, [r7, #0]
34180f58:	330d      	adds	r3, #13
34180f5a:	781b      	ldrb	r3, [r3, #0]
34180f5c:	061b      	lsls	r3, r3, #24
34180f5e:	4413      	add	r3, r2
34180f60:	62fb      	str	r3, [r7, #44]	@ 0x2c

  /* Read bitmap width */
  width = (uint32_t)pBmp[18] + ((uint32_t)pBmp[19] << 8) + ((uint32_t)pBmp[20] << 16)  + ((uint32_t)pBmp[21] << 24);
34180f62:	683b      	ldr	r3, [r7, #0]
34180f64:	3312      	adds	r3, #18
34180f66:	781b      	ldrb	r3, [r3, #0]
34180f68:	461a      	mov	r2, r3
34180f6a:	683b      	ldr	r3, [r7, #0]
34180f6c:	3313      	adds	r3, #19
34180f6e:	781b      	ldrb	r3, [r3, #0]
34180f70:	021b      	lsls	r3, r3, #8
34180f72:	441a      	add	r2, r3
34180f74:	683b      	ldr	r3, [r7, #0]
34180f76:	3314      	adds	r3, #20
34180f78:	781b      	ldrb	r3, [r3, #0]
34180f7a:	041b      	lsls	r3, r3, #16
34180f7c:	441a      	add	r2, r3
34180f7e:	683b      	ldr	r3, [r7, #0]
34180f80:	3315      	adds	r3, #21
34180f82:	781b      	ldrb	r3, [r3, #0]
34180f84:	061b      	lsls	r3, r3, #24
34180f86:	4413      	add	r3, r2
34180f88:	61bb      	str	r3, [r7, #24]

  /* Read bitmap height */
  height = (uint32_t)pBmp[22] + ((uint32_t)pBmp[23] << 8) + ((uint32_t)pBmp[24] << 16)  + ((uint32_t)pBmp[25] << 24);
34180f8a:	683b      	ldr	r3, [r7, #0]
34180f8c:	3316      	adds	r3, #22
34180f8e:	781b      	ldrb	r3, [r3, #0]
34180f90:	461a      	mov	r2, r3
34180f92:	683b      	ldr	r3, [r7, #0]
34180f94:	3317      	adds	r3, #23
34180f96:	781b      	ldrb	r3, [r3, #0]
34180f98:	021b      	lsls	r3, r3, #8
34180f9a:	441a      	add	r2, r3
34180f9c:	683b      	ldr	r3, [r7, #0]
34180f9e:	3318      	adds	r3, #24
34180fa0:	781b      	ldrb	r3, [r3, #0]
34180fa2:	041b      	lsls	r3, r3, #16
34180fa4:	441a      	add	r2, r3
34180fa6:	683b      	ldr	r3, [r7, #0]
34180fa8:	3319      	adds	r3, #25
34180faa:	781b      	ldrb	r3, [r3, #0]
34180fac:	061b      	lsls	r3, r3, #24
34180fae:	4413      	add	r3, r2
34180fb0:	617b      	str	r3, [r7, #20]

  /* Read bit/pixel */
  bit_pixel = (uint32_t)pBmp[28] + ((uint32_t)pBmp[29] << 8);
34180fb2:	683b      	ldr	r3, [r7, #0]
34180fb4:	331c      	adds	r3, #28
34180fb6:	781b      	ldrb	r3, [r3, #0]
34180fb8:	461a      	mov	r2, r3
34180fba:	683b      	ldr	r3, [r7, #0]
34180fbc:	331d      	adds	r3, #29
34180fbe:	781b      	ldrb	r3, [r3, #0]
34180fc0:	021b      	lsls	r3, r3, #8
34180fc2:	4413      	add	r3, r2
34180fc4:	613b      	str	r3, [r7, #16]

  /* Set the address */
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
34180fc6:	4a37      	ldr	r2, [pc, #220]	@ (341810a4 <BSP_LCD_DrawBitmap+0x17c>)
34180fc8:	68fb      	ldr	r3, [r7, #12]
34180fca:	015b      	lsls	r3, r3, #5
34180fcc:	4413      	add	r3, r2
34180fce:	3308      	adds	r3, #8
34180fd0:	681b      	ldr	r3, [r3, #0]
34180fd2:	4a35      	ldr	r2, [pc, #212]	@ (341810a8 <BSP_LCD_DrawBitmap+0x180>)
34180fd4:	2134      	movs	r1, #52	@ 0x34
34180fd6:	fb01 f303 	mul.w	r3, r1, r3
34180fda:	4413      	add	r3, r2
34180fdc:	335c      	adds	r3, #92	@ 0x5c
34180fde:	681a      	ldr	r2, [r3, #0]
34180fe0:	4930      	ldr	r1, [pc, #192]	@ (341810a4 <BSP_LCD_DrawBitmap+0x17c>)
34180fe2:	68fb      	ldr	r3, [r7, #12]
34180fe4:	015b      	lsls	r3, r3, #5
34180fe6:	440b      	add	r3, r1
34180fe8:	681b      	ldr	r3, [r3, #0]
34180fea:	6879      	ldr	r1, [r7, #4]
34180fec:	fb03 f101 	mul.w	r1, r3, r1
34180ff0:	68bb      	ldr	r3, [r7, #8]
34180ff2:	440b      	add	r3, r1
34180ff4:	482b      	ldr	r0, [pc, #172]	@ (341810a4 <BSP_LCD_DrawBitmap+0x17c>)
34180ff6:	68f9      	ldr	r1, [r7, #12]
34180ff8:	0149      	lsls	r1, r1, #5
34180ffa:	4401      	add	r1, r0
34180ffc:	3110      	adds	r1, #16
34180ffe:	6809      	ldr	r1, [r1, #0]
34181000:	fb01 f303 	mul.w	r3, r1, r3
34181004:	4413      	add	r3, r2
34181006:	62bb      	str	r3, [r7, #40]	@ 0x28

  /* Get the layer pixel format */
  if ((bit_pixel/8U) == 4U)
34181008:	693b      	ldr	r3, [r7, #16]
3418100a:	3b20      	subs	r3, #32
3418100c:	2b07      	cmp	r3, #7
3418100e:	d802      	bhi.n	34181016 <BSP_LCD_DrawBitmap+0xee>
  {
    input_color_mode = DMA2D_INPUT_ARGB8888;
34181010:	2300      	movs	r3, #0
34181012:	627b      	str	r3, [r7, #36]	@ 0x24
34181014:	e008      	b.n	34181028 <BSP_LCD_DrawBitmap+0x100>
  }
  else if ((bit_pixel/8U) == 2U)
34181016:	693b      	ldr	r3, [r7, #16]
34181018:	3b10      	subs	r3, #16
3418101a:	2b07      	cmp	r3, #7
3418101c:	d802      	bhi.n	34181024 <BSP_LCD_DrawBitmap+0xfc>
  {
    input_color_mode = DMA2D_INPUT_RGB565;
3418101e:	2302      	movs	r3, #2
34181020:	627b      	str	r3, [r7, #36]	@ 0x24
34181022:	e001      	b.n	34181028 <BSP_LCD_DrawBitmap+0x100>
  }
  else
  {
    input_color_mode = DMA2D_INPUT_RGB888;
34181024:	2301      	movs	r3, #1
34181026:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* Bypass the bitmap header */
  pbmp = pBmp + (index + (width * (height - 1U) * (bit_pixel/8U)));
34181028:	697b      	ldr	r3, [r7, #20]
3418102a:	3b01      	subs	r3, #1
3418102c:	69ba      	ldr	r2, [r7, #24]
3418102e:	fb02 f303 	mul.w	r3, r2, r3
34181032:	693a      	ldr	r2, [r7, #16]
34181034:	08d2      	lsrs	r2, r2, #3
34181036:	fb03 f202 	mul.w	r2, r3, r2
3418103a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418103c:	4413      	add	r3, r2
3418103e:	683a      	ldr	r2, [r7, #0]
34181040:	4413      	add	r3, r2
34181042:	623b      	str	r3, [r7, #32]

  /* Convert picture to ARGB8888 pixel format */
  for(index=0; index < height; index++)
34181044:	2300      	movs	r3, #0
34181046:	62fb      	str	r3, [r7, #44]	@ 0x2c
34181048:	e023      	b.n	34181092 <BSP_LCD_DrawBitmap+0x16a>
  {
    /* Pixel format conversion */
    LL_ConvertLineToRGB(Instance, (uint32_t *)pbmp, (uint32_t *)Address, width, input_color_mode);
3418104a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418104c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418104e:	9300      	str	r3, [sp, #0]
34181050:	69bb      	ldr	r3, [r7, #24]
34181052:	6a39      	ldr	r1, [r7, #32]
34181054:	68f8      	ldr	r0, [r7, #12]
34181056:	f000 fb27 	bl	341816a8 <LL_ConvertLineToRGB>

    /* Increment the source and destination buffers */
    Address+=  (Lcd_Ctx[Instance].XSize * Lcd_Ctx[Instance].BppFactor);
3418105a:	4a12      	ldr	r2, [pc, #72]	@ (341810a4 <BSP_LCD_DrawBitmap+0x17c>)
3418105c:	68fb      	ldr	r3, [r7, #12]
3418105e:	015b      	lsls	r3, r3, #5
34181060:	4413      	add	r3, r2
34181062:	681b      	ldr	r3, [r3, #0]
34181064:	490f      	ldr	r1, [pc, #60]	@ (341810a4 <BSP_LCD_DrawBitmap+0x17c>)
34181066:	68fa      	ldr	r2, [r7, #12]
34181068:	0152      	lsls	r2, r2, #5
3418106a:	440a      	add	r2, r1
3418106c:	3210      	adds	r2, #16
3418106e:	6812      	ldr	r2, [r2, #0]
34181070:	fb02 f303 	mul.w	r3, r2, r3
34181074:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34181076:	4413      	add	r3, r2
34181078:	62bb      	str	r3, [r7, #40]	@ 0x28
    pbmp -= width*(bit_pixel/8U);
3418107a:	693b      	ldr	r3, [r7, #16]
3418107c:	08db      	lsrs	r3, r3, #3
3418107e:	69ba      	ldr	r2, [r7, #24]
34181080:	fb02 f303 	mul.w	r3, r2, r3
34181084:	425b      	negs	r3, r3
34181086:	6a3a      	ldr	r2, [r7, #32]
34181088:	4413      	add	r3, r2
3418108a:	623b      	str	r3, [r7, #32]
  for(index=0; index < height; index++)
3418108c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418108e:	3301      	adds	r3, #1
34181090:	62fb      	str	r3, [r7, #44]	@ 0x2c
34181092:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34181094:	697b      	ldr	r3, [r7, #20]
34181096:	429a      	cmp	r2, r3
34181098:	d3d7      	bcc.n	3418104a <BSP_LCD_DrawBitmap+0x122>
  }

  return ret;
3418109a:	69fb      	ldr	r3, [r7, #28]
}
3418109c:	4618      	mov	r0, r3
3418109e:	3730      	adds	r7, #48	@ 0x30
341810a0:	46bd      	mov	sp, r7
341810a2:	bd80      	pop	{r7, pc}
341810a4:	341c015c 	.word	0x341c015c
341810a8:	341c00b4 	.word	0x341c00b4

341810ac <BSP_LCD_FillRGBRect>:
  * @param  Width Rectangle width.
  * @param  Height Rectangle Height.
  * @retval BSP status.
  */
int32_t BSP_LCD_FillRGBRect(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint8_t *pData, uint32_t Width, uint32_t Height)
{
341810ac:	b580      	push	{r7, lr}
341810ae:	b088      	sub	sp, #32
341810b0:	af00      	add	r7, sp, #0
341810b2:	60f8      	str	r0, [r7, #12]
341810b4:	60b9      	str	r1, [r7, #8]
341810b6:	607a      	str	r2, [r7, #4]
341810b8:	603b      	str	r3, [r7, #0]
  uint32_t i;
  uint8_t *pdata = pData;
341810ba:	683b      	ldr	r3, [r7, #0]
341810bc:	61bb      	str	r3, [r7, #24]
    pdata += Lcd_Ctx[Instance].BppFactor*Width;
  }
#else
  uint32_t color;
  uint32_t j;
  for(i = 0; i < Height; i++)
341810be:	2300      	movs	r3, #0
341810c0:	61fb      	str	r3, [r7, #28]
341810c2:	e032      	b.n	3418112a <BSP_LCD_FillRGBRect+0x7e>
  {
    for(j = 0; j < Width; j++)
341810c4:	2300      	movs	r3, #0
341810c6:	617b      	str	r3, [r7, #20]
341810c8:	e028      	b.n	3418111c <BSP_LCD_FillRGBRect+0x70>
    {
      color = (uint32_t)((uint32_t)*pdata | ((uint32_t)(*(pdata + 1U)) << 8U) | ((uint32_t)(*(pdata + 2U)) << 16U) | ((uint32_t)(*(pdata + 3U)) << 24U));
341810ca:	69bb      	ldr	r3, [r7, #24]
341810cc:	781b      	ldrb	r3, [r3, #0]
341810ce:	461a      	mov	r2, r3
341810d0:	69bb      	ldr	r3, [r7, #24]
341810d2:	3301      	adds	r3, #1
341810d4:	781b      	ldrb	r3, [r3, #0]
341810d6:	021b      	lsls	r3, r3, #8
341810d8:	431a      	orrs	r2, r3
341810da:	69bb      	ldr	r3, [r7, #24]
341810dc:	3302      	adds	r3, #2
341810de:	781b      	ldrb	r3, [r3, #0]
341810e0:	041b      	lsls	r3, r3, #16
341810e2:	431a      	orrs	r2, r3
341810e4:	69bb      	ldr	r3, [r7, #24]
341810e6:	3303      	adds	r3, #3
341810e8:	781b      	ldrb	r3, [r3, #0]
341810ea:	061b      	lsls	r3, r3, #24
341810ec:	4313      	orrs	r3, r2
341810ee:	613b      	str	r3, [r7, #16]
      (void)BSP_LCD_WritePixel(Instance, Xpos + j, Ypos + i, color);
341810f0:	68ba      	ldr	r2, [r7, #8]
341810f2:	697b      	ldr	r3, [r7, #20]
341810f4:	18d1      	adds	r1, r2, r3
341810f6:	687a      	ldr	r2, [r7, #4]
341810f8:	69fb      	ldr	r3, [r7, #28]
341810fa:	441a      	add	r2, r3
341810fc:	693b      	ldr	r3, [r7, #16]
341810fe:	68f8      	ldr	r0, [r7, #12]
34181100:	f000 f96c 	bl	341813dc <BSP_LCD_WritePixel>
      pdata += Lcd_Ctx[Instance].BppFactor;
34181104:	4a0d      	ldr	r2, [pc, #52]	@ (3418113c <BSP_LCD_FillRGBRect+0x90>)
34181106:	68fb      	ldr	r3, [r7, #12]
34181108:	015b      	lsls	r3, r3, #5
3418110a:	4413      	add	r3, r2
3418110c:	3310      	adds	r3, #16
3418110e:	681b      	ldr	r3, [r3, #0]
34181110:	69ba      	ldr	r2, [r7, #24]
34181112:	4413      	add	r3, r2
34181114:	61bb      	str	r3, [r7, #24]
    for(j = 0; j < Width; j++)
34181116:	697b      	ldr	r3, [r7, #20]
34181118:	3301      	adds	r3, #1
3418111a:	617b      	str	r3, [r7, #20]
3418111c:	697a      	ldr	r2, [r7, #20]
3418111e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34181120:	429a      	cmp	r2, r3
34181122:	d3d2      	bcc.n	341810ca <BSP_LCD_FillRGBRect+0x1e>
  for(i = 0; i < Height; i++)
34181124:	69fb      	ldr	r3, [r7, #28]
34181126:	3301      	adds	r3, #1
34181128:	61fb      	str	r3, [r7, #28]
3418112a:	69fa      	ldr	r2, [r7, #28]
3418112c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418112e:	429a      	cmp	r2, r3
34181130:	d3c8      	bcc.n	341810c4 <BSP_LCD_FillRGBRect+0x18>
    }
  }
#endif /* (USE_DMA2D_TO_FILL_RGB_RECT == 1) */

  return BSP_ERROR_NONE;
34181132:	2300      	movs	r3, #0
}
34181134:	4618      	mov	r0, r3
34181136:	3720      	adds	r7, #32
34181138:	46bd      	mov	sp, r7
3418113a:	bd80      	pop	{r7, pc}
3418113c:	341c015c 	.word	0x341c015c

34181140 <BSP_LCD_DrawHLine>:
  * @param  Length  Line length
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_DrawHLine(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
34181140:	b580      	push	{r7, lr}
34181142:	b088      	sub	sp, #32
34181144:	af02      	add	r7, sp, #8
34181146:	60f8      	str	r0, [r7, #12]
34181148:	60b9      	str	r1, [r7, #8]
3418114a:	607a      	str	r2, [r7, #4]
3418114c:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the line address */
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
3418114e:	4a18      	ldr	r2, [pc, #96]	@ (341811b0 <BSP_LCD_DrawHLine+0x70>)
34181150:	68fb      	ldr	r3, [r7, #12]
34181152:	015b      	lsls	r3, r3, #5
34181154:	4413      	add	r3, r2
34181156:	3308      	adds	r3, #8
34181158:	681b      	ldr	r3, [r3, #0]
3418115a:	4a16      	ldr	r2, [pc, #88]	@ (341811b4 <BSP_LCD_DrawHLine+0x74>)
3418115c:	2134      	movs	r1, #52	@ 0x34
3418115e:	fb01 f303 	mul.w	r3, r1, r3
34181162:	4413      	add	r3, r2
34181164:	335c      	adds	r3, #92	@ 0x5c
34181166:	681a      	ldr	r2, [r3, #0]
34181168:	4911      	ldr	r1, [pc, #68]	@ (341811b0 <BSP_LCD_DrawHLine+0x70>)
3418116a:	68fb      	ldr	r3, [r7, #12]
3418116c:	015b      	lsls	r3, r3, #5
3418116e:	440b      	add	r3, r1
34181170:	3310      	adds	r3, #16
34181172:	681b      	ldr	r3, [r3, #0]
34181174:	480e      	ldr	r0, [pc, #56]	@ (341811b0 <BSP_LCD_DrawHLine+0x70>)
34181176:	68f9      	ldr	r1, [r7, #12]
34181178:	0149      	lsls	r1, r1, #5
3418117a:	4401      	add	r1, r0
3418117c:	6809      	ldr	r1, [r1, #0]
3418117e:	6878      	ldr	r0, [r7, #4]
34181180:	fb01 f000 	mul.w	r0, r1, r0
34181184:	68b9      	ldr	r1, [r7, #8]
34181186:	4401      	add	r1, r0
34181188:	fb01 f303 	mul.w	r3, r1, r3
3418118c:	4413      	add	r3, r2
3418118e:	617b      	str	r3, [r7, #20]

  /* Write line */
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Length, 1, 0, Color);
34181190:	6979      	ldr	r1, [r7, #20]
34181192:	6a3b      	ldr	r3, [r7, #32]
34181194:	9301      	str	r3, [sp, #4]
34181196:	2300      	movs	r3, #0
34181198:	9300      	str	r3, [sp, #0]
3418119a:	2301      	movs	r3, #1
3418119c:	683a      	ldr	r2, [r7, #0]
3418119e:	68f8      	ldr	r0, [r7, #12]
341811a0:	f000 f9e6 	bl	34181570 <LL_FillBuffer>

  return BSP_ERROR_NONE;
341811a4:	2300      	movs	r3, #0
}
341811a6:	4618      	mov	r0, r3
341811a8:	3718      	adds	r7, #24
341811aa:	46bd      	mov	sp, r7
341811ac:	bd80      	pop	{r7, pc}
341811ae:	bf00      	nop
341811b0:	341c015c 	.word	0x341c015c
341811b4:	341c00b4 	.word	0x341c00b4

341811b8 <BSP_LCD_DrawVLine>:
  * @param  Length  Line length
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_DrawVLine(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
341811b8:	b580      	push	{r7, lr}
341811ba:	b088      	sub	sp, #32
341811bc:	af02      	add	r7, sp, #8
341811be:	60f8      	str	r0, [r7, #12]
341811c0:	60b9      	str	r1, [r7, #8]
341811c2:	607a      	str	r2, [r7, #4]
341811c4:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the line address */
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
341811c6:	4a1a      	ldr	r2, [pc, #104]	@ (34181230 <BSP_LCD_DrawVLine+0x78>)
341811c8:	68fb      	ldr	r3, [r7, #12]
341811ca:	015b      	lsls	r3, r3, #5
341811cc:	4413      	add	r3, r2
341811ce:	3308      	adds	r3, #8
341811d0:	681b      	ldr	r3, [r3, #0]
341811d2:	4a18      	ldr	r2, [pc, #96]	@ (34181234 <BSP_LCD_DrawVLine+0x7c>)
341811d4:	2134      	movs	r1, #52	@ 0x34
341811d6:	fb01 f303 	mul.w	r3, r1, r3
341811da:	4413      	add	r3, r2
341811dc:	335c      	adds	r3, #92	@ 0x5c
341811de:	681a      	ldr	r2, [r3, #0]
341811e0:	4913      	ldr	r1, [pc, #76]	@ (34181230 <BSP_LCD_DrawVLine+0x78>)
341811e2:	68fb      	ldr	r3, [r7, #12]
341811e4:	015b      	lsls	r3, r3, #5
341811e6:	440b      	add	r3, r1
341811e8:	3310      	adds	r3, #16
341811ea:	681b      	ldr	r3, [r3, #0]
341811ec:	4810      	ldr	r0, [pc, #64]	@ (34181230 <BSP_LCD_DrawVLine+0x78>)
341811ee:	68f9      	ldr	r1, [r7, #12]
341811f0:	0149      	lsls	r1, r1, #5
341811f2:	4401      	add	r1, r0
341811f4:	6809      	ldr	r1, [r1, #0]
341811f6:	6878      	ldr	r0, [r7, #4]
341811f8:	fb01 f000 	mul.w	r0, r1, r0
341811fc:	68b9      	ldr	r1, [r7, #8]
341811fe:	4401      	add	r1, r0
34181200:	fb01 f303 	mul.w	r3, r1, r3
34181204:	4413      	add	r3, r2
34181206:	617b      	str	r3, [r7, #20]

  /* Write line */
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, 1, Length, (Lcd_Ctx[Instance].XSize - 1U), Color);
34181208:	6979      	ldr	r1, [r7, #20]
3418120a:	4a09      	ldr	r2, [pc, #36]	@ (34181230 <BSP_LCD_DrawVLine+0x78>)
3418120c:	68fb      	ldr	r3, [r7, #12]
3418120e:	015b      	lsls	r3, r3, #5
34181210:	4413      	add	r3, r2
34181212:	681b      	ldr	r3, [r3, #0]
34181214:	3b01      	subs	r3, #1
34181216:	6a3a      	ldr	r2, [r7, #32]
34181218:	9201      	str	r2, [sp, #4]
3418121a:	9300      	str	r3, [sp, #0]
3418121c:	683b      	ldr	r3, [r7, #0]
3418121e:	2201      	movs	r2, #1
34181220:	68f8      	ldr	r0, [r7, #12]
34181222:	f000 f9a5 	bl	34181570 <LL_FillBuffer>

  return BSP_ERROR_NONE;
34181226:	2300      	movs	r3, #0
}
34181228:	4618      	mov	r0, r3
3418122a:	3718      	adds	r7, #24
3418122c:	46bd      	mov	sp, r7
3418122e:	bd80      	pop	{r7, pc}
34181230:	341c015c 	.word	0x341c015c
34181234:	341c00b4 	.word	0x341c00b4

34181238 <BSP_LCD_FillRect>:
  * @param  Height Rectangle height
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_FillRect(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
34181238:	b580      	push	{r7, lr}
3418123a:	b088      	sub	sp, #32
3418123c:	af02      	add	r7, sp, #8
3418123e:	60f8      	str	r0, [r7, #12]
34181240:	60b9      	str	r1, [r7, #8]
34181242:	607a      	str	r2, [r7, #4]
34181244:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the rectangle start address */
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34181246:	4a1b      	ldr	r2, [pc, #108]	@ (341812b4 <BSP_LCD_FillRect+0x7c>)
34181248:	68fb      	ldr	r3, [r7, #12]
3418124a:	015b      	lsls	r3, r3, #5
3418124c:	4413      	add	r3, r2
3418124e:	3308      	adds	r3, #8
34181250:	681b      	ldr	r3, [r3, #0]
34181252:	4a19      	ldr	r2, [pc, #100]	@ (341812b8 <BSP_LCD_FillRect+0x80>)
34181254:	2134      	movs	r1, #52	@ 0x34
34181256:	fb01 f303 	mul.w	r3, r1, r3
3418125a:	4413      	add	r3, r2
3418125c:	335c      	adds	r3, #92	@ 0x5c
3418125e:	681a      	ldr	r2, [r3, #0]
34181260:	4914      	ldr	r1, [pc, #80]	@ (341812b4 <BSP_LCD_FillRect+0x7c>)
34181262:	68fb      	ldr	r3, [r7, #12]
34181264:	015b      	lsls	r3, r3, #5
34181266:	440b      	add	r3, r1
34181268:	3310      	adds	r3, #16
3418126a:	681b      	ldr	r3, [r3, #0]
3418126c:	4811      	ldr	r0, [pc, #68]	@ (341812b4 <BSP_LCD_FillRect+0x7c>)
3418126e:	68f9      	ldr	r1, [r7, #12]
34181270:	0149      	lsls	r1, r1, #5
34181272:	4401      	add	r1, r0
34181274:	6809      	ldr	r1, [r1, #0]
34181276:	6878      	ldr	r0, [r7, #4]
34181278:	fb01 f000 	mul.w	r0, r1, r0
3418127c:	68b9      	ldr	r1, [r7, #8]
3418127e:	4401      	add	r1, r0
34181280:	fb01 f303 	mul.w	r3, r1, r3
34181284:	4413      	add	r3, r2
34181286:	617b      	str	r3, [r7, #20]

  /* Fill the rectangle */
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Width, Height, (Lcd_Ctx[Instance].XSize - Width), Color);
34181288:	6979      	ldr	r1, [r7, #20]
3418128a:	4a0a      	ldr	r2, [pc, #40]	@ (341812b4 <BSP_LCD_FillRect+0x7c>)
3418128c:	68fb      	ldr	r3, [r7, #12]
3418128e:	015b      	lsls	r3, r3, #5
34181290:	4413      	add	r3, r2
34181292:	681a      	ldr	r2, [r3, #0]
34181294:	683b      	ldr	r3, [r7, #0]
34181296:	1ad3      	subs	r3, r2, r3
34181298:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3418129a:	9201      	str	r2, [sp, #4]
3418129c:	9300      	str	r3, [sp, #0]
3418129e:	6a3b      	ldr	r3, [r7, #32]
341812a0:	683a      	ldr	r2, [r7, #0]
341812a2:	68f8      	ldr	r0, [r7, #12]
341812a4:	f000 f964 	bl	34181570 <LL_FillBuffer>

  return BSP_ERROR_NONE;
341812a8:	2300      	movs	r3, #0
}
341812aa:	4618      	mov	r0, r3
341812ac:	3718      	adds	r7, #24
341812ae:	46bd      	mov	sp, r7
341812b0:	bd80      	pop	{r7, pc}
341812b2:	bf00      	nop
341812b4:	341c015c 	.word	0x341c015c
341812b8:	341c00b4 	.word	0x341c00b4

341812bc <BSP_LCD_ReadPixel>:
  * @param  Ypos Y position
  * @param  Color RGB pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_ReadPixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t *Color)
{
341812bc:	b480      	push	{r7}
341812be:	b085      	sub	sp, #20
341812c0:	af00      	add	r7, sp, #0
341812c2:	60f8      	str	r0, [r7, #12]
341812c4:	60b9      	str	r1, [r7, #8]
341812c6:	607a      	str	r2, [r7, #4]
341812c8:	603b      	str	r3, [r7, #0]
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
341812ca:	4a42      	ldr	r2, [pc, #264]	@ (341813d4 <BSP_LCD_ReadPixel+0x118>)
341812cc:	68fb      	ldr	r3, [r7, #12]
341812ce:	015b      	lsls	r3, r3, #5
341812d0:	4413      	add	r3, r2
341812d2:	3308      	adds	r3, #8
341812d4:	681b      	ldr	r3, [r3, #0]
341812d6:	4a40      	ldr	r2, [pc, #256]	@ (341813d8 <BSP_LCD_ReadPixel+0x11c>)
341812d8:	2134      	movs	r1, #52	@ 0x34
341812da:	fb01 f303 	mul.w	r3, r1, r3
341812de:	4413      	add	r3, r2
341812e0:	3348      	adds	r3, #72	@ 0x48
341812e2:	681b      	ldr	r3, [r3, #0]
341812e4:	2b00      	cmp	r3, #0
341812e6:	d11c      	bne.n	34181322 <BSP_LCD_ReadPixel+0x66>
  {
    /* Read data value from RAM memory */
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
341812e8:	4a3a      	ldr	r2, [pc, #232]	@ (341813d4 <BSP_LCD_ReadPixel+0x118>)
341812ea:	68fb      	ldr	r3, [r7, #12]
341812ec:	015b      	lsls	r3, r3, #5
341812ee:	4413      	add	r3, r2
341812f0:	3308      	adds	r3, #8
341812f2:	681b      	ldr	r3, [r3, #0]
341812f4:	4a38      	ldr	r2, [pc, #224]	@ (341813d8 <BSP_LCD_ReadPixel+0x11c>)
341812f6:	2134      	movs	r1, #52	@ 0x34
341812f8:	fb01 f303 	mul.w	r3, r1, r3
341812fc:	4413      	add	r3, r2
341812fe:	335c      	adds	r3, #92	@ 0x5c
34181300:	681a      	ldr	r2, [r3, #0]
34181302:	4934      	ldr	r1, [pc, #208]	@ (341813d4 <BSP_LCD_ReadPixel+0x118>)
34181304:	68fb      	ldr	r3, [r7, #12]
34181306:	015b      	lsls	r3, r3, #5
34181308:	440b      	add	r3, r1
3418130a:	681b      	ldr	r3, [r3, #0]
3418130c:	6879      	ldr	r1, [r7, #4]
3418130e:	fb03 f101 	mul.w	r1, r3, r1
34181312:	68bb      	ldr	r3, [r7, #8]
34181314:	440b      	add	r3, r1
34181316:	009b      	lsls	r3, r3, #2
34181318:	4413      	add	r3, r2
3418131a:	681a      	ldr	r2, [r3, #0]
3418131c:	683b      	ldr	r3, [r7, #0]
3418131e:	601a      	str	r2, [r3, #0]
34181320:	e051      	b.n	341813c6 <BSP_LCD_ReadPixel+0x10a>
  }
  else if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
34181322:	4a2c      	ldr	r2, [pc, #176]	@ (341813d4 <BSP_LCD_ReadPixel+0x118>)
34181324:	68fb      	ldr	r3, [r7, #12]
34181326:	015b      	lsls	r3, r3, #5
34181328:	4413      	add	r3, r2
3418132a:	3308      	adds	r3, #8
3418132c:	681b      	ldr	r3, [r3, #0]
3418132e:	4a2a      	ldr	r2, [pc, #168]	@ (341813d8 <BSP_LCD_ReadPixel+0x11c>)
34181330:	2134      	movs	r1, #52	@ 0x34
34181332:	fb01 f303 	mul.w	r3, r1, r3
34181336:	4413      	add	r3, r2
34181338:	3348      	adds	r3, #72	@ 0x48
3418133a:	681b      	ldr	r3, [r3, #0]
3418133c:	2b06      	cmp	r3, #6
3418133e:	d124      	bne.n	3418138a <BSP_LCD_ReadPixel+0xce>
  {
    /* Read data value from RAM memory */
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34181340:	4a24      	ldr	r2, [pc, #144]	@ (341813d4 <BSP_LCD_ReadPixel+0x118>)
34181342:	68fb      	ldr	r3, [r7, #12]
34181344:	015b      	lsls	r3, r3, #5
34181346:	4413      	add	r3, r2
34181348:	3308      	adds	r3, #8
3418134a:	681b      	ldr	r3, [r3, #0]
3418134c:	4a22      	ldr	r2, [pc, #136]	@ (341813d8 <BSP_LCD_ReadPixel+0x11c>)
3418134e:	2134      	movs	r1, #52	@ 0x34
34181350:	fb01 f303 	mul.w	r3, r1, r3
34181354:	4413      	add	r3, r2
34181356:	335c      	adds	r3, #92	@ 0x5c
34181358:	6819      	ldr	r1, [r3, #0]
3418135a:	4a1e      	ldr	r2, [pc, #120]	@ (341813d4 <BSP_LCD_ReadPixel+0x118>)
3418135c:	68fb      	ldr	r3, [r7, #12]
3418135e:	015b      	lsls	r3, r3, #5
34181360:	4413      	add	r3, r2
34181362:	681b      	ldr	r3, [r3, #0]
34181364:	687a      	ldr	r2, [r7, #4]
34181366:	fb03 f202 	mul.w	r2, r3, r2
3418136a:	68bb      	ldr	r3, [r7, #8]
3418136c:	441a      	add	r2, r3
3418136e:	4613      	mov	r3, r2
34181370:	005b      	lsls	r3, r3, #1
34181372:	4413      	add	r3, r2
34181374:	440b      	add	r3, r1
34181376:	681a      	ldr	r2, [r3, #0]
34181378:	683b      	ldr	r3, [r7, #0]
3418137a:	601a      	str	r2, [r3, #0]
    *Color = CONVERTARGB88882RGB888(*Color);
3418137c:	683b      	ldr	r3, [r7, #0]
3418137e:	681b      	ldr	r3, [r3, #0]
34181380:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
34181384:	683b      	ldr	r3, [r7, #0]
34181386:	601a      	str	r2, [r3, #0]
34181388:	e01d      	b.n	341813c6 <BSP_LCD_ReadPixel+0x10a>
  }
  else /* if((hlcd_ltdc.LayerCfg[layer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565) */
  {
    /* Read data value from RAM memory */
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
3418138a:	4a12      	ldr	r2, [pc, #72]	@ (341813d4 <BSP_LCD_ReadPixel+0x118>)
3418138c:	68fb      	ldr	r3, [r7, #12]
3418138e:	015b      	lsls	r3, r3, #5
34181390:	4413      	add	r3, r2
34181392:	3308      	adds	r3, #8
34181394:	681b      	ldr	r3, [r3, #0]
34181396:	4a10      	ldr	r2, [pc, #64]	@ (341813d8 <BSP_LCD_ReadPixel+0x11c>)
34181398:	2134      	movs	r1, #52	@ 0x34
3418139a:	fb01 f303 	mul.w	r3, r1, r3
3418139e:	4413      	add	r3, r2
341813a0:	335c      	adds	r3, #92	@ 0x5c
341813a2:	681a      	ldr	r2, [r3, #0]
341813a4:	490b      	ldr	r1, [pc, #44]	@ (341813d4 <BSP_LCD_ReadPixel+0x118>)
341813a6:	68fb      	ldr	r3, [r7, #12]
341813a8:	015b      	lsls	r3, r3, #5
341813aa:	440b      	add	r3, r1
341813ac:	681b      	ldr	r3, [r3, #0]
341813ae:	6879      	ldr	r1, [r7, #4]
341813b0:	fb03 f101 	mul.w	r1, r3, r1
341813b4:	68bb      	ldr	r3, [r7, #8]
341813b6:	440b      	add	r3, r1
341813b8:	005b      	lsls	r3, r3, #1
341813ba:	4413      	add	r3, r2
341813bc:	881b      	ldrh	r3, [r3, #0]
341813be:	b29b      	uxth	r3, r3
341813c0:	461a      	mov	r2, r3
341813c2:	683b      	ldr	r3, [r7, #0]
341813c4:	601a      	str	r2, [r3, #0]
  }

  return BSP_ERROR_NONE;
341813c6:	2300      	movs	r3, #0
}
341813c8:	4618      	mov	r0, r3
341813ca:	3714      	adds	r7, #20
341813cc:	46bd      	mov	sp, r7
341813ce:	f85d 7b04 	ldr.w	r7, [sp], #4
341813d2:	4770      	bx	lr
341813d4:	341c015c 	.word	0x341c015c
341813d8:	341c00b4 	.word	0x341c00b4

341813dc <BSP_LCD_WritePixel>:
  * @param  Ypos Y position
  * @param  Color Pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_WritePixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Color)
{
341813dc:	b480      	push	{r7}
341813de:	b085      	sub	sp, #20
341813e0:	af00      	add	r7, sp, #0
341813e2:	60f8      	str	r0, [r7, #12]
341813e4:	60b9      	str	r1, [r7, #8]
341813e6:	607a      	str	r2, [r7, #4]
341813e8:	603b      	str	r3, [r7, #0]
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
341813ea:	4a5f      	ldr	r2, [pc, #380]	@ (34181568 <BSP_LCD_WritePixel+0x18c>)
341813ec:	68fb      	ldr	r3, [r7, #12]
341813ee:	015b      	lsls	r3, r3, #5
341813f0:	4413      	add	r3, r2
341813f2:	3308      	adds	r3, #8
341813f4:	681b      	ldr	r3, [r3, #0]
341813f6:	4a5d      	ldr	r2, [pc, #372]	@ (3418156c <BSP_LCD_WritePixel+0x190>)
341813f8:	2134      	movs	r1, #52	@ 0x34
341813fa:	fb01 f303 	mul.w	r3, r1, r3
341813fe:	4413      	add	r3, r2
34181400:	3348      	adds	r3, #72	@ 0x48
34181402:	681b      	ldr	r3, [r3, #0]
34181404:	2b00      	cmp	r3, #0
34181406:	d11c      	bne.n	34181442 <BSP_LCD_WritePixel+0x66>
  {
    /* Write data value to RAM memory */
    *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = Color;
34181408:	4a57      	ldr	r2, [pc, #348]	@ (34181568 <BSP_LCD_WritePixel+0x18c>)
3418140a:	68fb      	ldr	r3, [r7, #12]
3418140c:	015b      	lsls	r3, r3, #5
3418140e:	4413      	add	r3, r2
34181410:	3308      	adds	r3, #8
34181412:	681b      	ldr	r3, [r3, #0]
34181414:	4a55      	ldr	r2, [pc, #340]	@ (3418156c <BSP_LCD_WritePixel+0x190>)
34181416:	2134      	movs	r1, #52	@ 0x34
34181418:	fb01 f303 	mul.w	r3, r1, r3
3418141c:	4413      	add	r3, r2
3418141e:	335c      	adds	r3, #92	@ 0x5c
34181420:	681a      	ldr	r2, [r3, #0]
34181422:	4951      	ldr	r1, [pc, #324]	@ (34181568 <BSP_LCD_WritePixel+0x18c>)
34181424:	68fb      	ldr	r3, [r7, #12]
34181426:	015b      	lsls	r3, r3, #5
34181428:	440b      	add	r3, r1
3418142a:	681b      	ldr	r3, [r3, #0]
3418142c:	6879      	ldr	r1, [r7, #4]
3418142e:	fb03 f101 	mul.w	r1, r3, r1
34181432:	68bb      	ldr	r3, [r7, #8]
34181434:	440b      	add	r3, r1
34181436:	009b      	lsls	r3, r3, #2
34181438:	4413      	add	r3, r2
3418143a:	461a      	mov	r2, r3
3418143c:	683b      	ldr	r3, [r7, #0]
3418143e:	6013      	str	r3, [r2, #0]
34181440:	e08a      	b.n	34181558 <BSP_LCD_WritePixel+0x17c>
  }
  else if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
34181442:	4a49      	ldr	r2, [pc, #292]	@ (34181568 <BSP_LCD_WritePixel+0x18c>)
34181444:	68fb      	ldr	r3, [r7, #12]
34181446:	015b      	lsls	r3, r3, #5
34181448:	4413      	add	r3, r2
3418144a:	3308      	adds	r3, #8
3418144c:	681b      	ldr	r3, [r3, #0]
3418144e:	4a47      	ldr	r2, [pc, #284]	@ (3418156c <BSP_LCD_WritePixel+0x190>)
34181450:	2134      	movs	r1, #52	@ 0x34
34181452:	fb01 f303 	mul.w	r3, r1, r3
34181456:	4413      	add	r3, r2
34181458:	3348      	adds	r3, #72	@ 0x48
3418145a:	681b      	ldr	r3, [r3, #0]
3418145c:	2b06      	cmp	r3, #6
3418145e:	d15f      	bne.n	34181520 <BSP_LCD_WritePixel+0x144>
  {
    /* Write data value to RAM memory */
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-3U)) = (uint8_t) (Color);
34181460:	4a41      	ldr	r2, [pc, #260]	@ (34181568 <BSP_LCD_WritePixel+0x18c>)
34181462:	68fb      	ldr	r3, [r7, #12]
34181464:	015b      	lsls	r3, r3, #5
34181466:	4413      	add	r3, r2
34181468:	3308      	adds	r3, #8
3418146a:	681b      	ldr	r3, [r3, #0]
3418146c:	4a3f      	ldr	r2, [pc, #252]	@ (3418156c <BSP_LCD_WritePixel+0x190>)
3418146e:	2134      	movs	r1, #52	@ 0x34
34181470:	fb01 f303 	mul.w	r3, r1, r3
34181474:	4413      	add	r3, r2
34181476:	335c      	adds	r3, #92	@ 0x5c
34181478:	6819      	ldr	r1, [r3, #0]
3418147a:	4a3b      	ldr	r2, [pc, #236]	@ (34181568 <BSP_LCD_WritePixel+0x18c>)
3418147c:	68fb      	ldr	r3, [r7, #12]
3418147e:	015b      	lsls	r3, r3, #5
34181480:	4413      	add	r3, r2
34181482:	681b      	ldr	r3, [r3, #0]
34181484:	687a      	ldr	r2, [r7, #4]
34181486:	fb03 f202 	mul.w	r2, r3, r2
3418148a:	68bb      	ldr	r3, [r7, #8]
3418148c:	441a      	add	r2, r3
3418148e:	4613      	mov	r3, r2
34181490:	005b      	lsls	r3, r3, #1
34181492:	4413      	add	r3, r2
34181494:	440b      	add	r3, r1
34181496:	3b03      	subs	r3, #3
34181498:	683a      	ldr	r2, [r7, #0]
3418149a:	b2d2      	uxtb	r2, r2
3418149c:	701a      	strb	r2, [r3, #0]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-2U)) = (uint8_t) (Color>>8U);
3418149e:	683b      	ldr	r3, [r7, #0]
341814a0:	0a18      	lsrs	r0, r3, #8
341814a2:	4a31      	ldr	r2, [pc, #196]	@ (34181568 <BSP_LCD_WritePixel+0x18c>)
341814a4:	68fb      	ldr	r3, [r7, #12]
341814a6:	015b      	lsls	r3, r3, #5
341814a8:	4413      	add	r3, r2
341814aa:	3308      	adds	r3, #8
341814ac:	681b      	ldr	r3, [r3, #0]
341814ae:	4a2f      	ldr	r2, [pc, #188]	@ (3418156c <BSP_LCD_WritePixel+0x190>)
341814b0:	2134      	movs	r1, #52	@ 0x34
341814b2:	fb01 f303 	mul.w	r3, r1, r3
341814b6:	4413      	add	r3, r2
341814b8:	335c      	adds	r3, #92	@ 0x5c
341814ba:	6819      	ldr	r1, [r3, #0]
341814bc:	4a2a      	ldr	r2, [pc, #168]	@ (34181568 <BSP_LCD_WritePixel+0x18c>)
341814be:	68fb      	ldr	r3, [r7, #12]
341814c0:	015b      	lsls	r3, r3, #5
341814c2:	4413      	add	r3, r2
341814c4:	681b      	ldr	r3, [r3, #0]
341814c6:	687a      	ldr	r2, [r7, #4]
341814c8:	fb03 f202 	mul.w	r2, r3, r2
341814cc:	68bb      	ldr	r3, [r7, #8]
341814ce:	441a      	add	r2, r3
341814d0:	4613      	mov	r3, r2
341814d2:	005b      	lsls	r3, r3, #1
341814d4:	4413      	add	r3, r2
341814d6:	440b      	add	r3, r1
341814d8:	3b02      	subs	r3, #2
341814da:	b2c2      	uxtb	r2, r0
341814dc:	701a      	strb	r2, [r3, #0]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-1U)) = (uint8_t) (Color>>16U);
341814de:	683b      	ldr	r3, [r7, #0]
341814e0:	0c18      	lsrs	r0, r3, #16
341814e2:	4a21      	ldr	r2, [pc, #132]	@ (34181568 <BSP_LCD_WritePixel+0x18c>)
341814e4:	68fb      	ldr	r3, [r7, #12]
341814e6:	015b      	lsls	r3, r3, #5
341814e8:	4413      	add	r3, r2
341814ea:	3308      	adds	r3, #8
341814ec:	681b      	ldr	r3, [r3, #0]
341814ee:	4a1f      	ldr	r2, [pc, #124]	@ (3418156c <BSP_LCD_WritePixel+0x190>)
341814f0:	2134      	movs	r1, #52	@ 0x34
341814f2:	fb01 f303 	mul.w	r3, r1, r3
341814f6:	4413      	add	r3, r2
341814f8:	335c      	adds	r3, #92	@ 0x5c
341814fa:	6819      	ldr	r1, [r3, #0]
341814fc:	4a1a      	ldr	r2, [pc, #104]	@ (34181568 <BSP_LCD_WritePixel+0x18c>)
341814fe:	68fb      	ldr	r3, [r7, #12]
34181500:	015b      	lsls	r3, r3, #5
34181502:	4413      	add	r3, r2
34181504:	681b      	ldr	r3, [r3, #0]
34181506:	687a      	ldr	r2, [r7, #4]
34181508:	fb03 f202 	mul.w	r2, r3, r2
3418150c:	68bb      	ldr	r3, [r7, #8]
3418150e:	441a      	add	r2, r3
34181510:	4613      	mov	r3, r2
34181512:	005b      	lsls	r3, r3, #1
34181514:	4413      	add	r3, r2
34181516:	440b      	add	r3, r1
34181518:	3b01      	subs	r3, #1
3418151a:	b2c2      	uxtb	r2, r0
3418151c:	701a      	strb	r2, [r3, #0]
3418151e:	e01b      	b.n	34181558 <BSP_LCD_WritePixel+0x17c>
  }
  else
  {
    /* Write data value to RAM memory */
    *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = (uint16_t)Color;
34181520:	4a11      	ldr	r2, [pc, #68]	@ (34181568 <BSP_LCD_WritePixel+0x18c>)
34181522:	68fb      	ldr	r3, [r7, #12]
34181524:	015b      	lsls	r3, r3, #5
34181526:	4413      	add	r3, r2
34181528:	3308      	adds	r3, #8
3418152a:	681b      	ldr	r3, [r3, #0]
3418152c:	4a0f      	ldr	r2, [pc, #60]	@ (3418156c <BSP_LCD_WritePixel+0x190>)
3418152e:	2134      	movs	r1, #52	@ 0x34
34181530:	fb01 f303 	mul.w	r3, r1, r3
34181534:	4413      	add	r3, r2
34181536:	335c      	adds	r3, #92	@ 0x5c
34181538:	681a      	ldr	r2, [r3, #0]
3418153a:	490b      	ldr	r1, [pc, #44]	@ (34181568 <BSP_LCD_WritePixel+0x18c>)
3418153c:	68fb      	ldr	r3, [r7, #12]
3418153e:	015b      	lsls	r3, r3, #5
34181540:	440b      	add	r3, r1
34181542:	681b      	ldr	r3, [r3, #0]
34181544:	6879      	ldr	r1, [r7, #4]
34181546:	fb03 f101 	mul.w	r1, r3, r1
3418154a:	68bb      	ldr	r3, [r7, #8]
3418154c:	440b      	add	r3, r1
3418154e:	005b      	lsls	r3, r3, #1
34181550:	4413      	add	r3, r2
34181552:	683a      	ldr	r2, [r7, #0]
34181554:	b292      	uxth	r2, r2
34181556:	801a      	strh	r2, [r3, #0]
  }

  return BSP_ERROR_NONE;
34181558:	2300      	movs	r3, #0
}
3418155a:	4618      	mov	r0, r3
3418155c:	3714      	adds	r7, #20
3418155e:	46bd      	mov	sp, r7
34181560:	f85d 7b04 	ldr.w	r7, [sp], #4
34181564:	4770      	bx	lr
34181566:	bf00      	nop
34181568:	341c015c 	.word	0x341c015c
3418156c:	341c00b4 	.word	0x341c00b4

34181570 <LL_FillBuffer>:
  * @param  ySize Buffer height
  * @param  OffLine Offset
  * @param  Color RGB color
  */
static void LL_FillBuffer(uint32_t Instance, uint32_t *pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t Color)
{
34181570:	b580      	push	{r7, lr}
34181572:	b088      	sub	sp, #32
34181574:	af02      	add	r7, sp, #8
34181576:	60f8      	str	r0, [r7, #12]
34181578:	60b9      	str	r1, [r7, #8]
3418157a:	607a      	str	r2, [r7, #4]
3418157c:	603b      	str	r3, [r7, #0]
  uint32_t output_color_mode;
  uint32_t input_color = Color;
3418157e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34181580:	613b      	str	r3, [r7, #16]

  switch(Lcd_Ctx[Instance].PixelFormat)
34181582:	4a46      	ldr	r2, [pc, #280]	@ (3418169c <LL_FillBuffer+0x12c>)
34181584:	68fb      	ldr	r3, [r7, #12]
34181586:	015b      	lsls	r3, r3, #5
34181588:	4413      	add	r3, r2
3418158a:	330c      	adds	r3, #12
3418158c:	681b      	ldr	r3, [r3, #0]
3418158e:	2b04      	cmp	r3, #4
34181590:	d02f      	beq.n	341815f2 <LL_FillBuffer+0x82>
34181592:	2b04      	cmp	r3, #4
34181594:	d859      	bhi.n	3418164a <LL_FillBuffer+0xda>
34181596:	2b01      	cmp	r3, #1
34181598:	d050      	beq.n	3418163c <LL_FillBuffer+0xcc>
3418159a:	2b02      	cmp	r3, #2
3418159c:	d155      	bne.n	3418164a <LL_FillBuffer+0xda>
  {
  case LCD_PIXEL_FORMAT_RGB565:
    output_color_mode = DMA2D_OUTPUT_RGB565; /* RGB565 */
3418159e:	2302      	movs	r3, #2
341815a0:	617b      	str	r3, [r7, #20]
    input_color = CONVERTRGB5652ARGB8888(Color);
341815a2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341815a4:	0adb      	lsrs	r3, r3, #11
341815a6:	f003 021f 	and.w	r2, r3, #31
341815aa:	4613      	mov	r3, r2
341815ac:	011b      	lsls	r3, r3, #4
341815ae:	4413      	add	r3, r2
341815b0:	015a      	lsls	r2, r3, #5
341815b2:	1ad3      	subs	r3, r2, r3
341815b4:	3317      	adds	r3, #23
341815b6:	099b      	lsrs	r3, r3, #6
341815b8:	0419      	lsls	r1, r3, #16
341815ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341815bc:	095b      	lsrs	r3, r3, #5
341815be:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
341815c2:	4613      	mov	r3, r2
341815c4:	01db      	lsls	r3, r3, #7
341815c6:	4413      	add	r3, r2
341815c8:	005b      	lsls	r3, r3, #1
341815ca:	4413      	add	r3, r2
341815cc:	3321      	adds	r3, #33	@ 0x21
341815ce:	099b      	lsrs	r3, r3, #6
341815d0:	021b      	lsls	r3, r3, #8
341815d2:	4319      	orrs	r1, r3
341815d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341815d6:	f003 021f 	and.w	r2, r3, #31
341815da:	4613      	mov	r3, r2
341815dc:	011b      	lsls	r3, r3, #4
341815de:	4413      	add	r3, r2
341815e0:	015a      	lsls	r2, r3, #5
341815e2:	1ad3      	subs	r3, r2, r3
341815e4:	3317      	adds	r3, #23
341815e6:	099b      	lsrs	r3, r3, #6
341815e8:	430b      	orrs	r3, r1
341815ea:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
341815ee:	613b      	str	r3, [r7, #16]
    break;
341815f0:	e02e      	b.n	34181650 <LL_FillBuffer+0xe0>
  case LCD_PIXEL_FORMAT_ARGB4444:
    output_color_mode = DMA2D_OUTPUT_ARGB4444; /* ARGB4444 */
341815f2:	2304      	movs	r3, #4
341815f4:	617b      	str	r3, [r7, #20]
    input_color = CONVERTARGB44442ARGB8888(Color);
341815f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341815f8:	0b1b      	lsrs	r3, r3, #12
341815fa:	f003 020f 	and.w	r2, r3, #15
341815fe:	4613      	mov	r3, r2
34181600:	011b      	lsls	r3, r3, #4
34181602:	4413      	add	r3, r2
34181604:	0619      	lsls	r1, r3, #24
34181606:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34181608:	0a1b      	lsrs	r3, r3, #8
3418160a:	f003 020f 	and.w	r2, r3, #15
3418160e:	4613      	mov	r3, r2
34181610:	011b      	lsls	r3, r3, #4
34181612:	4413      	add	r3, r2
34181614:	041b      	lsls	r3, r3, #16
34181616:	4319      	orrs	r1, r3
34181618:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418161a:	091b      	lsrs	r3, r3, #4
3418161c:	f003 020f 	and.w	r2, r3, #15
34181620:	4613      	mov	r3, r2
34181622:	011b      	lsls	r3, r3, #4
34181624:	4413      	add	r3, r2
34181626:	021b      	lsls	r3, r3, #8
34181628:	4319      	orrs	r1, r3
3418162a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418162c:	f003 020f 	and.w	r2, r3, #15
34181630:	4613      	mov	r3, r2
34181632:	011b      	lsls	r3, r3, #4
34181634:	4413      	add	r3, r2
34181636:	430b      	orrs	r3, r1
34181638:	613b      	str	r3, [r7, #16]
    break;
3418163a:	e009      	b.n	34181650 <LL_FillBuffer+0xe0>
  case LCD_PIXEL_FORMAT_RGB888:
    output_color_mode = DMA2D_OUTPUT_RGB888; /* RGB888 */
3418163c:	2301      	movs	r3, #1
3418163e:	617b      	str	r3, [r7, #20]
    input_color = CONVERTRGB8882ARGB8888(Color);
34181640:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34181642:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
34181646:	613b      	str	r3, [r7, #16]
    break;
34181648:	e002      	b.n	34181650 <LL_FillBuffer+0xe0>
  default:
    output_color_mode = DMA2D_OUTPUT_ARGB8888; /* ARGB8888 */
3418164a:	2300      	movs	r3, #0
3418164c:	617b      	str	r3, [r7, #20]
    break;
3418164e:	bf00      	nop
  }

  /* Register to memory mode with ARGB8888 as color Mode */
  hlcd_dma2d.Init.Mode         = DMA2D_R2M;
34181650:	4b13      	ldr	r3, [pc, #76]	@ (341816a0 <LL_FillBuffer+0x130>)
34181652:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
34181656:	605a      	str	r2, [r3, #4]
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
34181658:	4a11      	ldr	r2, [pc, #68]	@ (341816a0 <LL_FillBuffer+0x130>)
3418165a:	697b      	ldr	r3, [r7, #20]
3418165c:	6093      	str	r3, [r2, #8]
  hlcd_dma2d.Init.OutputOffset = OffLine;
3418165e:	4a10      	ldr	r2, [pc, #64]	@ (341816a0 <LL_FillBuffer+0x130>)
34181660:	6a3b      	ldr	r3, [r7, #32]
34181662:	60d3      	str	r3, [r2, #12]

  hlcd_dma2d.Instance = DMA2D;
34181664:	4b0e      	ldr	r3, [pc, #56]	@ (341816a0 <LL_FillBuffer+0x130>)
34181666:	4a0f      	ldr	r2, [pc, #60]	@ (341816a4 <LL_FillBuffer+0x134>)
34181668:	601a      	str	r2, [r3, #0]

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
3418166a:	480d      	ldr	r0, [pc, #52]	@ (341816a0 <LL_FillBuffer+0x130>)
3418166c:	f000 fed0 	bl	34182410 <HAL_DMA2D_Init>
34181670:	4603      	mov	r3, r0
34181672:	2b00      	cmp	r3, #0
34181674:	d10e      	bne.n	34181694 <LL_FillBuffer+0x124>
  {
    if (HAL_DMA2D_Start(&hlcd_dma2d, input_color, (uint32_t)pDst, xSize, ySize) == HAL_OK)
34181676:	68ba      	ldr	r2, [r7, #8]
34181678:	683b      	ldr	r3, [r7, #0]
3418167a:	9300      	str	r3, [sp, #0]
3418167c:	687b      	ldr	r3, [r7, #4]
3418167e:	6939      	ldr	r1, [r7, #16]
34181680:	4807      	ldr	r0, [pc, #28]	@ (341816a0 <LL_FillBuffer+0x130>)
34181682:	f000 ff30 	bl	341824e6 <HAL_DMA2D_Start>
34181686:	4603      	mov	r3, r0
34181688:	2b00      	cmp	r3, #0
3418168a:	d103      	bne.n	34181694 <LL_FillBuffer+0x124>
    {
      /* Polling For DMA transfer */
      (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
3418168c:	2132      	movs	r1, #50	@ 0x32
3418168e:	4804      	ldr	r0, [pc, #16]	@ (341816a0 <LL_FillBuffer+0x130>)
34181690:	f000 ff54 	bl	3418253c <HAL_DMA2D_PollForTransfer>
    }
  }
}
34181694:	bf00      	nop
34181696:	3718      	adds	r7, #24
34181698:	46bd      	mov	sp, r7
3418169a:	bd80      	pop	{r7, pc}
3418169c:	341c015c 	.word	0x341c015c
341816a0:	341c004c 	.word	0x341c004c
341816a4:	58021000 	.word	0x58021000

341816a8 <LL_ConvertLineToRGB>:
  * @param  pDst Output color
  * @param  xSize Buffer width
  * @param  ColorMode Input color mode
  */
static void LL_ConvertLineToRGB(uint32_t Instance, uint32_t *pSrc, uint32_t *pDst, uint32_t xSize, uint32_t ColorMode)
{
341816a8:	b580      	push	{r7, lr}
341816aa:	b088      	sub	sp, #32
341816ac:	af02      	add	r7, sp, #8
341816ae:	60f8      	str	r0, [r7, #12]
341816b0:	60b9      	str	r1, [r7, #8]
341816b2:	607a      	str	r2, [r7, #4]
341816b4:	603b      	str	r3, [r7, #0]
  uint32_t output_color_mode;

  switch(Lcd_Ctx[Instance].PixelFormat)
341816b6:	4a29      	ldr	r2, [pc, #164]	@ (3418175c <LL_ConvertLineToRGB+0xb4>)
341816b8:	68fb      	ldr	r3, [r7, #12]
341816ba:	015b      	lsls	r3, r3, #5
341816bc:	4413      	add	r3, r2
341816be:	330c      	adds	r3, #12
341816c0:	681b      	ldr	r3, [r3, #0]
341816c2:	2b04      	cmp	r3, #4
341816c4:	d008      	beq.n	341816d8 <LL_ConvertLineToRGB+0x30>
341816c6:	2b04      	cmp	r3, #4
341816c8:	d80c      	bhi.n	341816e4 <LL_ConvertLineToRGB+0x3c>
341816ca:	2b01      	cmp	r3, #1
341816cc:	d007      	beq.n	341816de <LL_ConvertLineToRGB+0x36>
341816ce:	2b02      	cmp	r3, #2
341816d0:	d108      	bne.n	341816e4 <LL_ConvertLineToRGB+0x3c>
  {
  case LCD_PIXEL_FORMAT_RGB565:
    output_color_mode = DMA2D_OUTPUT_RGB565; /* RGB565 */
341816d2:	2302      	movs	r3, #2
341816d4:	617b      	str	r3, [r7, #20]
    break;
341816d6:	e008      	b.n	341816ea <LL_ConvertLineToRGB+0x42>
  case LCD_PIXEL_FORMAT_ARGB4444:
    output_color_mode = DMA2D_OUTPUT_ARGB4444; /* ARGB4444 */
341816d8:	2304      	movs	r3, #4
341816da:	617b      	str	r3, [r7, #20]
    break;
341816dc:	e005      	b.n	341816ea <LL_ConvertLineToRGB+0x42>
  case LCD_PIXEL_FORMAT_RGB888:
    output_color_mode = DMA2D_OUTPUT_RGB888; /* RGB888 */
341816de:	2301      	movs	r3, #1
341816e0:	617b      	str	r3, [r7, #20]
    break;
341816e2:	e002      	b.n	341816ea <LL_ConvertLineToRGB+0x42>
  default:
    output_color_mode = DMA2D_OUTPUT_ARGB8888; /* ARGB8888 */
341816e4:	2300      	movs	r3, #0
341816e6:	617b      	str	r3, [r7, #20]
    break;
341816e8:	bf00      	nop
  }

  /* Configure the DMA2D Mode, Color Mode and output offset */
  hlcd_dma2d.Init.Mode         = DMA2D_M2M_PFC;
341816ea:	4b1d      	ldr	r3, [pc, #116]	@ (34181760 <LL_ConvertLineToRGB+0xb8>)
341816ec:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
341816f0:	605a      	str	r2, [r3, #4]
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
341816f2:	4a1b      	ldr	r2, [pc, #108]	@ (34181760 <LL_ConvertLineToRGB+0xb8>)
341816f4:	697b      	ldr	r3, [r7, #20]
341816f6:	6093      	str	r3, [r2, #8]
  hlcd_dma2d.Init.OutputOffset = 0;
341816f8:	4b19      	ldr	r3, [pc, #100]	@ (34181760 <LL_ConvertLineToRGB+0xb8>)
341816fa:	2200      	movs	r2, #0
341816fc:	60da      	str	r2, [r3, #12]

  /* Foreground Configuration */
  hlcd_dma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
341816fe:	4b18      	ldr	r3, [pc, #96]	@ (34181760 <LL_ConvertLineToRGB+0xb8>)
34181700:	2200      	movs	r2, #0
34181702:	64da      	str	r2, [r3, #76]	@ 0x4c
  hlcd_dma2d.LayerCfg[1].InputAlpha = 0xFF;
34181704:	4b16      	ldr	r3, [pc, #88]	@ (34181760 <LL_ConvertLineToRGB+0xb8>)
34181706:	22ff      	movs	r2, #255	@ 0xff
34181708:	651a      	str	r2, [r3, #80]	@ 0x50
  hlcd_dma2d.LayerCfg[1].InputColorMode = ColorMode;
3418170a:	4a15      	ldr	r2, [pc, #84]	@ (34181760 <LL_ConvertLineToRGB+0xb8>)
3418170c:	6a3b      	ldr	r3, [r7, #32]
3418170e:	6493      	str	r3, [r2, #72]	@ 0x48
  hlcd_dma2d.LayerCfg[1].InputOffset = 0;
34181710:	4b13      	ldr	r3, [pc, #76]	@ (34181760 <LL_ConvertLineToRGB+0xb8>)
34181712:	2200      	movs	r2, #0
34181714:	645a      	str	r2, [r3, #68]	@ 0x44

  hlcd_dma2d.Instance = DMA2D;
34181716:	4b12      	ldr	r3, [pc, #72]	@ (34181760 <LL_ConvertLineToRGB+0xb8>)
34181718:	4a12      	ldr	r2, [pc, #72]	@ (34181764 <LL_ConvertLineToRGB+0xbc>)
3418171a:	601a      	str	r2, [r3, #0]

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
3418171c:	4810      	ldr	r0, [pc, #64]	@ (34181760 <LL_ConvertLineToRGB+0xb8>)
3418171e:	f000 fe77 	bl	34182410 <HAL_DMA2D_Init>
34181722:	4603      	mov	r3, r0
34181724:	2b00      	cmp	r3, #0
34181726:	d115      	bne.n	34181754 <LL_ConvertLineToRGB+0xac>
  {
    if(HAL_DMA2D_ConfigLayer(&hlcd_dma2d, 1) == HAL_OK)
34181728:	2101      	movs	r1, #1
3418172a:	480d      	ldr	r0, [pc, #52]	@ (34181760 <LL_ConvertLineToRGB+0xb8>)
3418172c:	f000 fff0 	bl	34182710 <HAL_DMA2D_ConfigLayer>
34181730:	4603      	mov	r3, r0
34181732:	2b00      	cmp	r3, #0
34181734:	d10e      	bne.n	34181754 <LL_ConvertLineToRGB+0xac>
    {
      if (HAL_DMA2D_Start(&hlcd_dma2d, (uint32_t)pSrc, (uint32_t)pDst, xSize, 1) == HAL_OK)
34181736:	68b9      	ldr	r1, [r7, #8]
34181738:	687a      	ldr	r2, [r7, #4]
3418173a:	2301      	movs	r3, #1
3418173c:	9300      	str	r3, [sp, #0]
3418173e:	683b      	ldr	r3, [r7, #0]
34181740:	4807      	ldr	r0, [pc, #28]	@ (34181760 <LL_ConvertLineToRGB+0xb8>)
34181742:	f000 fed0 	bl	341824e6 <HAL_DMA2D_Start>
34181746:	4603      	mov	r3, r0
34181748:	2b00      	cmp	r3, #0
3418174a:	d103      	bne.n	34181754 <LL_ConvertLineToRGB+0xac>
      {
        /* Polling For DMA transfer */
        (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
3418174c:	2132      	movs	r1, #50	@ 0x32
3418174e:	4804      	ldr	r0, [pc, #16]	@ (34181760 <LL_ConvertLineToRGB+0xb8>)
34181750:	f000 fef4 	bl	3418253c <HAL_DMA2D_PollForTransfer>
      }
    }
  }
}
34181754:	bf00      	nop
34181756:	3718      	adds	r7, #24
34181758:	46bd      	mov	sp, r7
3418175a:	bd80      	pop	{r7, pc}
3418175c:	341c015c 	.word	0x341c015c
34181760:	341c004c 	.word	0x341c004c
34181764:	58021000 	.word	0x58021000

34181768 <LTDC_MspInit>:
  * @brief  Initialize the BSP LTDC Msp.
  * @param  hltdc  LTDC handle
  * @retval None
  */
static void LTDC_MspInit(LTDC_HandleTypeDef *hltdc)
{
34181768:	b580      	push	{r7, lr}
3418176a:	b088      	sub	sp, #32
3418176c:	af00      	add	r7, sp, #0
3418176e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef  gpio_init_structure = {0};
34181770:	f107 030c 	add.w	r3, r7, #12
34181774:	2200      	movs	r2, #0
34181776:	601a      	str	r2, [r3, #0]
34181778:	605a      	str	r2, [r3, #4]
3418177a:	609a      	str	r2, [r3, #8]
3418177c:	60da      	str	r2, [r3, #12]
3418177e:	611a      	str	r2, [r3, #16]

  if (hltdc->Instance == LTDC)
34181780:	687b      	ldr	r3, [r7, #4]
34181782:	681b      	ldr	r3, [r3, #0]
34181784:	4a4e      	ldr	r2, [pc, #312]	@ (341818c0 <LTDC_MspInit+0x158>)
34181786:	4293      	cmp	r3, r2
34181788:	f040 8095 	bne.w	341818b6 <LTDC_MspInit+0x14e>
  {
    __HAL_RCC_LTDC_CLK_ENABLE();
3418178c:	2002      	movs	r0, #2
3418178e:	f7ff f8d1 	bl	34180934 <LL_APB5_GRP1_EnableClock>

    __HAL_RCC_LTDC_FORCE_RESET();
34181792:	2002      	movs	r0, #2
34181794:	f7ff f8e4 	bl	34180960 <LL_APB5_GRP1_ForceReset>
    __HAL_RCC_LTDC_RELEASE_RESET();
34181798:	2002      	movs	r0, #2
3418179a:	f7ff f8f1 	bl	34180980 <LL_APB5_GRP1_ReleaseReset>
    /* PB13 LCD_CLK     */
    /* PQ4  LCD_INT     */
    /* PQ6  LCD_BL_CTRL */
    /* PE1  NRST        */

    __HAL_RCC_GPIOA_CLK_ENABLE();
3418179e:	2001      	movs	r0, #1
341817a0:	f7ff f878 	bl	34180894 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
341817a4:	2002      	movs	r0, #2
341817a6:	f7ff f875 	bl	34180894 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOD_CLK_ENABLE();
341817aa:	2008      	movs	r0, #8
341817ac:	f7ff f872 	bl	34180894 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOE_CLK_ENABLE();
341817b0:	2010      	movs	r0, #16
341817b2:	f7ff f86f 	bl	34180894 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOG_CLK_ENABLE();
341817b6:	2040      	movs	r0, #64	@ 0x40
341817b8:	f7ff f86c 	bl	34180894 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
341817bc:	2080      	movs	r0, #128	@ 0x80
341817be:	f7ff f869 	bl	34180894 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOQ_CLK_ENABLE();
341817c2:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
341817c6:	f7ff f865 	bl	34180894 <LL_AHB4_GRP1_EnableClock>

    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
341817ca:	2302      	movs	r3, #2
341817cc:	613b      	str	r3, [r7, #16]
    gpio_init_structure.Pull      = GPIO_NOPULL;
341817ce:	2300      	movs	r3, #0
341817d0:	617b      	str	r3, [r7, #20]
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
341817d2:	2302      	movs	r3, #2
341817d4:	61bb      	str	r3, [r7, #24]

    /* G3, G2, B7, B1, B6, R5 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
341817d6:	f248 1387 	movw	r3, #33159	@ 0x8187
341817da:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
341817dc:	230e      	movs	r3, #14
341817de:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &gpio_init_structure);
341817e0:	f107 030c 	add.w	r3, r7, #12
341817e4:	4619      	mov	r1, r3
341817e6:	4837      	ldr	r0, [pc, #220]	@ (341818c4 <LTDC_MspInit+0x15c>)
341817e8:	f001 f8e6 	bl	341829b8 <HAL_GPIO_Init>

    /* LCD_CLK, LCD_HSYNC B2, R3, G6, G5, G4 */
    gpio_init_structure.Pin       = GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_15;
341817ec:	f64f 0314 	movw	r3, #63508	@ 0xf814
341817f0:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
341817f2:	230e      	movs	r3, #14
341817f4:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOB, &gpio_init_structure);
341817f6:	f107 030c 	add.w	r3, r7, #12
341817fa:	4619      	mov	r1, r3
341817fc:	4832      	ldr	r0, [pc, #200]	@ (341818c8 <LTDC_MspInit+0x160>)
341817fe:	f001 f8db 	bl	341829b8 <HAL_GPIO_Init>

    /* R7, R1, R2 */
    gpio_init_structure.Pin       = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_15;
34181802:	f44f 4303 	mov.w	r3, #33536	@ 0x8300
34181806:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34181808:	230e      	movs	r3, #14
3418180a:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOD, &gpio_init_structure);
3418180c:	f107 030c 	add.w	r3, r7, #12
34181810:	4619      	mov	r1, r3
34181812:	482e      	ldr	r0, [pc, #184]	@ (341818cc <LTDC_MspInit+0x164>)
34181814:	f001 f8d0 	bl	341829b8 <HAL_GPIO_Init>

    /* LCD_VSYNC */
    gpio_init_structure.Pin       = GPIO_PIN_11;
34181818:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3418181c:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
3418181e:	230e      	movs	r3, #14
34181820:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34181822:	f107 030c 	add.w	r3, r7, #12
34181826:	4619      	mov	r1, r3
34181828:	4829      	ldr	r0, [pc, #164]	@ (341818d0 <LTDC_MspInit+0x168>)
3418182a:	f001 f8c5 	bl	341829b8 <HAL_GPIO_Init>

    /* R0, G1, B3, G7, R6, G0 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_6 | GPIO_PIN_8 | GPIO_PIN_11 | GPIO_PIN_12 ;
3418182e:	f641 1343 	movw	r3, #6467	@ 0x1943
34181832:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34181834:	230e      	movs	r3, #14
34181836:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34181838:	f107 030c 	add.w	r3, r7, #12
3418183c:	4619      	mov	r1, r3
3418183e:	4825      	ldr	r0, [pc, #148]	@ (341818d4 <LTDC_MspInit+0x16c>)
34181840:	f001 f8ba 	bl	341829b8 <HAL_GPIO_Init>

    /* B4, R4, B5 */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6;
34181844:	2358      	movs	r3, #88	@ 0x58
34181846:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34181848:	230e      	movs	r3, #14
3418184a:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);
3418184c:	f107 030c 	add.w	r3, r7, #12
34181850:	4619      	mov	r1, r3
34181852:	4821      	ldr	r0, [pc, #132]	@ (341818d8 <LTDC_MspInit+0x170>)
34181854:	f001 f8b0 	bl	341829b8 <HAL_GPIO_Init>

    /* NRST */
    gpio_init_structure.Pin       = GPIO_PIN_1;
34181858:	2302      	movs	r3, #2
3418185a:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3418185c:	2301      	movs	r3, #1
3418185e:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34181860:	f107 030c 	add.w	r3, r7, #12
34181864:	4619      	mov	r1, r3
34181866:	481a      	ldr	r0, [pc, #104]	@ (341818d0 <LTDC_MspInit+0x168>)
34181868:	f001 f8a6 	bl	341829b8 <HAL_GPIO_Init>

    /* LCD_ONOFF, LCD_BL_CTRL */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_6;
3418186c:	2348      	movs	r3, #72	@ 0x48
3418186e:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34181870:	2301      	movs	r3, #1
34181872:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOQ, &gpio_init_structure);
34181874:	f107 030c 	add.w	r3, r7, #12
34181878:	4619      	mov	r1, r3
3418187a:	4818      	ldr	r0, [pc, #96]	@ (341818dc <LTDC_MspInit+0x174>)
3418187c:	f001 f89c 	bl	341829b8 <HAL_GPIO_Init>

    /* LCD_DE */
    gpio_init_structure.Pin       = GPIO_PIN_13;
34181880:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34181884:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34181886:	2301      	movs	r3, #1
34181888:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
3418188a:	f107 030c 	add.w	r3, r7, #12
3418188e:	4619      	mov	r1, r3
34181890:	4810      	ldr	r0, [pc, #64]	@ (341818d4 <LTDC_MspInit+0x16c>)
34181892:	f001 f891 	bl	341829b8 <HAL_GPIO_Init>

    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_3, GPIO_PIN_SET); /* LCD On */ /* PQ3  LCD_ONOFF   */
34181896:	2201      	movs	r2, #1
34181898:	2108      	movs	r1, #8
3418189a:	4810      	ldr	r0, [pc, #64]	@ (341818dc <LTDC_MspInit+0x174>)
3418189c:	f001 fa3e 	bl	34182d1c <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13, GPIO_PIN_SET); /* Display Enable */ /* PG13 LCD_DE      */
341818a0:	2201      	movs	r2, #1
341818a2:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
341818a6:	480b      	ldr	r0, [pc, #44]	@ (341818d4 <LTDC_MspInit+0x16c>)
341818a8:	f001 fa38 	bl	34182d1c <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_6, GPIO_PIN_SET); /* 100% Brightness */ /* PQ6  LCD_BL_CTRL */
341818ac:	2201      	movs	r2, #1
341818ae:	2140      	movs	r1, #64	@ 0x40
341818b0:	480a      	ldr	r0, [pc, #40]	@ (341818dc <LTDC_MspInit+0x174>)
341818b2:	f001 fa33 	bl	34182d1c <HAL_GPIO_WritePin>

  }
}
341818b6:	bf00      	nop
341818b8:	3720      	adds	r7, #32
341818ba:	46bd      	mov	sp, r7
341818bc:	bd80      	pop	{r7, pc}
341818be:	bf00      	nop
341818c0:	58001000 	.word	0x58001000
341818c4:	56020000 	.word	0x56020000
341818c8:	56020400 	.word	0x56020400
341818cc:	56020c00 	.word	0x56020c00
341818d0:	56021000 	.word	0x56021000
341818d4:	56021800 	.word	0x56021800
341818d8:	56021c00 	.word	0x56021c00
341818dc:	56024000 	.word	0x56024000

341818e0 <DMA2D_MspInit>:
  * @brief  Initialize the BSP DMA2D Msp.
  * @param  hdma2d  DMA2D handle
  * @retval None
  */
static void DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
341818e0:	b580      	push	{r7, lr}
341818e2:	b082      	sub	sp, #8
341818e4:	af00      	add	r7, sp, #0
341818e6:	6078      	str	r0, [r7, #4]
  if(hdma2d->Instance == DMA2D)
341818e8:	687b      	ldr	r3, [r7, #4]
341818ea:	681b      	ldr	r3, [r3, #0]
341818ec:	4a07      	ldr	r2, [pc, #28]	@ (3418190c <DMA2D_MspInit+0x2c>)
341818ee:	4293      	cmp	r3, r2
341818f0:	d108      	bne.n	34181904 <DMA2D_MspInit+0x24>
  {
    /** Enable the DMA2D clock */
    __HAL_RCC_DMA2D_CLK_ENABLE();
341818f2:	2002      	movs	r0, #2
341818f4:	f7fe ffe4 	bl	341808c0 <LL_AHB5_GRP1_EnableClock>

    /** Toggle Sw reset of DMA2D IP */
    __HAL_RCC_DMA2D_FORCE_RESET();
341818f8:	2002      	movs	r0, #2
341818fa:	f7fe fff7 	bl	341808ec <LL_AHB5_GRP1_ForceReset>
    __HAL_RCC_DMA2D_RELEASE_RESET();
341818fe:	2002      	movs	r0, #2
34181900:	f7ff f804 	bl	3418090c <LL_AHB5_GRP1_ReleaseReset>
  }
}
34181904:	bf00      	nop
34181906:	3708      	adds	r7, #8
34181908:	46bd      	mov	sp, r7
3418190a:	bd80      	pop	{r7, pc}
3418190c:	58021000 	.word	0x58021000

34181910 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
34181910:	b580      	push	{r7, lr}
34181912:	b084      	sub	sp, #16
34181914:	af02      	add	r7, sp, #8
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();
34181916:	f000 fc2a 	bl	3418216e <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
3418191a:	f000 f871 	bl	34181a00 <SystemClock_Config>

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  /* USER CODE BEGIN 2 */
  BSP_LED_Init(LED_GREEN);
3418191e:	2000      	movs	r0, #0
34181920:	f7fe ff4a 	bl	341807b8 <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
34181924:	2001      	movs	r0, #1
34181926:	f7fe ff47 	bl	341807b8 <BSP_LED_Init>

  BSP_LCD_Init(0, LCD_ORIENTATION_LANDSCAPE);
3418192a:	2101      	movs	r1, #1
3418192c:	2000      	movs	r0, #0
3418192e:	f7ff f83b 	bl	341809a8 <BSP_LCD_Init>
  UTIL_LCD_SetFuncDriver(&LCD_Driver);
34181932:	4829      	ldr	r0, [pc, #164]	@ (341819d8 <main+0xc8>)
34181934:	f007 fac4 	bl	34188ec0 <UTIL_LCD_SetFuncDriver>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
34181938:	f04f 30ff 	mov.w	r0, #4294967295
3418193c:	f007 fb36 	bl	34188fac <UTIL_LCD_SetBackColor>
  UTIL_LCD_Clear(UTIL_LCD_COLOR_WHITE);
34181940:	f04f 30ff 	mov.w	r0, #4294967295
34181944:	f007 fb76 	bl	34189034 <UTIL_LCD_Clear>
  UTIL_LCD_SetFont(&UTIL_LCD_DEFAULT_FONT);
34181948:	4824      	ldr	r0, [pc, #144]	@ (341819dc <main+0xcc>)
3418194a:	f007 fb43 	bl	34188fd4 <UTIL_LCD_SetFont>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_DARKBLUE);
3418194e:	4824      	ldr	r0, [pc, #144]	@ (341819e0 <main+0xd0>)
34181950:	f007 fb18 	bl	34188f84 <UTIL_LCD_SetTextColor>
  UTIL_LCD_DisplayStringAt(0, 10, (uint8_t *)"STM32N6570-DK BSP", CENTER_MODE);
34181954:	2301      	movs	r3, #1
34181956:	4a23      	ldr	r2, [pc, #140]	@ (341819e4 <main+0xd4>)
34181958:	210a      	movs	r1, #10
3418195a:	2000      	movs	r0, #0
3418195c:	f007 fbc0 	bl	341890e0 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_DisplayStringAt(0, 35, (uint8_t *)"Drivers examples", CENTER_MODE);
34181960:	2301      	movs	r3, #1
34181962:	4a21      	ldr	r2, [pc, #132]	@ (341819e8 <main+0xd8>)
34181964:	2123      	movs	r1, #35	@ 0x23
34181966:	2000      	movs	r0, #0
34181968:	f007 fbba 	bl	341890e0 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_SetFont(&Font12);
3418196c:	481f      	ldr	r0, [pc, #124]	@ (341819ec <main+0xdc>)
3418196e:	f007 fb31 	bl	34188fd4 <UTIL_LCD_SetFont>
  uint32_t x_size;
  uint32_t y_size;
  BSP_LCD_GetXSize(0, &x_size);
34181972:	1d3b      	adds	r3, r7, #4
34181974:	4619      	mov	r1, r3
34181976:	2000      	movs	r0, #0
34181978:	f7ff fa98 	bl	34180eac <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
3418197c:	463b      	mov	r3, r7
3418197e:	4619      	mov	r1, r3
34181980:	2000      	movs	r0, #0
34181982:	f7ff fab1 	bl	34180ee8 <BSP_LCD_GetYSize>
  UTIL_LCD_DisplayStringAt(0, y_size - 20, (uint8_t *)"Copyright (c) STMicroelectronics 2024", CENTER_MODE);
34181986:	683b      	ldr	r3, [r7, #0]
34181988:	f1a3 0114 	sub.w	r1, r3, #20
3418198c:	2301      	movs	r3, #1
3418198e:	4a18      	ldr	r2, [pc, #96]	@ (341819f0 <main+0xe0>)
34181990:	2000      	movs	r0, #0
34181992:	f007 fba5 	bl	341890e0 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_SetFont(&Font16);
34181996:	4817      	ldr	r0, [pc, #92]	@ (341819f4 <main+0xe4>)
34181998:	f007 fb1c 	bl	34188fd4 <UTIL_LCD_SetFont>
  BSP_LCD_FillRect(0, 0, y_size/2 - 15, x_size, 100, UTIL_LCD_COLOR_BLUE);
3418199c:	683b      	ldr	r3, [r7, #0]
3418199e:	085b      	lsrs	r3, r3, #1
341819a0:	f1a3 020f 	sub.w	r2, r3, #15
341819a4:	687b      	ldr	r3, [r7, #4]
341819a6:	4914      	ldr	r1, [pc, #80]	@ (341819f8 <main+0xe8>)
341819a8:	9101      	str	r1, [sp, #4]
341819aa:	2164      	movs	r1, #100	@ 0x64
341819ac:	9100      	str	r1, [sp, #0]
341819ae:	2100      	movs	r1, #0
341819b0:	2000      	movs	r0, #0
341819b2:	f7ff fc41 	bl	34181238 <BSP_LCD_FillRect>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
341819b6:	f04f 30ff 	mov.w	r0, #4294967295
341819ba:	f007 fae3 	bl	34188f84 <UTIL_LCD_SetTextColor>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_BLUE);
341819be:	480e      	ldr	r0, [pc, #56]	@ (341819f8 <main+0xe8>)
341819c0:	f007 faf4 	bl	34188fac <UTIL_LCD_SetBackColor>
  UTIL_LCD_DisplayStringAt(0, y_size / 2 , (uint8_t *)"Demo ended", CENTER_MODE);
341819c4:	683b      	ldr	r3, [r7, #0]
341819c6:	0859      	lsrs	r1, r3, #1
341819c8:	2301      	movs	r3, #1
341819ca:	4a0c      	ldr	r2, [pc, #48]	@ (341819fc <main+0xec>)
341819cc:	2000      	movs	r0, #0
341819ce:	f007 fb87 	bl	341890e0 <UTIL_LCD_DisplayStringAt>
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
341819d2:	bf00      	nop
341819d4:	e7fd      	b.n	341819d2 <main+0xc2>
341819d6:	bf00      	nop
341819d8:	34189970 	.word	0x34189970
341819dc:	341c0024 	.word	0x341c0024
341819e0:	ff000080 	.word	0xff000080
341819e4:	3418990c 	.word	0x3418990c
341819e8:	34189920 	.word	0x34189920
341819ec:	341c0014 	.word	0x341c0014
341819f0:	34189934 	.word	0x34189934
341819f4:	341c001c 	.word	0x341c001c
341819f8:	ff0000ff 	.word	0xff0000ff
341819fc:	3418995c 	.word	0x3418995c

34181a00 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
34181a00:	b580      	push	{r7, lr}
34181a02:	b0b6      	sub	sp, #216	@ 0xd8
34181a04:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
34181a06:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34181a0a:	2298      	movs	r2, #152	@ 0x98
34181a0c:	2100      	movs	r1, #0
34181a0e:	4618      	mov	r0, r3
34181a10:	f007 ff44 	bl	3418989c <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
34181a14:	463b      	mov	r3, r7
34181a16:	2240      	movs	r2, #64	@ 0x40
34181a18:	2100      	movs	r1, #0
34181a1a:	4618      	mov	r0, r3
34181a1c:	f007 ff3e 	bl	3418989c <memset>

  /** Configure the System Power Supply
  */
  if (HAL_PWREx_ConfigSupply(PWR_EXTERNAL_SOURCE_SUPPLY) != HAL_OK)
34181a20:	2000      	movs	r0, #0
34181a22:	f002 fae7 	bl	34183ff4 <HAL_PWREx_ConfigSupply>
34181a26:	4603      	mov	r3, r0
34181a28:	2b00      	cmp	r3, #0
34181a2a:	d001      	beq.n	34181a30 <SystemClock_Config+0x30>
  {
    Error_Handler();
34181a2c:	f000 f88c 	bl	34181b48 <Error_Handler>
  }

  /* Enable HSI */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
34181a30:	2302      	movs	r3, #2
34181a32:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
34181a34:	2308      	movs	r3, #8
34181a36:	64fb      	str	r3, [r7, #76]	@ 0x4c
  RCC_OscInitStruct.HSIDiv = RCC_HSI_DIV1;
34181a38:	2300      	movs	r3, #0
34181a3a:	653b      	str	r3, [r7, #80]	@ 0x50
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
34181a3c:	2300      	movs	r3, #0
34181a3e:	657b      	str	r3, [r7, #84]	@ 0x54
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_NONE;
34181a40:	2300      	movs	r3, #0
34181a42:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_NONE;
34181a44:	2300      	movs	r3, #0
34181a46:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_NONE;
34181a4a:	2300      	movs	r3, #0
34181a4c:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_NONE;
34181a50:	2300      	movs	r3, #0
34181a52:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34181a56:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34181a5a:	4618      	mov	r0, r3
34181a5c:	f002 fd6c 	bl	34184538 <HAL_RCC_OscConfig>
34181a60:	4603      	mov	r3, r0
34181a62:	2b00      	cmp	r3, #0
34181a64:	d001      	beq.n	34181a6a <SystemClock_Config+0x6a>
  {
    Error_Handler();
34181a66:	f000 f86f 	bl	34181b48 <Error_Handler>
  }

  /** Get current CPU/System buses clocks configuration and if necessary switch
 to intermediate HSI clock to ensure target clock can be set
  */
  HAL_RCC_GetClockConfig(&RCC_ClkInitStruct);
34181a6a:	463b      	mov	r3, r7
34181a6c:	4618      	mov	r0, r3
34181a6e:	f003 fbc5 	bl	341851fc <HAL_RCC_GetClockConfig>
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
34181a72:	687b      	ldr	r3, [r7, #4]
34181a74:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34181a78:	d003      	beq.n	34181a82 <SystemClock_Config+0x82>
     (RCC_ClkInitStruct.SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11))
34181a7a:	68bb      	ldr	r3, [r7, #8]
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
34181a7c:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34181a80:	d10e      	bne.n	34181aa0 <SystemClock_Config+0xa0>
  {
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK);
34181a82:	2303      	movs	r3, #3
34181a84:	603b      	str	r3, [r7, #0]
    RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_HSI;
34181a86:	2300      	movs	r3, #0
34181a88:	607b      	str	r3, [r7, #4]
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
34181a8a:	2300      	movs	r3, #0
34181a8c:	60bb      	str	r3, [r7, #8]
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34181a8e:	463b      	mov	r3, r7
34181a90:	4618      	mov	r0, r3
34181a92:	f003 f931 	bl	34184cf8 <HAL_RCC_ClockConfig>
34181a96:	4603      	mov	r3, r0
34181a98:	2b00      	cmp	r3, #0
34181a9a:	d001      	beq.n	34181aa0 <SystemClock_Config+0xa0>
    {
      /* Initialization Error */
      Error_Handler();
34181a9c:	f000 f854 	bl	34181b48 <Error_Handler>
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
34181aa0:	2300      	movs	r3, #0
34181aa2:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
34181aa4:	2302      	movs	r3, #2
34181aa6:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
34181aa8:	2300      	movs	r3, #0
34181aaa:	66fb      	str	r3, [r7, #108]	@ 0x6c
  RCC_OscInitStruct.PLL1.PLLM = 4;
34181aac:	2304      	movs	r3, #4
34181aae:	673b      	str	r3, [r7, #112]	@ 0x70
  RCC_OscInitStruct.PLL1.PLLN = 75;
34181ab0:	234b      	movs	r3, #75	@ 0x4b
34181ab2:	67bb      	str	r3, [r7, #120]	@ 0x78
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
34181ab4:	2300      	movs	r3, #0
34181ab6:	677b      	str	r3, [r7, #116]	@ 0x74
  RCC_OscInitStruct.PLL1.PLLP1 = 1;
34181ab8:	2301      	movs	r3, #1
34181aba:	67fb      	str	r3, [r7, #124]	@ 0x7c
  RCC_OscInitStruct.PLL1.PLLP2 = 1;
34181abc:	2301      	movs	r3, #1
34181abe:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_NONE;
34181ac2:	2300      	movs	r3, #0
34181ac4:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_NONE;
34181ac8:	2300      	movs	r3, #0
34181aca:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_NONE;
34181ace:	2300      	movs	r3, #0
34181ad0:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34181ad4:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34181ad8:	4618      	mov	r0, r3
34181ada:	f002 fd2d 	bl	34184538 <HAL_RCC_OscConfig>
34181ade:	4603      	mov	r3, r0
34181ae0:	2b00      	cmp	r3, #0
34181ae2:	d001      	beq.n	34181ae8 <SystemClock_Config+0xe8>
  {
    Error_Handler();
34181ae4:	f000 f830 	bl	34181b48 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_CPUCLK|RCC_CLOCKTYPE_HCLK
34181ae8:	237f      	movs	r3, #127	@ 0x7f
34181aea:	603b      	str	r3, [r7, #0]
                              |RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
                              |RCC_CLOCKTYPE_PCLK2|RCC_CLOCKTYPE_PCLK5
                              |RCC_CLOCKTYPE_PCLK4;
  RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_IC1;
34181aec:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
34181af0:	607b      	str	r3, [r7, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_IC2_IC6_IC11;
34181af2:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
34181af6:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
34181af8:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
34181afc:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
34181afe:	2300      	movs	r3, #0
34181b00:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
34181b02:	2300      	movs	r3, #0
34181b04:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
34181b06:	2300      	movs	r3, #0
34181b08:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB5CLKDivider = RCC_APB5_DIV1;
34181b0a:	2300      	movs	r3, #0
34181b0c:	61fb      	str	r3, [r7, #28]
  RCC_ClkInitStruct.IC1Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34181b0e:	2300      	movs	r3, #0
34181b10:	623b      	str	r3, [r7, #32]
  RCC_ClkInitStruct.IC1Selection.ClockDivider = 3;
34181b12:	2303      	movs	r3, #3
34181b14:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_ClkInitStruct.IC2Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34181b16:	2300      	movs	r3, #0
34181b18:	62bb      	str	r3, [r7, #40]	@ 0x28
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 3;
34181b1a:	2303      	movs	r3, #3
34181b1c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  RCC_ClkInitStruct.IC6Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34181b1e:	2300      	movs	r3, #0
34181b20:	633b      	str	r3, [r7, #48]	@ 0x30
  RCC_ClkInitStruct.IC6Selection.ClockDivider = 4;
34181b22:	2304      	movs	r3, #4
34181b24:	637b      	str	r3, [r7, #52]	@ 0x34
  RCC_ClkInitStruct.IC11Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34181b26:	2300      	movs	r3, #0
34181b28:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_ClkInitStruct.IC11Selection.ClockDivider = 4;
34181b2a:	2304      	movs	r3, #4
34181b2c:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34181b2e:	463b      	mov	r3, r7
34181b30:	4618      	mov	r0, r3
34181b32:	f003 f8e1 	bl	34184cf8 <HAL_RCC_ClockConfig>
34181b36:	4603      	mov	r3, r0
34181b38:	2b00      	cmp	r3, #0
34181b3a:	d001      	beq.n	34181b40 <SystemClock_Config+0x140>
  {
    Error_Handler();
34181b3c:	f000 f804 	bl	34181b48 <Error_Handler>
  }
}
34181b40:	bf00      	nop
34181b42:	37d8      	adds	r7, #216	@ 0xd8
34181b44:	46bd      	mov	sp, r7
34181b46:	bd80      	pop	{r7, pc}

34181b48 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
34181b48:	b480      	push	{r7}
34181b4a:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
34181b4c:	b672      	cpsid	i
}
34181b4e:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
34181b50:	bf00      	nop
34181b52:	e7fd      	b.n	34181b50 <Error_Handler+0x8>

34181b54 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
34181b54:	b480      	push	{r7}
34181b56:	af00      	add	r7, sp, #0
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
34181b58:	bf00      	nop
34181b5a:	46bd      	mov	sp, r7
34181b5c:	f85d 7b04 	ldr.w	r7, [sp], #4
34181b60:	4770      	bx	lr

34181b62 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
34181b62:	b480      	push	{r7}
34181b64:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
34181b66:	bf00      	nop
34181b68:	e7fd      	b.n	34181b66 <NMI_Handler+0x4>

34181b6a <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
34181b6a:	b480      	push	{r7}
34181b6c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
34181b6e:	bf00      	nop
34181b70:	e7fd      	b.n	34181b6e <HardFault_Handler+0x4>

34181b72 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
34181b72:	b480      	push	{r7}
34181b74:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
34181b76:	bf00      	nop
34181b78:	e7fd      	b.n	34181b76 <MemManage_Handler+0x4>

34181b7a <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
34181b7a:	b480      	push	{r7}
34181b7c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
34181b7e:	bf00      	nop
34181b80:	e7fd      	b.n	34181b7e <BusFault_Handler+0x4>

34181b82 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
34181b82:	b480      	push	{r7}
34181b84:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
34181b86:	bf00      	nop
34181b88:	e7fd      	b.n	34181b86 <UsageFault_Handler+0x4>

34181b8a <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
34181b8a:	b480      	push	{r7}
34181b8c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */

  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
34181b8e:	bf00      	nop
34181b90:	e7fd      	b.n	34181b8e <SecureFault_Handler+0x4>

34181b92 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
34181b92:	b480      	push	{r7}
34181b94:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
34181b96:	bf00      	nop
34181b98:	46bd      	mov	sp, r7
34181b9a:	f85d 7b04 	ldr.w	r7, [sp], #4
34181b9e:	4770      	bx	lr

34181ba0 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
34181ba0:	b480      	push	{r7}
34181ba2:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
34181ba4:	bf00      	nop
34181ba6:	46bd      	mov	sp, r7
34181ba8:	f85d 7b04 	ldr.w	r7, [sp], #4
34181bac:	4770      	bx	lr

34181bae <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
34181bae:	b480      	push	{r7}
34181bb0:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
34181bb2:	bf00      	nop
34181bb4:	46bd      	mov	sp, r7
34181bb6:	f85d 7b04 	ldr.w	r7, [sp], #4
34181bba:	4770      	bx	lr

34181bbc <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
34181bbc:	b580      	push	{r7, lr}
34181bbe:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
34181bc0:	f000 fb20 	bl	34182204 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
34181bc4:	bf00      	nop
34181bc6:	bd80      	pop	{r7, pc}

34181bc8 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
34181bc8:	b480      	push	{r7}
34181bca:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
34181bcc:	4b6a      	ldr	r3, [pc, #424]	@ (34181d78 <SystemInit+0x1b0>)
34181bce:	4a6b      	ldr	r2, [pc, #428]	@ (34181d7c <SystemInit+0x1b4>)
34181bd0:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* RNG reset */
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
34181bd2:	4b6b      	ldr	r3, [pc, #428]	@ (34181d80 <SystemInit+0x1b8>)
34181bd4:	2201      	movs	r2, #1
34181bd6:	f8c3 2a18 	str.w	r2, [r3, #2584]	@ 0xa18
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
34181bda:	4b69      	ldr	r3, [pc, #420]	@ (34181d80 <SystemInit+0x1b8>)
34181bdc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181be0:	461a      	mov	r2, r3
34181be2:	2301      	movs	r3, #1
34181be4:	f8c2 3218 	str.w	r3, [r2, #536]	@ 0x218
  /* Deactivate RNG clock */
  RCC->AHB3ENCR = RCC_AHB3ENCR_RNGENC;
34181be8:	4b65      	ldr	r3, [pc, #404]	@ (34181d80 <SystemInit+0x1b8>)
34181bea:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181bee:	461a      	mov	r2, r3
34181bf0:	2301      	movs	r3, #1
34181bf2:	f8c2 3258 	str.w	r3, [r2, #600]	@ 0x258

  /* Clear SAU regions */
  SAU->RNR = 0;
34181bf6:	4b63      	ldr	r3, [pc, #396]	@ (34181d84 <SystemInit+0x1bc>)
34181bf8:	2200      	movs	r2, #0
34181bfa:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34181bfc:	4b61      	ldr	r3, [pc, #388]	@ (34181d84 <SystemInit+0x1bc>)
34181bfe:	2200      	movs	r2, #0
34181c00:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34181c02:	4b60      	ldr	r3, [pc, #384]	@ (34181d84 <SystemInit+0x1bc>)
34181c04:	2200      	movs	r2, #0
34181c06:	611a      	str	r2, [r3, #16]
  SAU->RNR = 1;
34181c08:	4b5e      	ldr	r3, [pc, #376]	@ (34181d84 <SystemInit+0x1bc>)
34181c0a:	2201      	movs	r2, #1
34181c0c:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34181c0e:	4b5d      	ldr	r3, [pc, #372]	@ (34181d84 <SystemInit+0x1bc>)
34181c10:	2200      	movs	r2, #0
34181c12:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34181c14:	4b5b      	ldr	r3, [pc, #364]	@ (34181d84 <SystemInit+0x1bc>)
34181c16:	2200      	movs	r2, #0
34181c18:	611a      	str	r2, [r3, #16]
  SAU->RNR = 2;
34181c1a:	4b5a      	ldr	r3, [pc, #360]	@ (34181d84 <SystemInit+0x1bc>)
34181c1c:	2202      	movs	r2, #2
34181c1e:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34181c20:	4b58      	ldr	r3, [pc, #352]	@ (34181d84 <SystemInit+0x1bc>)
34181c22:	2200      	movs	r2, #0
34181c24:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34181c26:	4b57      	ldr	r3, [pc, #348]	@ (34181d84 <SystemInit+0x1bc>)
34181c28:	2200      	movs	r2, #0
34181c2a:	611a      	str	r2, [r3, #16]
  SAU->RNR = 3;
34181c2c:	4b55      	ldr	r3, [pc, #340]	@ (34181d84 <SystemInit+0x1bc>)
34181c2e:	2203      	movs	r2, #3
34181c30:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34181c32:	4b54      	ldr	r3, [pc, #336]	@ (34181d84 <SystemInit+0x1bc>)
34181c34:	2200      	movs	r2, #0
34181c36:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34181c38:	4b52      	ldr	r3, [pc, #328]	@ (34181d84 <SystemInit+0x1bc>)
34181c3a:	2200      	movs	r2, #0
34181c3c:	611a      	str	r2, [r3, #16]
  SAU->RNR = 4;
34181c3e:	4b51      	ldr	r3, [pc, #324]	@ (34181d84 <SystemInit+0x1bc>)
34181c40:	2204      	movs	r2, #4
34181c42:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34181c44:	4b4f      	ldr	r3, [pc, #316]	@ (34181d84 <SystemInit+0x1bc>)
34181c46:	2200      	movs	r2, #0
34181c48:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34181c4a:	4b4e      	ldr	r3, [pc, #312]	@ (34181d84 <SystemInit+0x1bc>)
34181c4c:	2200      	movs	r2, #0
34181c4e:	611a      	str	r2, [r3, #16]
  SAU->RNR = 5;
34181c50:	4b4c      	ldr	r3, [pc, #304]	@ (34181d84 <SystemInit+0x1bc>)
34181c52:	2205      	movs	r2, #5
34181c54:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34181c56:	4b4b      	ldr	r3, [pc, #300]	@ (34181d84 <SystemInit+0x1bc>)
34181c58:	2200      	movs	r2, #0
34181c5a:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34181c5c:	4b49      	ldr	r3, [pc, #292]	@ (34181d84 <SystemInit+0x1bc>)
34181c5e:	2200      	movs	r2, #0
34181c60:	611a      	str	r2, [r3, #16]
  SAU->RNR = 6;
34181c62:	4b48      	ldr	r3, [pc, #288]	@ (34181d84 <SystemInit+0x1bc>)
34181c64:	2206      	movs	r2, #6
34181c66:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34181c68:	4b46      	ldr	r3, [pc, #280]	@ (34181d84 <SystemInit+0x1bc>)
34181c6a:	2200      	movs	r2, #0
34181c6c:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34181c6e:	4b45      	ldr	r3, [pc, #276]	@ (34181d84 <SystemInit+0x1bc>)
34181c70:	2200      	movs	r2, #0
34181c72:	611a      	str	r2, [r3, #16]
  SAU->RNR = 7;
34181c74:	4b43      	ldr	r3, [pc, #268]	@ (34181d84 <SystemInit+0x1bc>)
34181c76:	2207      	movs	r2, #7
34181c78:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34181c7a:	4b42      	ldr	r3, [pc, #264]	@ (34181d84 <SystemInit+0x1bc>)
34181c7c:	2200      	movs	r2, #0
34181c7e:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34181c80:	4b40      	ldr	r3, [pc, #256]	@ (34181d84 <SystemInit+0x1bc>)
34181c82:	2200      	movs	r2, #0
34181c84:	611a      	str	r2, [r3, #16]

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
34181c86:	4b3e      	ldr	r3, [pc, #248]	@ (34181d80 <SystemInit+0x1b8>)
34181c88:	2201      	movs	r2, #1
34181c8a:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
34181c8e:	4b3c      	ldr	r3, [pc, #240]	@ (34181d80 <SystemInit+0x1b8>)
34181c90:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34181c94:	4b38      	ldr	r3, [pc, #224]	@ (34181d78 <SystemInit+0x1b0>)
34181c96:	4a3c      	ldr	r2, [pc, #240]	@ (34181d88 <SystemInit+0x1c0>)
34181c98:	689b      	ldr	r3, [r3, #8]
34181c9a:	6113      	str	r3, [r2, #16]

  /* Enable VDDADC CLAMP */
  PWR->SVMCR3 |= PWR_SVMCR3_ASV;
34181c9c:	4b3b      	ldr	r3, [pc, #236]	@ (34181d8c <SystemInit+0x1c4>)
34181c9e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34181ca0:	4a3a      	ldr	r2, [pc, #232]	@ (34181d8c <SystemInit+0x1c4>)
34181ca2:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
34181ca6:	63d3      	str	r3, [r2, #60]	@ 0x3c
  PWR->SVMCR3 |= PWR_SVMCR3_AVMEN;
34181ca8:	4b38      	ldr	r3, [pc, #224]	@ (34181d8c <SystemInit+0x1c4>)
34181caa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34181cac:	4a37      	ldr	r2, [pc, #220]	@ (34181d8c <SystemInit+0x1c4>)
34181cae:	f043 0310 	orr.w	r3, r3, #16
34181cb2:	63d3      	str	r3, [r2, #60]	@ 0x3c
  /* read back the register to make sure that the transaction has taken place */
  (void) PWR->SVMCR3;
34181cb4:	4b35      	ldr	r3, [pc, #212]	@ (34181d8c <SystemInit+0x1c4>)
34181cb6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  /* enable VREF */
  RCC->APB4ENR1 |= RCC_APB4ENR1_VREFBUFEN;
34181cb8:	4b31      	ldr	r3, [pc, #196]	@ (34181d80 <SystemInit+0x1b8>)
34181cba:	f8d3 3274 	ldr.w	r3, [r3, #628]	@ 0x274
34181cbe:	4a30      	ldr	r2, [pc, #192]	@ (34181d80 <SystemInit+0x1b8>)
34181cc0:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34181cc4:	f8c2 3274 	str.w	r3, [r2, #628]	@ 0x274

  /* RCC Fix to lower power consumption */
  RCC->APB4ENR2 |= 0x00000010UL;
34181cc8:	4b2d      	ldr	r3, [pc, #180]	@ (34181d80 <SystemInit+0x1b8>)
34181cca:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
34181cce:	4a2c      	ldr	r2, [pc, #176]	@ (34181d80 <SystemInit+0x1b8>)
34181cd0:	f043 0310 	orr.w	r3, r3, #16
34181cd4:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  (void) RCC->APB4ENR2;
34181cd8:	4b29      	ldr	r3, [pc, #164]	@ (34181d80 <SystemInit+0x1b8>)
34181cda:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
  RCC->APB4ENR2 &= ~(0x00000010UL);
34181cde:	4b28      	ldr	r3, [pc, #160]	@ (34181d80 <SystemInit+0x1b8>)
34181ce0:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
34181ce4:	4a26      	ldr	r2, [pc, #152]	@ (34181d80 <SystemInit+0x1b8>)
34181ce6:	f023 0310 	bic.w	r3, r3, #16
34181cea:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278

  /* XSPI2 & XSPIM reset                                  */
  RCC->AHB5RSTSR = RCC_AHB5RSTSR_XSPIMRSTS | RCC_AHB5RSTSR_XSPI2RSTS;
34181cee:	4b24      	ldr	r3, [pc, #144]	@ (34181d80 <SystemInit+0x1b8>)
34181cf0:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
34181cf4:	f8c3 2a20 	str.w	r2, [r3, #2592]	@ 0xa20
  RCC->AHB5RSTCR = RCC_AHB5RSTCR_XSPIMRSTC | RCC_AHB5RSTCR_XSPI2RSTC;
34181cf8:	4b21      	ldr	r3, [pc, #132]	@ (34181d80 <SystemInit+0x1b8>)
34181cfa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181cfe:	461a      	mov	r2, r3
34181d00:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34181d04:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220

  /* TIM2 reset */
  RCC->APB1RSTSR1 = RCC_APB1RSTSR1_TIM2RSTS;
34181d08:	4b1d      	ldr	r3, [pc, #116]	@ (34181d80 <SystemInit+0x1b8>)
34181d0a:	2201      	movs	r2, #1
34181d0c:	f8c3 2a24 	str.w	r2, [r3, #2596]	@ 0xa24
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
34181d10:	4b1b      	ldr	r3, [pc, #108]	@ (34181d80 <SystemInit+0x1b8>)
34181d12:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181d16:	461a      	mov	r2, r3
34181d18:	2301      	movs	r3, #1
34181d1a:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
  /* Deactivate TIM2 clock */
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;
34181d1e:	4b18      	ldr	r3, [pc, #96]	@ (34181d80 <SystemInit+0x1b8>)
34181d20:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181d24:	461a      	mov	r2, r3
34181d26:	2301      	movs	r3, #1
34181d28:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264

  /* Deactivate GPIOG clock */
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34181d2c:	4b14      	ldr	r3, [pc, #80]	@ (34181d80 <SystemInit+0x1b8>)
34181d2e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181d32:	461a      	mov	r2, r3
34181d34:	2340      	movs	r3, #64	@ 0x40
34181d36:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c

  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
34181d3a:	4b13      	ldr	r3, [pc, #76]	@ (34181d88 <SystemInit+0x1c0>)
34181d3c:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34181d3e:	4b10      	ldr	r3, [pc, #64]	@ (34181d80 <SystemInit+0x1b8>)
34181d40:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181d44:	461a      	mov	r2, r3
34181d46:	2301      	movs	r3, #1
34181d48:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  TZ_SAU_Setup();
#endif /* USER_TZ_SAU_SETUP */

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34181d4c:	4b0a      	ldr	r3, [pc, #40]	@ (34181d78 <SystemInit+0x1b0>)
34181d4e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34181d52:	4a09      	ldr	r2, [pc, #36]	@ (34181d78 <SystemInit+0x1b0>)
34181d54:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34181d58:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34181d5c:	4b0c      	ldr	r3, [pc, #48]	@ (34181d90 <SystemInit+0x1c8>)
34181d5e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34181d62:	4a0b      	ldr	r2, [pc, #44]	@ (34181d90 <SystemInit+0x1c8>)
34181d64:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34181d68:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
34181d6c:	bf00      	nop
34181d6e:	46bd      	mov	sp, r7
34181d70:	f85d 7b04 	ldr.w	r7, [sp], #4
34181d74:	4770      	bx	lr
34181d76:	bf00      	nop
34181d78:	e000ed00 	.word	0xe000ed00
34181d7c:	34180400 	.word	0x34180400
34181d80:	56028000 	.word	0x56028000
34181d84:	e000edd0 	.word	0xe000edd0
34181d88:	56008000 	.word	0x56008000
34181d8c:	56024800 	.word	0x56024800
34181d90:	e002ed00 	.word	0xe002ed00

34181d94 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
34181d94:	b480      	push	{r7}
34181d96:	b08d      	sub	sp, #52	@ 0x34
34181d98:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
34181d9a:	2300      	movs	r3, #0
34181d9c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
34181d9e:	2300      	movs	r3, #0
34181da0:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
34181da2:	2300      	movs	r3, #0
34181da4:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
34181da6:	2300      	movs	r3, #0
34181da8:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
34181daa:	2300      	movs	r3, #0
34181dac:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
34181dae:	2300      	movs	r3, #0
34181db0:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34181db2:	4b9b      	ldr	r3, [pc, #620]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181db4:	6a1b      	ldr	r3, [r3, #32]
34181db6:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
34181dba:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34181dbe:	d029      	beq.n	34181e14 <SystemCoreClockUpdate+0x80>
34181dc0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34181dc4:	f200 8180 	bhi.w	341820c8 <SystemCoreClockUpdate+0x334>
34181dc8:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34181dcc:	d01f      	beq.n	34181e0e <SystemCoreClockUpdate+0x7a>
34181dce:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34181dd2:	f200 8179 	bhi.w	341820c8 <SystemCoreClockUpdate+0x334>
34181dd6:	2b00      	cmp	r3, #0
34181dd8:	d003      	beq.n	34181de2 <SystemCoreClockUpdate+0x4e>
34181dda:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34181dde:	d00a      	beq.n	34181df6 <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
34181de0:	e172      	b.n	341820c8 <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34181de2:	4b8f      	ldr	r3, [pc, #572]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181de4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34181de6:	09db      	lsrs	r3, r3, #7
34181de8:	f003 0303 	and.w	r3, r3, #3
34181dec:	4a8d      	ldr	r2, [pc, #564]	@ (34182024 <SystemCoreClockUpdate+0x290>)
34181dee:	fa22 f303 	lsr.w	r3, r2, r3
34181df2:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34181df4:	e169      	b.n	341820ca <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34181df6:	4b8a      	ldr	r3, [pc, #552]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181df8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34181dfa:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34181dfe:	2b00      	cmp	r3, #0
34181e00:	d102      	bne.n	34181e08 <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
34181e02:	4b89      	ldr	r3, [pc, #548]	@ (34182028 <SystemCoreClockUpdate+0x294>)
34181e04:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34181e06:	e160      	b.n	341820ca <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
34181e08:	4b88      	ldr	r3, [pc, #544]	@ (3418202c <SystemCoreClockUpdate+0x298>)
34181e0a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34181e0c:	e15d      	b.n	341820ca <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
34181e0e:	4b88      	ldr	r3, [pc, #544]	@ (34182030 <SystemCoreClockUpdate+0x29c>)
34181e10:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34181e12:	e15a      	b.n	341820ca <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34181e14:	4b82      	ldr	r3, [pc, #520]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181e16:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34181e1a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
34181e1e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34181e22:	d066      	beq.n	34181ef2 <SystemCoreClockUpdate+0x15e>
34181e24:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34181e28:	f200 8091 	bhi.w	34181f4e <SystemCoreClockUpdate+0x1ba>
34181e2c:	2b00      	cmp	r3, #0
34181e2e:	d003      	beq.n	34181e38 <SystemCoreClockUpdate+0xa4>
34181e30:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34181e34:	d02f      	beq.n	34181e96 <SystemCoreClockUpdate+0x102>
34181e36:	e08a      	b.n	34181f4e <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
34181e38:	4b79      	ldr	r3, [pc, #484]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181e3a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34181e3e:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
34181e40:	68fb      	ldr	r3, [r7, #12]
34181e42:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34181e46:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
34181e48:	68fb      	ldr	r3, [r7, #12]
34181e4a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34181e4e:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34181e50:	693b      	ldr	r3, [r7, #16]
34181e52:	2b00      	cmp	r3, #0
34181e54:	f040 80a9 	bne.w	34181faa <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
34181e58:	68fb      	ldr	r3, [r7, #12]
34181e5a:	0d1b      	lsrs	r3, r3, #20
34181e5c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34181e60:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
34181e62:	68fb      	ldr	r3, [r7, #12]
34181e64:	0a1b      	lsrs	r3, r3, #8
34181e66:	f3c3 030b 	ubfx	r3, r3, #0, #12
34181e6a:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34181e6c:	4b6c      	ldr	r3, [pc, #432]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181e6e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34181e72:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34181e76:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
34181e78:	4b69      	ldr	r3, [pc, #420]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181e7a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34181e7e:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
34181e80:	68fb      	ldr	r3, [r7, #12]
34181e82:	0edb      	lsrs	r3, r3, #27
34181e84:	f003 0307 	and.w	r3, r3, #7
34181e88:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
34181e8a:	68fb      	ldr	r3, [r7, #12]
34181e8c:	0e1b      	lsrs	r3, r3, #24
34181e8e:	f003 0307 	and.w	r3, r3, #7
34181e92:	61bb      	str	r3, [r7, #24]
      break;
34181e94:	e089      	b.n	34181faa <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
34181e96:	4b62      	ldr	r3, [pc, #392]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181e98:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34181e9c:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
34181e9e:	68fb      	ldr	r3, [r7, #12]
34181ea0:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34181ea4:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
34181ea6:	68fb      	ldr	r3, [r7, #12]
34181ea8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34181eac:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34181eae:	693b      	ldr	r3, [r7, #16]
34181eb0:	2b00      	cmp	r3, #0
34181eb2:	d17c      	bne.n	34181fae <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
34181eb4:	68fb      	ldr	r3, [r7, #12]
34181eb6:	0d1b      	lsrs	r3, r3, #20
34181eb8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34181ebc:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
34181ebe:	68fb      	ldr	r3, [r7, #12]
34181ec0:	0a1b      	lsrs	r3, r3, #8
34181ec2:	f3c3 030b 	ubfx	r3, r3, #0, #12
34181ec6:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34181ec8:	4b55      	ldr	r3, [pc, #340]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181eca:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34181ece:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34181ed2:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
34181ed4:	4b52      	ldr	r3, [pc, #328]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181ed6:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34181eda:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34181edc:	68fb      	ldr	r3, [r7, #12]
34181ede:	0edb      	lsrs	r3, r3, #27
34181ee0:	f003 0307 	and.w	r3, r3, #7
34181ee4:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
34181ee6:	68fb      	ldr	r3, [r7, #12]
34181ee8:	0e1b      	lsrs	r3, r3, #24
34181eea:	f003 0307 	and.w	r3, r3, #7
34181eee:	61bb      	str	r3, [r7, #24]
      break;
34181ef0:	e05d      	b.n	34181fae <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
34181ef2:	4b4b      	ldr	r3, [pc, #300]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181ef4:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34181ef8:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
34181efa:	68fb      	ldr	r3, [r7, #12]
34181efc:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34181f00:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
34181f02:	68fb      	ldr	r3, [r7, #12]
34181f04:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34181f08:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34181f0a:	693b      	ldr	r3, [r7, #16]
34181f0c:	2b00      	cmp	r3, #0
34181f0e:	d150      	bne.n	34181fb2 <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
34181f10:	68fb      	ldr	r3, [r7, #12]
34181f12:	0d1b      	lsrs	r3, r3, #20
34181f14:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34181f18:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
34181f1a:	68fb      	ldr	r3, [r7, #12]
34181f1c:	0a1b      	lsrs	r3, r3, #8
34181f1e:	f3c3 030b 	ubfx	r3, r3, #0, #12
34181f22:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34181f24:	4b3e      	ldr	r3, [pc, #248]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181f26:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34181f2a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34181f2e:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34181f30:	4b3b      	ldr	r3, [pc, #236]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181f32:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34181f36:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34181f38:	68fb      	ldr	r3, [r7, #12]
34181f3a:	0edb      	lsrs	r3, r3, #27
34181f3c:	f003 0307 	and.w	r3, r3, #7
34181f40:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
34181f42:	68fb      	ldr	r3, [r7, #12]
34181f44:	0e1b      	lsrs	r3, r3, #24
34181f46:	f003 0307 	and.w	r3, r3, #7
34181f4a:	61bb      	str	r3, [r7, #24]
      break;
34181f4c:	e031      	b.n	34181fb2 <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
34181f4e:	4b34      	ldr	r3, [pc, #208]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181f50:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34181f54:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34181f56:	68fb      	ldr	r3, [r7, #12]
34181f58:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34181f5c:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
34181f5e:	68fb      	ldr	r3, [r7, #12]
34181f60:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34181f64:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34181f66:	693b      	ldr	r3, [r7, #16]
34181f68:	2b00      	cmp	r3, #0
34181f6a:	d124      	bne.n	34181fb6 <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
34181f6c:	68fb      	ldr	r3, [r7, #12]
34181f6e:	0d1b      	lsrs	r3, r3, #20
34181f70:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34181f74:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
34181f76:	68fb      	ldr	r3, [r7, #12]
34181f78:	0a1b      	lsrs	r3, r3, #8
34181f7a:	f3c3 030b 	ubfx	r3, r3, #0, #12
34181f7e:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34181f80:	4b27      	ldr	r3, [pc, #156]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181f82:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34181f86:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34181f8a:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34181f8c:	4b24      	ldr	r3, [pc, #144]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181f8e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34181f92:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
34181f94:	68fb      	ldr	r3, [r7, #12]
34181f96:	0edb      	lsrs	r3, r3, #27
34181f98:	f003 0307 	and.w	r3, r3, #7
34181f9c:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
34181f9e:	68fb      	ldr	r3, [r7, #12]
34181fa0:	0e1b      	lsrs	r3, r3, #24
34181fa2:	f003 0307 	and.w	r3, r3, #7
34181fa6:	61bb      	str	r3, [r7, #24]
      break;
34181fa8:	e005      	b.n	34181fb6 <SystemCoreClockUpdate+0x222>
      break;
34181faa:	bf00      	nop
34181fac:	e004      	b.n	34181fb8 <SystemCoreClockUpdate+0x224>
      break;
34181fae:	bf00      	nop
34181fb0:	e002      	b.n	34181fb8 <SystemCoreClockUpdate+0x224>
      break;
34181fb2:	bf00      	nop
34181fb4:	e000      	b.n	34181fb8 <SystemCoreClockUpdate+0x224>
      break;
34181fb6:	bf00      	nop
    switch (pllsource)
34181fb8:	697b      	ldr	r3, [r7, #20]
34181fba:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34181fbe:	d02c      	beq.n	3418201a <SystemCoreClockUpdate+0x286>
34181fc0:	697b      	ldr	r3, [r7, #20]
34181fc2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34181fc6:	d839      	bhi.n	3418203c <SystemCoreClockUpdate+0x2a8>
34181fc8:	697b      	ldr	r3, [r7, #20]
34181fca:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34181fce:	d021      	beq.n	34182014 <SystemCoreClockUpdate+0x280>
34181fd0:	697b      	ldr	r3, [r7, #20]
34181fd2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34181fd6:	d831      	bhi.n	3418203c <SystemCoreClockUpdate+0x2a8>
34181fd8:	697b      	ldr	r3, [r7, #20]
34181fda:	2b00      	cmp	r3, #0
34181fdc:	d004      	beq.n	34181fe8 <SystemCoreClockUpdate+0x254>
34181fde:	697b      	ldr	r3, [r7, #20]
34181fe0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34181fe4:	d00a      	beq.n	34181ffc <SystemCoreClockUpdate+0x268>
      break;
34181fe6:	e029      	b.n	3418203c <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34181fe8:	4b0d      	ldr	r3, [pc, #52]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181fea:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34181fec:	09db      	lsrs	r3, r3, #7
34181fee:	f003 0303 	and.w	r3, r3, #3
34181ff2:	4a0c      	ldr	r2, [pc, #48]	@ (34182024 <SystemCoreClockUpdate+0x290>)
34181ff4:	fa22 f303 	lsr.w	r3, r2, r3
34181ff8:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34181ffa:	e020      	b.n	3418203e <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34181ffc:	4b08      	ldr	r3, [pc, #32]	@ (34182020 <SystemCoreClockUpdate+0x28c>)
34181ffe:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34182000:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34182004:	2b00      	cmp	r3, #0
34182006:	d102      	bne.n	3418200e <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
34182008:	4b07      	ldr	r3, [pc, #28]	@ (34182028 <SystemCoreClockUpdate+0x294>)
3418200a:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
3418200c:	e017      	b.n	3418203e <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
3418200e:	4b07      	ldr	r3, [pc, #28]	@ (3418202c <SystemCoreClockUpdate+0x298>)
34182010:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34182012:	e014      	b.n	3418203e <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
34182014:	4b06      	ldr	r3, [pc, #24]	@ (34182030 <SystemCoreClockUpdate+0x29c>)
34182016:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34182018:	e011      	b.n	3418203e <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
3418201a:	4b06      	ldr	r3, [pc, #24]	@ (34182034 <SystemCoreClockUpdate+0x2a0>)
3418201c:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
3418201e:	e00e      	b.n	3418203e <SystemCoreClockUpdate+0x2aa>
34182020:	56028000 	.word	0x56028000
34182024:	03d09000 	.word	0x03d09000
34182028:	003d0900 	.word	0x003d0900
3418202c:	00f42400 	.word	0x00f42400
34182030:	02dc6c00 	.word	0x02dc6c00
34182034:	00bb8000 	.word	0x00bb8000
34182038:	4b800000 	.word	0x4b800000
      break;
3418203c:	bf00      	nop
    if (pllbypass == 0U)
3418203e:	693b      	ldr	r3, [r7, #16]
34182040:	2b00      	cmp	r3, #0
34182042:	d134      	bne.n	341820ae <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34182044:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34182046:	ee07 3a90 	vmov	s15, r3
3418204a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3418204e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34182050:	ee07 3a90 	vmov	s15, r3
34182054:	eef8 6a67 	vcvt.f32.u32	s13, s15
34182058:	6a3b      	ldr	r3, [r7, #32]
3418205a:	ee07 3a90 	vmov	s15, r3
3418205e:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34182062:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 34182038 <SystemCoreClockUpdate+0x2a4>
34182066:	eec6 7a25 	vdiv.f32	s15, s12, s11
3418206a:	ee76 7aa7 	vadd.f32	s15, s13, s15
3418206e:	ee67 6a27 	vmul.f32	s13, s14, s15
34182072:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34182074:	ee07 3a90 	vmov	s15, r3
34182078:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3418207c:	eec6 7a87 	vdiv.f32	s15, s13, s14
34182080:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
34182084:	69fb      	ldr	r3, [r7, #28]
34182086:	ee07 3a90 	vmov	s15, r3
3418208a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3418208e:	69bb      	ldr	r3, [r7, #24]
34182090:	ee07 3a90 	vmov	s15, r3
34182094:	eef8 7a67 	vcvt.f32.u32	s15, s15
34182098:	ee27 7a27 	vmul.f32	s14, s14, s15
3418209c:	edd7 6a02 	vldr	s13, [r7, #8]
341820a0:	eec6 7a87 	vdiv.f32	s15, s13, s14
341820a4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
341820a8:	ee17 3a90 	vmov	r3, s15
341820ac:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
341820ae:	4b0b      	ldr	r3, [pc, #44]	@ (341820dc <SystemCoreClockUpdate+0x348>)
341820b0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
341820b4:	0c1b      	lsrs	r3, r3, #16
341820b6:	b2db      	uxtb	r3, r3
341820b8:	3301      	adds	r3, #1
341820ba:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
341820bc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
341820be:	687b      	ldr	r3, [r7, #4]
341820c0:	fbb2 f3f3 	udiv	r3, r2, r3
341820c4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
341820c6:	e000      	b.n	341820ca <SystemCoreClockUpdate+0x336>
    break;
341820c8:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
341820ca:	4a05      	ldr	r2, [pc, #20]	@ (341820e0 <SystemCoreClockUpdate+0x34c>)
341820cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341820ce:	6013      	str	r3, [r2, #0]
}
341820d0:	bf00      	nop
341820d2:	3734      	adds	r7, #52	@ 0x34
341820d4:	46bd      	mov	sp, r7
341820d6:	f85d 7b04 	ldr.w	r7, [sp], #4
341820da:	4770      	bx	lr
341820dc:	56028000 	.word	0x56028000
341820e0:	341c0008 	.word	0x341c0008

341820e4 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
341820e4:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
341820e8:	b588      	push	{r3, r7, lr}
341820ea:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
341820ec:	f7ff fe52 	bl	34181d94 <SystemCoreClockUpdate>

  return SystemCoreClock;
341820f0:	4b06      	ldr	r3, [pc, #24]	@ (3418210c <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
341820f2:	681b      	ldr	r3, [r3, #0]
}
341820f4:	4618      	mov	r0, r3
341820f6:	46bd      	mov	sp, r7
341820f8:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
341820fc:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34182100:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34182104:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34182108:	4774      	bxns	lr
3418210a:	bf00      	nop
3418210c:	341c0008 	.word	0x341c0008

34182110 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
34182110:	480f      	ldr	r0, [pc, #60]	@ (34182150 <LoopForever+0x4>)
  msr   MSPLIM, r0
34182112:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
34182116:	480f      	ldr	r0, [pc, #60]	@ (34182154 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
34182118:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
3418211a:	f7ff fd55 	bl	34181bc8 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
3418211e:	480e      	ldr	r0, [pc, #56]	@ (34182158 <LoopForever+0xc>)
  ldr r1, =_edata
34182120:	490e      	ldr	r1, [pc, #56]	@ (3418215c <LoopForever+0x10>)
  ldr r2, =_sidata
34182122:	4a0f      	ldr	r2, [pc, #60]	@ (34182160 <LoopForever+0x14>)
  movs r3, #0
34182124:	2300      	movs	r3, #0
  b LoopCopyDataInit
34182126:	e002      	b.n	3418212e <LoopCopyDataInit>

34182128 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
34182128:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
3418212a:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
3418212c:	3304      	adds	r3, #4

3418212e <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
3418212e:	18c4      	adds	r4, r0, r3
  cmp r4, r1
34182130:	428c      	cmp	r4, r1
  bcc CopyDataInit
34182132:	d3f9      	bcc.n	34182128 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
34182134:	4a0b      	ldr	r2, [pc, #44]	@ (34182164 <LoopForever+0x18>)
  ldr r4, =_ebss
34182136:	4c0c      	ldr	r4, [pc, #48]	@ (34182168 <LoopForever+0x1c>)
  movs r3, #0
34182138:	2300      	movs	r3, #0
  b LoopFillZerobss
3418213a:	e001      	b.n	34182140 <LoopFillZerobss>

3418213c <FillZerobss>:

FillZerobss:
  str  r3, [r2]
3418213c:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
3418213e:	3204      	adds	r2, #4

34182140 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
34182140:	42a2      	cmp	r2, r4
  bcc FillZerobss
34182142:	d3fb      	bcc.n	3418213c <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
34182144:	f007 fbb2 	bl	341898ac <__libc_init_array>
/* Call the application's entry point.*/
  bl main
34182148:	f7ff fbe2 	bl	34181910 <main>

3418214c <LoopForever>:

LoopForever:
  b LoopForever
3418214c:	e7fe      	b.n	3418214c <LoopForever>
3418214e:	0000      	.short	0x0000
  ldr   r0, =_sstack
34182150:	341ff800 	.word	0x341ff800
  ldr   r0, =_estack
34182154:	34200000 	.word	0x34200000
  ldr r0, =_sdata
34182158:	341c0000 	.word	0x341c0000
  ldr r1, =_edata
3418215c:	341c002c 	.word	0x341c002c
  ldr r2, =_sidata
34182160:	3418c4b0 	.word	0x3418c4b0
  ldr r2, =_sbss
34182164:	341c0030 	.word	0x341c0030
  ldr r4, =_ebss
34182168:	341c01ec 	.word	0x341c01ec

3418216c <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
3418216c:	e7fe      	b.n	3418216c <ADC1_2_IRQHandler>

3418216e <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
3418216e:	b580      	push	{r7, lr}
34182170:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
34182172:	2003      	movs	r0, #3
34182174:	f000 f918 	bl	341823a8 <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
34182178:	f7ff fe0c 	bl	34181d94 <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
3418217c:	200f      	movs	r0, #15
3418217e:	f000 f80b 	bl	34182198 <HAL_InitTick>
34182182:	4603      	mov	r3, r0
34182184:	2b00      	cmp	r3, #0
34182186:	d001      	beq.n	3418218c <HAL_Init+0x1e>
  {
    return HAL_ERROR;
34182188:	2301      	movs	r3, #1
3418218a:	e002      	b.n	34182192 <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
3418218c:	f7ff fce2 	bl	34181b54 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
34182190:	2300      	movs	r3, #0
}
34182192:	4618      	mov	r0, r3
34182194:	bd80      	pop	{r7, pc}
	...

34182198 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
34182198:	b580      	push	{r7, lr}
3418219a:	b082      	sub	sp, #8
3418219c:	af00      	add	r7, sp, #0
3418219e:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
341821a0:	4b15      	ldr	r3, [pc, #84]	@ (341821f8 <HAL_InitTick+0x60>)
341821a2:	781b      	ldrb	r3, [r3, #0]
341821a4:	2b00      	cmp	r3, #0
341821a6:	d101      	bne.n	341821ac <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
341821a8:	2301      	movs	r3, #1
341821aa:	e021      	b.n	341821f0 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
341821ac:	4b13      	ldr	r3, [pc, #76]	@ (341821fc <HAL_InitTick+0x64>)
341821ae:	681a      	ldr	r2, [r3, #0]
341821b0:	4b11      	ldr	r3, [pc, #68]	@ (341821f8 <HAL_InitTick+0x60>)
341821b2:	781b      	ldrb	r3, [r3, #0]
341821b4:	4619      	mov	r1, r3
341821b6:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
341821ba:	fbb3 f3f1 	udiv	r3, r3, r1
341821be:	fbb2 f3f3 	udiv	r3, r2, r3
341821c2:	4618      	mov	r0, r3
341821c4:	f000 f918 	bl	341823f8 <HAL_SYSTICK_Config>
341821c8:	4603      	mov	r3, r0
341821ca:	2b00      	cmp	r3, #0
341821cc:	d001      	beq.n	341821d2 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
341821ce:	2301      	movs	r3, #1
341821d0:	e00e      	b.n	341821f0 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
341821d2:	687b      	ldr	r3, [r7, #4]
341821d4:	2b0f      	cmp	r3, #15
341821d6:	d80a      	bhi.n	341821ee <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
341821d8:	2200      	movs	r2, #0
341821da:	6879      	ldr	r1, [r7, #4]
341821dc:	f04f 30ff 	mov.w	r0, #4294967295
341821e0:	f000 f8ed 	bl	341823be <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
341821e4:	4a06      	ldr	r2, [pc, #24]	@ (34182200 <HAL_InitTick+0x68>)
341821e6:	687b      	ldr	r3, [r7, #4]
341821e8:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
341821ea:	2300      	movs	r3, #0
341821ec:	e000      	b.n	341821f0 <HAL_InitTick+0x58>
    return HAL_ERROR;
341821ee:	2301      	movs	r3, #1
}
341821f0:	4618      	mov	r0, r3
341821f2:	3708      	adds	r7, #8
341821f4:	46bd      	mov	sp, r7
341821f6:	bd80      	pop	{r7, pc}
341821f8:	341c0010 	.word	0x341c0010
341821fc:	341c0008 	.word	0x341c0008
34182200:	341c000c 	.word	0x341c000c

34182204 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
34182204:	b480      	push	{r7}
34182206:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
34182208:	4b06      	ldr	r3, [pc, #24]	@ (34182224 <HAL_IncTick+0x20>)
3418220a:	781b      	ldrb	r3, [r3, #0]
3418220c:	461a      	mov	r2, r3
3418220e:	4b06      	ldr	r3, [pc, #24]	@ (34182228 <HAL_IncTick+0x24>)
34182210:	681b      	ldr	r3, [r3, #0]
34182212:	4413      	add	r3, r2
34182214:	4a04      	ldr	r2, [pc, #16]	@ (34182228 <HAL_IncTick+0x24>)
34182216:	6013      	str	r3, [r2, #0]
}
34182218:	bf00      	nop
3418221a:	46bd      	mov	sp, r7
3418221c:	f85d 7b04 	ldr.w	r7, [sp], #4
34182220:	4770      	bx	lr
34182222:	bf00      	nop
34182224:	341c0010 	.word	0x341c0010
34182228:	341c017c 	.word	0x341c017c

3418222c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
3418222c:	b480      	push	{r7}
3418222e:	af00      	add	r7, sp, #0
  return uwTick;
34182230:	4b03      	ldr	r3, [pc, #12]	@ (34182240 <HAL_GetTick+0x14>)
34182232:	681b      	ldr	r3, [r3, #0]
}
34182234:	4618      	mov	r0, r3
34182236:	46bd      	mov	sp, r7
34182238:	f85d 7b04 	ldr.w	r7, [sp], #4
3418223c:	4770      	bx	lr
3418223e:	bf00      	nop
34182240:	341c017c 	.word	0x341c017c

34182244 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34182244:	b480      	push	{r7}
34182246:	b085      	sub	sp, #20
34182248:	af00      	add	r7, sp, #0
3418224a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
3418224c:	687b      	ldr	r3, [r7, #4]
3418224e:	f003 0307 	and.w	r3, r3, #7
34182252:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34182254:	4b0c      	ldr	r3, [pc, #48]	@ (34182288 <__NVIC_SetPriorityGrouping+0x44>)
34182256:	68db      	ldr	r3, [r3, #12]
34182258:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
3418225a:	68ba      	ldr	r2, [r7, #8]
3418225c:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
34182260:	4013      	ands	r3, r2
34182262:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
34182264:	68fb      	ldr	r3, [r7, #12]
34182266:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
34182268:	68bb      	ldr	r3, [r7, #8]
3418226a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
3418226c:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
34182270:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34182274:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
34182276:	4a04      	ldr	r2, [pc, #16]	@ (34182288 <__NVIC_SetPriorityGrouping+0x44>)
34182278:	68bb      	ldr	r3, [r7, #8]
3418227a:	60d3      	str	r3, [r2, #12]
}
3418227c:	bf00      	nop
3418227e:	3714      	adds	r7, #20
34182280:	46bd      	mov	sp, r7
34182282:	f85d 7b04 	ldr.w	r7, [sp], #4
34182286:	4770      	bx	lr
34182288:	e000ed00 	.word	0xe000ed00

3418228c <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
3418228c:	b480      	push	{r7}
3418228e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
34182290:	4b04      	ldr	r3, [pc, #16]	@ (341822a4 <__NVIC_GetPriorityGrouping+0x18>)
34182292:	68db      	ldr	r3, [r3, #12]
34182294:	0a1b      	lsrs	r3, r3, #8
34182296:	f003 0307 	and.w	r3, r3, #7
}
3418229a:	4618      	mov	r0, r3
3418229c:	46bd      	mov	sp, r7
3418229e:	f85d 7b04 	ldr.w	r7, [sp], #4
341822a2:	4770      	bx	lr
341822a4:	e000ed00 	.word	0xe000ed00

341822a8 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
341822a8:	b480      	push	{r7}
341822aa:	b083      	sub	sp, #12
341822ac:	af00      	add	r7, sp, #0
341822ae:	4603      	mov	r3, r0
341822b0:	6039      	str	r1, [r7, #0]
341822b2:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
341822b4:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341822b8:	2b00      	cmp	r3, #0
341822ba:	db0a      	blt.n	341822d2 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
341822bc:	683b      	ldr	r3, [r7, #0]
341822be:	b2da      	uxtb	r2, r3
341822c0:	490c      	ldr	r1, [pc, #48]	@ (341822f4 <__NVIC_SetPriority+0x4c>)
341822c2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341822c6:	0112      	lsls	r2, r2, #4
341822c8:	b2d2      	uxtb	r2, r2
341822ca:	440b      	add	r3, r1
341822cc:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
341822d0:	e00a      	b.n	341822e8 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
341822d2:	683b      	ldr	r3, [r7, #0]
341822d4:	b2da      	uxtb	r2, r3
341822d6:	4908      	ldr	r1, [pc, #32]	@ (341822f8 <__NVIC_SetPriority+0x50>)
341822d8:	88fb      	ldrh	r3, [r7, #6]
341822da:	f003 030f 	and.w	r3, r3, #15
341822de:	3b04      	subs	r3, #4
341822e0:	0112      	lsls	r2, r2, #4
341822e2:	b2d2      	uxtb	r2, r2
341822e4:	440b      	add	r3, r1
341822e6:	761a      	strb	r2, [r3, #24]
}
341822e8:	bf00      	nop
341822ea:	370c      	adds	r7, #12
341822ec:	46bd      	mov	sp, r7
341822ee:	f85d 7b04 	ldr.w	r7, [sp], #4
341822f2:	4770      	bx	lr
341822f4:	e000e100 	.word	0xe000e100
341822f8:	e000ed00 	.word	0xe000ed00

341822fc <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
341822fc:	b480      	push	{r7}
341822fe:	b089      	sub	sp, #36	@ 0x24
34182300:	af00      	add	r7, sp, #0
34182302:	60f8      	str	r0, [r7, #12]
34182304:	60b9      	str	r1, [r7, #8]
34182306:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
34182308:	68fb      	ldr	r3, [r7, #12]
3418230a:	f003 0307 	and.w	r3, r3, #7
3418230e:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34182310:	69fb      	ldr	r3, [r7, #28]
34182312:	f1c3 0307 	rsb	r3, r3, #7
34182316:	2b04      	cmp	r3, #4
34182318:	bf28      	it	cs
3418231a:	2304      	movcs	r3, #4
3418231c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
3418231e:	69fb      	ldr	r3, [r7, #28]
34182320:	3304      	adds	r3, #4
34182322:	2b06      	cmp	r3, #6
34182324:	d902      	bls.n	3418232c <NVIC_EncodePriority+0x30>
34182326:	69fb      	ldr	r3, [r7, #28]
34182328:	3b03      	subs	r3, #3
3418232a:	e000      	b.n	3418232e <NVIC_EncodePriority+0x32>
3418232c:	2300      	movs	r3, #0
3418232e:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34182330:	f04f 32ff 	mov.w	r2, #4294967295
34182334:	69bb      	ldr	r3, [r7, #24]
34182336:	fa02 f303 	lsl.w	r3, r2, r3
3418233a:	43da      	mvns	r2, r3
3418233c:	68bb      	ldr	r3, [r7, #8]
3418233e:	401a      	ands	r2, r3
34182340:	697b      	ldr	r3, [r7, #20]
34182342:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34182344:	f04f 31ff 	mov.w	r1, #4294967295
34182348:	697b      	ldr	r3, [r7, #20]
3418234a:	fa01 f303 	lsl.w	r3, r1, r3
3418234e:	43d9      	mvns	r1, r3
34182350:	687b      	ldr	r3, [r7, #4]
34182352:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34182354:	4313      	orrs	r3, r2
         );
}
34182356:	4618      	mov	r0, r3
34182358:	3724      	adds	r7, #36	@ 0x24
3418235a:	46bd      	mov	sp, r7
3418235c:	f85d 7b04 	ldr.w	r7, [sp], #4
34182360:	4770      	bx	lr
	...

34182364 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
34182364:	b580      	push	{r7, lr}
34182366:	b082      	sub	sp, #8
34182368:	af00      	add	r7, sp, #0
3418236a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
3418236c:	687b      	ldr	r3, [r7, #4]
3418236e:	3b01      	subs	r3, #1
34182370:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34182374:	d301      	bcc.n	3418237a <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
34182376:	2301      	movs	r3, #1
34182378:	e00f      	b.n	3418239a <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
3418237a:	4a0a      	ldr	r2, [pc, #40]	@ (341823a4 <SysTick_Config+0x40>)
3418237c:	687b      	ldr	r3, [r7, #4]
3418237e:	3b01      	subs	r3, #1
34182380:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
34182382:	210f      	movs	r1, #15
34182384:	f04f 30ff 	mov.w	r0, #4294967295
34182388:	f7ff ff8e 	bl	341822a8 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
3418238c:	4b05      	ldr	r3, [pc, #20]	@ (341823a4 <SysTick_Config+0x40>)
3418238e:	2200      	movs	r2, #0
34182390:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34182392:	4b04      	ldr	r3, [pc, #16]	@ (341823a4 <SysTick_Config+0x40>)
34182394:	2207      	movs	r2, #7
34182396:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
34182398:	2300      	movs	r3, #0
}
3418239a:	4618      	mov	r0, r3
3418239c:	3708      	adds	r7, #8
3418239e:	46bd      	mov	sp, r7
341823a0:	bd80      	pop	{r7, pc}
341823a2:	bf00      	nop
341823a4:	e000e010 	.word	0xe000e010

341823a8 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
341823a8:	b580      	push	{r7, lr}
341823aa:	b082      	sub	sp, #8
341823ac:	af00      	add	r7, sp, #0
341823ae:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
341823b0:	6878      	ldr	r0, [r7, #4]
341823b2:	f7ff ff47 	bl	34182244 <__NVIC_SetPriorityGrouping>
}
341823b6:	bf00      	nop
341823b8:	3708      	adds	r7, #8
341823ba:	46bd      	mov	sp, r7
341823bc:	bd80      	pop	{r7, pc}

341823be <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
341823be:	b580      	push	{r7, lr}
341823c0:	b086      	sub	sp, #24
341823c2:	af00      	add	r7, sp, #0
341823c4:	4603      	mov	r3, r0
341823c6:	60b9      	str	r1, [r7, #8]
341823c8:	607a      	str	r2, [r7, #4]
341823ca:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
341823cc:	f7ff ff5e 	bl	3418228c <__NVIC_GetPriorityGrouping>
341823d0:	4603      	mov	r3, r0
341823d2:	f003 0307 	and.w	r3, r3, #7
341823d6:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
341823d8:	687a      	ldr	r2, [r7, #4]
341823da:	68b9      	ldr	r1, [r7, #8]
341823dc:	6978      	ldr	r0, [r7, #20]
341823de:	f7ff ff8d 	bl	341822fc <NVIC_EncodePriority>
341823e2:	4602      	mov	r2, r0
341823e4:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
341823e8:	4611      	mov	r1, r2
341823ea:	4618      	mov	r0, r3
341823ec:	f7ff ff5c 	bl	341822a8 <__NVIC_SetPriority>
}
341823f0:	bf00      	nop
341823f2:	3718      	adds	r7, #24
341823f4:	46bd      	mov	sp, r7
341823f6:	bd80      	pop	{r7, pc}

341823f8 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
341823f8:	b580      	push	{r7, lr}
341823fa:	b082      	sub	sp, #8
341823fc:	af00      	add	r7, sp, #0
341823fe:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
34182400:	6878      	ldr	r0, [r7, #4]
34182402:	f7ff ffaf 	bl	34182364 <SysTick_Config>
34182406:	4603      	mov	r3, r0
}
34182408:	4618      	mov	r0, r3
3418240a:	3708      	adds	r7, #8
3418240c:	46bd      	mov	sp, r7
3418240e:	bd80      	pop	{r7, pc}

34182410 <HAL_DMA2D_Init>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
34182410:	b580      	push	{r7, lr}
34182412:	b082      	sub	sp, #8
34182414:	af00      	add	r7, sp, #0
34182416:	6078      	str	r0, [r7, #4]
  /* Check the DMA2D peripheral state */
  if (hdma2d == NULL)
34182418:	687b      	ldr	r3, [r7, #4]
3418241a:	2b00      	cmp	r3, #0
3418241c:	d101      	bne.n	34182422 <HAL_DMA2D_Init+0x12>
  {
    return HAL_ERROR;
3418241e:	2301      	movs	r3, #1
34182420:	e053      	b.n	341824ca <HAL_DMA2D_Init+0xba>

    /* Init the low level hardware */
    hdma2d->MspInitCallback(hdma2d);
  }
#else
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
34182422:	687b      	ldr	r3, [r7, #4]
34182424:	f893 3061 	ldrb.w	r3, [r3, #97]	@ 0x61
34182428:	b2db      	uxtb	r3, r3
3418242a:	2b00      	cmp	r3, #0
3418242c:	d106      	bne.n	3418243c <HAL_DMA2D_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hdma2d->Lock = HAL_UNLOCKED;
3418242e:	687b      	ldr	r3, [r7, #4]
34182430:	2200      	movs	r2, #0
34182432:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
    /* Init the low level hardware */
    HAL_DMA2D_MspInit(hdma2d);
34182436:	6878      	ldr	r0, [r7, #4]
34182438:	f000 f84b 	bl	341824d2 <HAL_DMA2D_MspInit>
  }
#endif /* (USE_HAL_DMA2D_REGISTER_CALLBACKS) */

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
3418243c:	687b      	ldr	r3, [r7, #4]
3418243e:	2202      	movs	r2, #2
34182440:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* DMA2D CR register configuration -------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE | DMA2D_CR_LOM, hdma2d->Init.Mode | hdma2d->Init.LineOffsetMode);
34182444:	687b      	ldr	r3, [r7, #4]
34182446:	681b      	ldr	r3, [r3, #0]
34182448:	681b      	ldr	r3, [r3, #0]
3418244a:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3418244e:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
34182452:	687a      	ldr	r2, [r7, #4]
34182454:	6851      	ldr	r1, [r2, #4]
34182456:	687a      	ldr	r2, [r7, #4]
34182458:	69d2      	ldr	r2, [r2, #28]
3418245a:	4311      	orrs	r1, r2
3418245c:	687a      	ldr	r2, [r7, #4]
3418245e:	6812      	ldr	r2, [r2, #0]
34182460:	430b      	orrs	r3, r1
34182462:	6013      	str	r3, [r2, #0]

  /* DMA2D OPFCCR register configuration ---------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM | DMA2D_OPFCCR_SB,
34182464:	687b      	ldr	r3, [r7, #4]
34182466:	681b      	ldr	r3, [r3, #0]
34182468:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418246a:	f423 7383 	bic.w	r3, r3, #262	@ 0x106
3418246e:	f023 0301 	bic.w	r3, r3, #1
34182472:	687a      	ldr	r2, [r7, #4]
34182474:	6891      	ldr	r1, [r2, #8]
34182476:	687a      	ldr	r2, [r7, #4]
34182478:	6992      	ldr	r2, [r2, #24]
3418247a:	4311      	orrs	r1, r2
3418247c:	687a      	ldr	r2, [r7, #4]
3418247e:	6812      	ldr	r2, [r2, #0]
34182480:	430b      	orrs	r3, r1
34182482:	6353      	str	r3, [r2, #52]	@ 0x34
             hdma2d->Init.ColorMode | hdma2d->Init.BytesSwap);

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
34182484:	687b      	ldr	r3, [r7, #4]
34182486:	681b      	ldr	r3, [r3, #0]
34182488:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418248a:	0c1b      	lsrs	r3, r3, #16
3418248c:	041b      	lsls	r3, r3, #16
3418248e:	687a      	ldr	r2, [r7, #4]
34182490:	68d1      	ldr	r1, [r2, #12]
34182492:	687a      	ldr	r2, [r7, #4]
34182494:	6812      	ldr	r2, [r2, #0]
34182496:	430b      	orrs	r3, r1
34182498:	6413      	str	r3, [r2, #64]	@ 0x40
  /* DMA2D OPFCCR AI and RBS fields setting (Output Alpha Inversion)*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS),
3418249a:	687b      	ldr	r3, [r7, #4]
3418249c:	681b      	ldr	r3, [r3, #0]
3418249e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
341824a0:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
341824a4:	687b      	ldr	r3, [r7, #4]
341824a6:	691b      	ldr	r3, [r3, #16]
341824a8:	051a      	lsls	r2, r3, #20
341824aa:	687b      	ldr	r3, [r7, #4]
341824ac:	695b      	ldr	r3, [r3, #20]
341824ae:	055b      	lsls	r3, r3, #21
341824b0:	431a      	orrs	r2, r3
341824b2:	687b      	ldr	r3, [r7, #4]
341824b4:	681b      	ldr	r3, [r3, #0]
341824b6:	430a      	orrs	r2, r1
341824b8:	635a      	str	r2, [r3, #52]	@ 0x34
             ((hdma2d->Init.AlphaInverted << DMA2D_OPFCCR_AI_Pos) | \
              (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));


  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
341824ba:	687b      	ldr	r3, [r7, #4]
341824bc:	2200      	movs	r2, #0
341824be:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
341824c0:	687b      	ldr	r3, [r7, #4]
341824c2:	2201      	movs	r2, #1
341824c4:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  return HAL_OK;
341824c8:	2300      	movs	r3, #0
}
341824ca:	4618      	mov	r0, r3
341824cc:	3708      	adds	r7, #8
341824ce:	46bd      	mov	sp, r7
341824d0:	bd80      	pop	{r7, pc}

341824d2 <HAL_DMA2D_MspInit>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
341824d2:	b480      	push	{r7}
341824d4:	b083      	sub	sp, #12
341824d6:	af00      	add	r7, sp, #0
341824d8:	6078      	str	r0, [r7, #4]
  UNUSED(hdma2d);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_MspInit can be implemented in the user file.
   */
}
341824da:	bf00      	nop
341824dc:	370c      	adds	r7, #12
341824de:	46bd      	mov	sp, r7
341824e0:	f85d 7b04 	ldr.w	r7, [sp], #4
341824e4:	4770      	bx	lr

341824e6 <HAL_DMA2D_Start>:
  * @param  Height     The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                                  uint32_t Height)
{
341824e6:	b580      	push	{r7, lr}
341824e8:	b086      	sub	sp, #24
341824ea:	af02      	add	r7, sp, #8
341824ec:	60f8      	str	r0, [r7, #12]
341824ee:	60b9      	str	r1, [r7, #8]
341824f0:	607a      	str	r2, [r7, #4]
341824f2:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA2D_LINE(Height));
  assert_param(IS_DMA2D_PIXEL(Width));

  /* Process locked */
  __HAL_LOCK(hdma2d);
341824f4:	68fb      	ldr	r3, [r7, #12]
341824f6:	f893 3060 	ldrb.w	r3, [r3, #96]	@ 0x60
341824fa:	2b01      	cmp	r3, #1
341824fc:	d101      	bne.n	34182502 <HAL_DMA2D_Start+0x1c>
341824fe:	2302      	movs	r3, #2
34182500:	e018      	b.n	34182534 <HAL_DMA2D_Start+0x4e>
34182502:	68fb      	ldr	r3, [r7, #12]
34182504:	2201      	movs	r2, #1
34182506:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
3418250a:	68fb      	ldr	r3, [r7, #12]
3418250c:	2202      	movs	r2, #2
3418250e:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Configure the source, destination address and the data size */
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
34182512:	69bb      	ldr	r3, [r7, #24]
34182514:	9300      	str	r3, [sp, #0]
34182516:	683b      	ldr	r3, [r7, #0]
34182518:	687a      	ldr	r2, [r7, #4]
3418251a:	68b9      	ldr	r1, [r7, #8]
3418251c:	68f8      	ldr	r0, [r7, #12]
3418251e:	f000 f9a5 	bl	3418286c <DMA2D_SetConfig>

  /* Enable the Peripheral */
  __HAL_DMA2D_ENABLE(hdma2d);
34182522:	68fb      	ldr	r3, [r7, #12]
34182524:	681b      	ldr	r3, [r3, #0]
34182526:	681a      	ldr	r2, [r3, #0]
34182528:	68fb      	ldr	r3, [r7, #12]
3418252a:	681b      	ldr	r3, [r3, #0]
3418252c:	f042 0201 	orr.w	r2, r2, #1
34182530:	601a      	str	r2, [r3, #0]

  return HAL_OK;
34182532:	2300      	movs	r3, #0
}
34182534:	4618      	mov	r0, r3
34182536:	3710      	adds	r7, #16
34182538:	46bd      	mov	sp, r7
3418253a:	bd80      	pop	{r7, pc}

3418253c <HAL_DMA2D_PollForTransfer>:
  *                 the configuration information for the DMA2D.
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout)
{
3418253c:	b580      	push	{r7, lr}
3418253e:	b086      	sub	sp, #24
34182540:	af00      	add	r7, sp, #0
34182542:	6078      	str	r0, [r7, #4]
34182544:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  uint32_t layer_start;
  __IO uint32_t isrflags = 0x0U;
34182546:	2300      	movs	r3, #0
34182548:	60fb      	str	r3, [r7, #12]

  /* Polling for DMA2D transfer */
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
3418254a:	687b      	ldr	r3, [r7, #4]
3418254c:	681b      	ldr	r3, [r3, #0]
3418254e:	681b      	ldr	r3, [r3, #0]
34182550:	f003 0301 	and.w	r3, r3, #1
34182554:	2b00      	cmp	r3, #0
34182556:	d056      	beq.n	34182606 <HAL_DMA2D_PollForTransfer+0xca>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
34182558:	f7ff fe68 	bl	3418222c <HAL_GetTick>
3418255c:	6178      	str	r0, [r7, #20]

    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
3418255e:	e04b      	b.n	341825f8 <HAL_DMA2D_PollForTransfer+0xbc>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
34182560:	687b      	ldr	r3, [r7, #4]
34182562:	681b      	ldr	r3, [r3, #0]
34182564:	685b      	ldr	r3, [r3, #4]
34182566:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34182568:	68fb      	ldr	r3, [r7, #12]
3418256a:	f003 0321 	and.w	r3, r3, #33	@ 0x21
3418256e:	2b00      	cmp	r3, #0
34182570:	d023      	beq.n	341825ba <HAL_DMA2D_PollForTransfer+0x7e>
      {
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34182572:	68fb      	ldr	r3, [r7, #12]
34182574:	f003 0320 	and.w	r3, r3, #32
34182578:	2b00      	cmp	r3, #0
3418257a:	d005      	beq.n	34182588 <HAL_DMA2D_PollForTransfer+0x4c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
3418257c:	687b      	ldr	r3, [r7, #4]
3418257e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34182580:	f043 0202 	orr.w	r2, r3, #2
34182584:	687b      	ldr	r3, [r7, #4]
34182586:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34182588:	68fb      	ldr	r3, [r7, #12]
3418258a:	f003 0301 	and.w	r3, r3, #1
3418258e:	2b00      	cmp	r3, #0
34182590:	d005      	beq.n	3418259e <HAL_DMA2D_PollForTransfer+0x62>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34182592:	687b      	ldr	r3, [r7, #4]
34182594:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34182596:	f043 0201 	orr.w	r2, r3, #1
3418259a:	687b      	ldr	r3, [r7, #4]
3418259c:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        /* Clear the transfer and configuration error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
3418259e:	687b      	ldr	r3, [r7, #4]
341825a0:	681b      	ldr	r3, [r3, #0]
341825a2:	2221      	movs	r2, #33	@ 0x21
341825a4:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
341825a6:	687b      	ldr	r3, [r7, #4]
341825a8:	2204      	movs	r2, #4
341825aa:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
341825ae:	687b      	ldr	r3, [r7, #4]
341825b0:	2200      	movs	r2, #0
341825b2:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

        return HAL_ERROR;
341825b6:	2301      	movs	r3, #1
341825b8:	e0a5      	b.n	34182706 <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
341825ba:	683b      	ldr	r3, [r7, #0]
341825bc:	f1b3 3fff 	cmp.w	r3, #4294967295
341825c0:	d01a      	beq.n	341825f8 <HAL_DMA2D_PollForTransfer+0xbc>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
341825c2:	f7ff fe33 	bl	3418222c <HAL_GetTick>
341825c6:	4602      	mov	r2, r0
341825c8:	697b      	ldr	r3, [r7, #20]
341825ca:	1ad3      	subs	r3, r2, r3
341825cc:	683a      	ldr	r2, [r7, #0]
341825ce:	429a      	cmp	r2, r3
341825d0:	d302      	bcc.n	341825d8 <HAL_DMA2D_PollForTransfer+0x9c>
341825d2:	683b      	ldr	r3, [r7, #0]
341825d4:	2b00      	cmp	r3, #0
341825d6:	d10f      	bne.n	341825f8 <HAL_DMA2D_PollForTransfer+0xbc>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
341825d8:	687b      	ldr	r3, [r7, #4]
341825da:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
341825dc:	f043 0220 	orr.w	r2, r3, #32
341825e0:	687b      	ldr	r3, [r7, #4]
341825e2:	665a      	str	r2, [r3, #100]	@ 0x64

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
341825e4:	687b      	ldr	r3, [r7, #4]
341825e6:	2203      	movs	r2, #3
341825e8:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
341825ec:	687b      	ldr	r3, [r7, #4]
341825ee:	2200      	movs	r2, #0
341825f0:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

          return HAL_TIMEOUT;
341825f4:	2303      	movs	r3, #3
341825f6:	e086      	b.n	34182706 <HAL_DMA2D_PollForTransfer+0x1ca>
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
341825f8:	687b      	ldr	r3, [r7, #4]
341825fa:	681b      	ldr	r3, [r3, #0]
341825fc:	685b      	ldr	r3, [r3, #4]
341825fe:	f003 0302 	and.w	r3, r3, #2
34182602:	2b00      	cmp	r3, #0
34182604:	d0ac      	beq.n	34182560 <HAL_DMA2D_PollForTransfer+0x24>
        }
      }
    }
  }
  /* Polling for CLUT loading (foreground or background) */
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
34182606:	687b      	ldr	r3, [r7, #4]
34182608:	681b      	ldr	r3, [r3, #0]
3418260a:	69db      	ldr	r3, [r3, #28]
3418260c:	f003 0320 	and.w	r3, r3, #32
34182610:	613b      	str	r3, [r7, #16]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
34182612:	687b      	ldr	r3, [r7, #4]
34182614:	681b      	ldr	r3, [r3, #0]
34182616:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182618:	f003 0320 	and.w	r3, r3, #32
3418261c:	693a      	ldr	r2, [r7, #16]
3418261e:	4313      	orrs	r3, r2
34182620:	613b      	str	r3, [r7, #16]
  if (layer_start != 0U)
34182622:	693b      	ldr	r3, [r7, #16]
34182624:	2b00      	cmp	r3, #0
34182626:	d061      	beq.n	341826ec <HAL_DMA2D_PollForTransfer+0x1b0>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
34182628:	f7ff fe00 	bl	3418222c <HAL_GetTick>
3418262c:	6178      	str	r0, [r7, #20]

    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
3418262e:	e056      	b.n	341826de <HAL_DMA2D_PollForTransfer+0x1a2>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
34182630:	687b      	ldr	r3, [r7, #4]
34182632:	681b      	ldr	r3, [r3, #0]
34182634:	685b      	ldr	r3, [r3, #4]
34182636:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34182638:	68fb      	ldr	r3, [r7, #12]
3418263a:	f003 0329 	and.w	r3, r3, #41	@ 0x29
3418263e:	2b00      	cmp	r3, #0
34182640:	d02e      	beq.n	341826a0 <HAL_DMA2D_PollForTransfer+0x164>
      {
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
34182642:	68fb      	ldr	r3, [r7, #12]
34182644:	f003 0308 	and.w	r3, r3, #8
34182648:	2b00      	cmp	r3, #0
3418264a:	d005      	beq.n	34182658 <HAL_DMA2D_PollForTransfer+0x11c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
3418264c:	687b      	ldr	r3, [r7, #4]
3418264e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34182650:	f043 0204 	orr.w	r2, r3, #4
34182654:	687b      	ldr	r3, [r7, #4]
34182656:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34182658:	68fb      	ldr	r3, [r7, #12]
3418265a:	f003 0320 	and.w	r3, r3, #32
3418265e:	2b00      	cmp	r3, #0
34182660:	d005      	beq.n	3418266e <HAL_DMA2D_PollForTransfer+0x132>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34182662:	687b      	ldr	r3, [r7, #4]
34182664:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34182666:	f043 0202 	orr.w	r2, r3, #2
3418266a:	687b      	ldr	r3, [r7, #4]
3418266c:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
3418266e:	68fb      	ldr	r3, [r7, #12]
34182670:	f003 0301 	and.w	r3, r3, #1
34182674:	2b00      	cmp	r3, #0
34182676:	d005      	beq.n	34182684 <HAL_DMA2D_PollForTransfer+0x148>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34182678:	687b      	ldr	r3, [r7, #4]
3418267a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3418267c:	f043 0201 	orr.w	r2, r3, #1
34182680:	687b      	ldr	r3, [r7, #4]
34182682:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        /* Clear the CLUT Access Error, Configuration Error and Transfer Error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34182684:	687b      	ldr	r3, [r7, #4]
34182686:	681b      	ldr	r3, [r3, #0]
34182688:	2229      	movs	r2, #41	@ 0x29
3418268a:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
3418268c:	687b      	ldr	r3, [r7, #4]
3418268e:	2204      	movs	r2, #4
34182690:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
34182694:	687b      	ldr	r3, [r7, #4]
34182696:	2200      	movs	r2, #0
34182698:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

        return HAL_ERROR;
3418269c:	2301      	movs	r3, #1
3418269e:	e032      	b.n	34182706 <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
341826a0:	683b      	ldr	r3, [r7, #0]
341826a2:	f1b3 3fff 	cmp.w	r3, #4294967295
341826a6:	d01a      	beq.n	341826de <HAL_DMA2D_PollForTransfer+0x1a2>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
341826a8:	f7ff fdc0 	bl	3418222c <HAL_GetTick>
341826ac:	4602      	mov	r2, r0
341826ae:	697b      	ldr	r3, [r7, #20]
341826b0:	1ad3      	subs	r3, r2, r3
341826b2:	683a      	ldr	r2, [r7, #0]
341826b4:	429a      	cmp	r2, r3
341826b6:	d302      	bcc.n	341826be <HAL_DMA2D_PollForTransfer+0x182>
341826b8:	683b      	ldr	r3, [r7, #0]
341826ba:	2b00      	cmp	r3, #0
341826bc:	d10f      	bne.n	341826de <HAL_DMA2D_PollForTransfer+0x1a2>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
341826be:	687b      	ldr	r3, [r7, #4]
341826c0:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
341826c2:	f043 0220 	orr.w	r2, r3, #32
341826c6:	687b      	ldr	r3, [r7, #4]
341826c8:	665a      	str	r2, [r3, #100]	@ 0x64

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
341826ca:	687b      	ldr	r3, [r7, #4]
341826cc:	2203      	movs	r2, #3
341826ce:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
341826d2:	687b      	ldr	r3, [r7, #4]
341826d4:	2200      	movs	r2, #0
341826d6:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

          return HAL_TIMEOUT;
341826da:	2303      	movs	r3, #3
341826dc:	e013      	b.n	34182706 <HAL_DMA2D_PollForTransfer+0x1ca>
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
341826de:	687b      	ldr	r3, [r7, #4]
341826e0:	681b      	ldr	r3, [r3, #0]
341826e2:	685b      	ldr	r3, [r3, #4]
341826e4:	f003 0310 	and.w	r3, r3, #16
341826e8:	2b00      	cmp	r3, #0
341826ea:	d0a1      	beq.n	34182630 <HAL_DMA2D_PollForTransfer+0xf4>
      }
    }
  }

  /* Clear the transfer complete and CLUT loading flags */
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
341826ec:	687b      	ldr	r3, [r7, #4]
341826ee:	681b      	ldr	r3, [r3, #0]
341826f0:	2212      	movs	r2, #18
341826f2:	609a      	str	r2, [r3, #8]

  /* Change DMA2D state */
  hdma2d->State = HAL_DMA2D_STATE_READY;
341826f4:	687b      	ldr	r3, [r7, #4]
341826f6:	2201      	movs	r2, #1
341826f8:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
341826fc:	687b      	ldr	r3, [r7, #4]
341826fe:	2200      	movs	r2, #0
34182700:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  return HAL_OK;
34182704:	2300      	movs	r3, #0
}
34182706:	4618      	mov	r0, r3
34182708:	3718      	adds	r7, #24
3418270a:	46bd      	mov	sp, r7
3418270c:	bd80      	pop	{r7, pc}
	...

34182710 <HAL_DMA2D_ConfigLayer>:
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
{
34182710:	b480      	push	{r7}
34182712:	b087      	sub	sp, #28
34182714:	af00      	add	r7, sp, #0
34182716:	6078      	str	r0, [r7, #4]
34182718:	6039      	str	r1, [r7, #0]
  uint32_t regValue;

  /* Check the parameters */
  assert_param(IS_DMA2D_LAYER(LayerIdx));
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
  if (hdma2d->Init.Mode != DMA2D_R2M)
3418271a:	687b      	ldr	r3, [r7, #4]
3418271c:	685b      	ldr	r3, [r3, #4]
3418271e:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
    }
  }
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));

  if ((LayerIdx == DMA2D_FOREGROUND_LAYER) && (hdma2d->LayerCfg[LayerIdx].InputColorMode == DMA2D_INPUT_YCBCR))
34182722:	683b      	ldr	r3, [r7, #0]
34182724:	2b01      	cmp	r3, #1
  {
    assert_param(IS_DMA2D_CHROMA_SUB_SAMPLING(hdma2d->LayerCfg[LayerIdx].ChromaSubSampling));
  }

  /* Process locked */
  __HAL_LOCK(hdma2d);
34182726:	687b      	ldr	r3, [r7, #4]
34182728:	f893 3060 	ldrb.w	r3, [r3, #96]	@ 0x60
3418272c:	2b01      	cmp	r3, #1
3418272e:	d101      	bne.n	34182734 <HAL_DMA2D_ConfigLayer+0x24>
34182730:	2302      	movs	r3, #2
34182732:	e092      	b.n	3418285a <HAL_DMA2D_ConfigLayer+0x14a>
34182734:	687b      	ldr	r3, [r7, #4]
34182736:	2201      	movs	r2, #1
34182738:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
3418273c:	687b      	ldr	r3, [r7, #4]
3418273e:	2202      	movs	r2, #2
34182740:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
34182744:	683a      	ldr	r2, [r7, #0]
34182746:	4613      	mov	r3, r2
34182748:	00db      	lsls	r3, r3, #3
3418274a:	1a9b      	subs	r3, r3, r2
3418274c:	009b      	lsls	r3, r3, #2
3418274e:	3328      	adds	r3, #40	@ 0x28
34182750:	687a      	ldr	r2, [r7, #4]
34182752:	4413      	add	r3, r2
34182754:	60fb      	str	r3, [r7, #12]

  /* Prepare the value to be written to the BGPFCCR or FGPFCCR register */
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34182756:	68fb      	ldr	r3, [r7, #12]
34182758:	685a      	ldr	r2, [r3, #4]
3418275a:	68fb      	ldr	r3, [r7, #12]
3418275c:	689b      	ldr	r3, [r3, #8]
3418275e:	041b      	lsls	r3, r3, #16
34182760:	431a      	orrs	r2, r3
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34182762:	68fb      	ldr	r3, [r7, #12]
34182764:	691b      	ldr	r3, [r3, #16]
34182766:	051b      	lsls	r3, r3, #20
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34182768:	431a      	orrs	r2, r3
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
3418276a:	68fb      	ldr	r3, [r7, #12]
3418276c:	695b      	ldr	r3, [r3, #20]
3418276e:	055b      	lsls	r3, r3, #21
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34182770:	4313      	orrs	r3, r2
34182772:	613b      	str	r3, [r7, #16]
  regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
34182774:	4b3c      	ldr	r3, [pc, #240]	@ (34182868 <HAL_DMA2D_ConfigLayer+0x158>)
34182776:	617b      	str	r3, [r7, #20]


  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34182778:	68fb      	ldr	r3, [r7, #12]
3418277a:	685b      	ldr	r3, [r3, #4]
3418277c:	2b0a      	cmp	r3, #10
3418277e:	d003      	beq.n	34182788 <HAL_DMA2D_ConfigLayer+0x78>
34182780:	68fb      	ldr	r3, [r7, #12]
34182782:	685b      	ldr	r3, [r3, #4]
34182784:	2b09      	cmp	r3, #9
34182786:	d107      	bne.n	34182798 <HAL_DMA2D_ConfigLayer+0x88>
  {
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
34182788:	68fb      	ldr	r3, [r7, #12]
3418278a:	68db      	ldr	r3, [r3, #12]
3418278c:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
34182790:	693a      	ldr	r2, [r7, #16]
34182792:	4313      	orrs	r3, r2
34182794:	613b      	str	r3, [r7, #16]
34182796:	e005      	b.n	341827a4 <HAL_DMA2D_ConfigLayer+0x94>
  }
  else
  {
    regValue |= (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
34182798:	68fb      	ldr	r3, [r7, #12]
3418279a:	68db      	ldr	r3, [r3, #12]
3418279c:	061b      	lsls	r3, r3, #24
3418279e:	693a      	ldr	r2, [r7, #16]
341827a0:	4313      	orrs	r3, r2
341827a2:	613b      	str	r3, [r7, #16]
  }

  /* Configure the background DMA2D layer */
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
341827a4:	683b      	ldr	r3, [r7, #0]
341827a6:	2b00      	cmp	r3, #0
341827a8:	d120      	bne.n	341827ec <HAL_DMA2D_ConfigLayer+0xdc>
  {
    /* Write DMA2D BGPFCCR register */
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
341827aa:	687b      	ldr	r3, [r7, #4]
341827ac:	681b      	ldr	r3, [r3, #0]
341827ae:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
341827b0:	697b      	ldr	r3, [r7, #20]
341827b2:	43db      	mvns	r3, r3
341827b4:	ea02 0103 	and.w	r1, r2, r3
341827b8:	687b      	ldr	r3, [r7, #4]
341827ba:	681b      	ldr	r3, [r3, #0]
341827bc:	693a      	ldr	r2, [r7, #16]
341827be:	430a      	orrs	r2, r1
341827c0:	625a      	str	r2, [r3, #36]	@ 0x24

    /* DMA2D BGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
341827c2:	687b      	ldr	r3, [r7, #4]
341827c4:	681b      	ldr	r3, [r3, #0]
341827c6:	68fa      	ldr	r2, [r7, #12]
341827c8:	6812      	ldr	r2, [r2, #0]
341827ca:	619a      	str	r2, [r3, #24]

    /* DMA2D BGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
341827cc:	68fb      	ldr	r3, [r7, #12]
341827ce:	685b      	ldr	r3, [r3, #4]
341827d0:	2b0a      	cmp	r3, #10
341827d2:	d003      	beq.n	341827dc <HAL_DMA2D_ConfigLayer+0xcc>
341827d4:	68fb      	ldr	r3, [r7, #12]
341827d6:	685b      	ldr	r3, [r3, #4]
341827d8:	2b09      	cmp	r3, #9
341827da:	d135      	bne.n	34182848 <HAL_DMA2D_ConfigLayer+0x138>
    {
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
341827dc:	68fb      	ldr	r3, [r7, #12]
341827de:	68da      	ldr	r2, [r3, #12]
341827e0:	687b      	ldr	r3, [r7, #4]
341827e2:	681b      	ldr	r3, [r3, #0]
341827e4:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
341827e8:	629a      	str	r2, [r3, #40]	@ 0x28
341827ea:	e02d      	b.n	34182848 <HAL_DMA2D_ConfigLayer+0x138>
  }
  /* Configure the foreground DMA2D layer */
  else
  {

    if (pLayerCfg->InputColorMode == DMA2D_INPUT_YCBCR)
341827ec:	68fb      	ldr	r3, [r7, #12]
341827ee:	685b      	ldr	r3, [r3, #4]
341827f0:	2b0b      	cmp	r3, #11
341827f2:	d109      	bne.n	34182808 <HAL_DMA2D_ConfigLayer+0xf8>
    {
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
341827f4:	68fb      	ldr	r3, [r7, #12]
341827f6:	699b      	ldr	r3, [r3, #24]
341827f8:	049b      	lsls	r3, r3, #18
341827fa:	693a      	ldr	r2, [r7, #16]
341827fc:	4313      	orrs	r3, r2
341827fe:	613b      	str	r3, [r7, #16]
      regMask  |= DMA2D_FGPFCCR_CSS;
34182800:	697b      	ldr	r3, [r7, #20]
34182802:	f443 2340 	orr.w	r3, r3, #786432	@ 0xc0000
34182806:	617b      	str	r3, [r7, #20]
    }

    /* Write DMA2D FGPFCCR register */
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
34182808:	687b      	ldr	r3, [r7, #4]
3418280a:	681b      	ldr	r3, [r3, #0]
3418280c:	69da      	ldr	r2, [r3, #28]
3418280e:	697b      	ldr	r3, [r7, #20]
34182810:	43db      	mvns	r3, r3
34182812:	ea02 0103 	and.w	r1, r2, r3
34182816:	687b      	ldr	r3, [r7, #4]
34182818:	681b      	ldr	r3, [r3, #0]
3418281a:	693a      	ldr	r2, [r7, #16]
3418281c:	430a      	orrs	r2, r1
3418281e:	61da      	str	r2, [r3, #28]

    /* DMA2D FGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
34182820:	687b      	ldr	r3, [r7, #4]
34182822:	681b      	ldr	r3, [r3, #0]
34182824:	68fa      	ldr	r2, [r7, #12]
34182826:	6812      	ldr	r2, [r2, #0]
34182828:	611a      	str	r2, [r3, #16]

    /* DMA2D FGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
3418282a:	68fb      	ldr	r3, [r7, #12]
3418282c:	685b      	ldr	r3, [r3, #4]
3418282e:	2b0a      	cmp	r3, #10
34182830:	d003      	beq.n	3418283a <HAL_DMA2D_ConfigLayer+0x12a>
34182832:	68fb      	ldr	r3, [r7, #12]
34182834:	685b      	ldr	r3, [r3, #4]
34182836:	2b09      	cmp	r3, #9
34182838:	d106      	bne.n	34182848 <HAL_DMA2D_ConfigLayer+0x138>
    {
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
3418283a:	68fb      	ldr	r3, [r7, #12]
3418283c:	68da      	ldr	r2, [r3, #12]
3418283e:	687b      	ldr	r3, [r7, #4]
34182840:	681b      	ldr	r3, [r3, #0]
34182842:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
34182846:	621a      	str	r2, [r3, #32]
                                                                   DMA2D_FGCOLR_RED));
    }
  }
  /* Initialize the DMA2D state*/
  hdma2d->State = HAL_DMA2D_STATE_READY;
34182848:	687b      	ldr	r3, [r7, #4]
3418284a:	2201      	movs	r2, #1
3418284c:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
34182850:	687b      	ldr	r3, [r7, #4]
34182852:	2200      	movs	r2, #0
34182854:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  return HAL_OK;
34182858:	2300      	movs	r3, #0
}
3418285a:	4618      	mov	r0, r3
3418285c:	371c      	adds	r7, #28
3418285e:	46bd      	mov	sp, r7
34182860:	f85d 7b04 	ldr.w	r7, [sp], #4
34182864:	4770      	bx	lr
34182866:	bf00      	nop
34182868:	ff33000f 	.word	0xff33000f

3418286c <DMA2D_SetConfig>:
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                            uint32_t Height)
{
3418286c:	b480      	push	{r7}
3418286e:	b08b      	sub	sp, #44	@ 0x2c
34182870:	af00      	add	r7, sp, #0
34182872:	60f8      	str	r0, [r7, #12]
34182874:	60b9      	str	r1, [r7, #8]
34182876:	607a      	str	r2, [r7, #4]
34182878:	603b      	str	r3, [r7, #0]
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
3418287a:	68fb      	ldr	r3, [r7, #12]
3418287c:	681b      	ldr	r3, [r3, #0]
3418287e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34182880:	f003 4140 	and.w	r1, r3, #3221225472	@ 0xc0000000
34182884:	683b      	ldr	r3, [r7, #0]
34182886:	041a      	lsls	r2, r3, #16
34182888:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418288a:	431a      	orrs	r2, r3
3418288c:	68fb      	ldr	r3, [r7, #12]
3418288e:	681b      	ldr	r3, [r3, #0]
34182890:	430a      	orrs	r2, r1
34182892:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
34182894:	68fb      	ldr	r3, [r7, #12]
34182896:	681b      	ldr	r3, [r3, #0]
34182898:	687a      	ldr	r2, [r7, #4]
3418289a:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
3418289c:	68fb      	ldr	r3, [r7, #12]
3418289e:	685b      	ldr	r3, [r3, #4]
341828a0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
341828a4:	d174      	bne.n	34182990 <DMA2D_SetConfig+0x124>
  {
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
341828a6:	68bb      	ldr	r3, [r7, #8]
341828a8:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
341828ac:	623b      	str	r3, [r7, #32]
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
341828ae:	68bb      	ldr	r3, [r7, #8]
341828b0:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
341828b4:	61fb      	str	r3, [r7, #28]
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
341828b6:	68bb      	ldr	r3, [r7, #8]
341828b8:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
341828bc:	61bb      	str	r3, [r7, #24]
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
341828be:	68bb      	ldr	r3, [r7, #8]
341828c0:	b2db      	uxtb	r3, r3
341828c2:	617b      	str	r3, [r7, #20]

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
341828c4:	68fb      	ldr	r3, [r7, #12]
341828c6:	689b      	ldr	r3, [r3, #8]
341828c8:	2b00      	cmp	r3, #0
341828ca:	d108      	bne.n	341828de <DMA2D_SetConfig+0x72>
    {
      tmp = (tmp3 | tmp2 | tmp1 | tmp4);
341828cc:	69ba      	ldr	r2, [r7, #24]
341828ce:	69fb      	ldr	r3, [r7, #28]
341828d0:	431a      	orrs	r2, r3
341828d2:	6a3b      	ldr	r3, [r7, #32]
341828d4:	4313      	orrs	r3, r2
341828d6:	697a      	ldr	r2, [r7, #20]
341828d8:	4313      	orrs	r3, r2
341828da:	627b      	str	r3, [r7, #36]	@ 0x24
341828dc:	e053      	b.n	34182986 <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
341828de:	68fb      	ldr	r3, [r7, #12]
341828e0:	689b      	ldr	r3, [r3, #8]
341828e2:	2b01      	cmp	r3, #1
341828e4:	d106      	bne.n	341828f4 <DMA2D_SetConfig+0x88>
    {
      tmp = (tmp3 | tmp2 | tmp4);
341828e6:	69ba      	ldr	r2, [r7, #24]
341828e8:	69fb      	ldr	r3, [r7, #28]
341828ea:	4313      	orrs	r3, r2
341828ec:	697a      	ldr	r2, [r7, #20]
341828ee:	4313      	orrs	r3, r2
341828f0:	627b      	str	r3, [r7, #36]	@ 0x24
341828f2:	e048      	b.n	34182986 <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
341828f4:	68fb      	ldr	r3, [r7, #12]
341828f6:	689b      	ldr	r3, [r3, #8]
341828f8:	2b02      	cmp	r3, #2
341828fa:	d111      	bne.n	34182920 <DMA2D_SetConfig+0xb4>
    {
      tmp2 = (tmp2 >> 19U);
341828fc:	69fb      	ldr	r3, [r7, #28]
341828fe:	0cdb      	lsrs	r3, r3, #19
34182900:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 10U);
34182902:	69bb      	ldr	r3, [r7, #24]
34182904:	0a9b      	lsrs	r3, r3, #10
34182906:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
34182908:	697b      	ldr	r3, [r7, #20]
3418290a:	08db      	lsrs	r3, r3, #3
3418290c:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
3418290e:	69bb      	ldr	r3, [r7, #24]
34182910:	015a      	lsls	r2, r3, #5
34182912:	69fb      	ldr	r3, [r7, #28]
34182914:	02db      	lsls	r3, r3, #11
34182916:	4313      	orrs	r3, r2
34182918:	697a      	ldr	r2, [r7, #20]
3418291a:	4313      	orrs	r3, r2
3418291c:	627b      	str	r3, [r7, #36]	@ 0x24
3418291e:	e032      	b.n	34182986 <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
34182920:	68fb      	ldr	r3, [r7, #12]
34182922:	689b      	ldr	r3, [r3, #8]
34182924:	2b03      	cmp	r3, #3
34182926:	d117      	bne.n	34182958 <DMA2D_SetConfig+0xec>
    {
      tmp1 = (tmp1 >> 31U);
34182928:	6a3b      	ldr	r3, [r7, #32]
3418292a:	0fdb      	lsrs	r3, r3, #31
3418292c:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 19U);
3418292e:	69fb      	ldr	r3, [r7, #28]
34182930:	0cdb      	lsrs	r3, r3, #19
34182932:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 11U);
34182934:	69bb      	ldr	r3, [r7, #24]
34182936:	0adb      	lsrs	r3, r3, #11
34182938:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
3418293a:	697b      	ldr	r3, [r7, #20]
3418293c:	08db      	lsrs	r3, r3, #3
3418293e:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
34182940:	69bb      	ldr	r3, [r7, #24]
34182942:	015a      	lsls	r2, r3, #5
34182944:	69fb      	ldr	r3, [r7, #28]
34182946:	029b      	lsls	r3, r3, #10
34182948:	431a      	orrs	r2, r3
3418294a:	6a3b      	ldr	r3, [r7, #32]
3418294c:	03db      	lsls	r3, r3, #15
3418294e:	4313      	orrs	r3, r2
34182950:	697a      	ldr	r2, [r7, #20]
34182952:	4313      	orrs	r3, r2
34182954:	627b      	str	r3, [r7, #36]	@ 0x24
34182956:	e016      	b.n	34182986 <DMA2D_SetConfig+0x11a>
    }
    else /* Dhdma2d->Init.ColorMode = DMA2D_OUTPUT_ARGB4444 */
    {
      tmp1 = (tmp1 >> 28U);
34182958:	6a3b      	ldr	r3, [r7, #32]
3418295a:	0f1b      	lsrs	r3, r3, #28
3418295c:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 20U);
3418295e:	69fb      	ldr	r3, [r7, #28]
34182960:	0d1b      	lsrs	r3, r3, #20
34182962:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 12U);
34182964:	69bb      	ldr	r3, [r7, #24]
34182966:	0b1b      	lsrs	r3, r3, #12
34182968:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 4U);
3418296a:	697b      	ldr	r3, [r7, #20]
3418296c:	091b      	lsrs	r3, r3, #4
3418296e:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
34182970:	69bb      	ldr	r3, [r7, #24]
34182972:	011a      	lsls	r2, r3, #4
34182974:	69fb      	ldr	r3, [r7, #28]
34182976:	021b      	lsls	r3, r3, #8
34182978:	431a      	orrs	r2, r3
3418297a:	6a3b      	ldr	r3, [r7, #32]
3418297c:	031b      	lsls	r3, r3, #12
3418297e:	4313      	orrs	r3, r2
34182980:	697a      	ldr	r2, [r7, #20]
34182982:	4313      	orrs	r3, r2
34182984:	627b      	str	r3, [r7, #36]	@ 0x24
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
34182986:	68fb      	ldr	r3, [r7, #12]
34182988:	681b      	ldr	r3, [r3, #0]
3418298a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3418298c:	639a      	str	r2, [r3, #56]	@ 0x38
  else /* M2M, M2M_PFC,M2M_Blending or M2M_blending with fixed color BG DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
3418298e:	e00d      	b.n	341829ac <DMA2D_SetConfig+0x140>
  else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG) /*M2M_blending with fixed color FG DMA2D Mode selected*/
34182990:	68fb      	ldr	r3, [r7, #12]
34182992:	685b      	ldr	r3, [r3, #4]
34182994:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34182998:	d104      	bne.n	341829a4 <DMA2D_SetConfig+0x138>
    WRITE_REG(hdma2d->Instance->BGMAR, pdata);
3418299a:	68fb      	ldr	r3, [r7, #12]
3418299c:	681b      	ldr	r3, [r3, #0]
3418299e:	68ba      	ldr	r2, [r7, #8]
341829a0:	615a      	str	r2, [r3, #20]
}
341829a2:	e003      	b.n	341829ac <DMA2D_SetConfig+0x140>
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
341829a4:	68fb      	ldr	r3, [r7, #12]
341829a6:	681b      	ldr	r3, [r3, #0]
341829a8:	68ba      	ldr	r2, [r7, #8]
341829aa:	60da      	str	r2, [r3, #12]
}
341829ac:	bf00      	nop
341829ae:	372c      	adds	r7, #44	@ 0x2c
341829b0:	46bd      	mov	sp, r7
341829b2:	f85d 7b04 	ldr.w	r7, [sp], #4
341829b6:	4770      	bx	lr

341829b8 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
341829b8:	b480      	push	{r7}
341829ba:	b087      	sub	sp, #28
341829bc:	af00      	add	r7, sp, #0
341829be:	6078      	str	r0, [r7, #4]
341829c0:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
341829c2:	2300      	movs	r3, #0
341829c4:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
341829c6:	e180      	b.n	34182cca <HAL_GPIO_Init+0x312>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
341829c8:	683b      	ldr	r3, [r7, #0]
341829ca:	681a      	ldr	r2, [r3, #0]
341829cc:	2101      	movs	r1, #1
341829ce:	697b      	ldr	r3, [r7, #20]
341829d0:	fa01 f303 	lsl.w	r3, r1, r3
341829d4:	4013      	ands	r3, r2
341829d6:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
341829d8:	68fb      	ldr	r3, [r7, #12]
341829da:	2b00      	cmp	r3, #0
341829dc:	f000 8172 	beq.w	34182cc4 <HAL_GPIO_Init+0x30c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
341829e0:	683b      	ldr	r3, [r7, #0]
341829e2:	685b      	ldr	r3, [r3, #4]
341829e4:	f003 0303 	and.w	r3, r3, #3
341829e8:	2b01      	cmp	r3, #1
341829ea:	d005      	beq.n	341829f8 <HAL_GPIO_Init+0x40>
341829ec:	683b      	ldr	r3, [r7, #0]
341829ee:	685b      	ldr	r3, [r3, #4]
341829f0:	f003 0303 	and.w	r3, r3, #3
341829f4:	2b02      	cmp	r3, #2
341829f6:	d130      	bne.n	34182a5a <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
341829f8:	687b      	ldr	r3, [r7, #4]
341829fa:	689b      	ldr	r3, [r3, #8]
341829fc:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
341829fe:	697b      	ldr	r3, [r7, #20]
34182a00:	005b      	lsls	r3, r3, #1
34182a02:	2203      	movs	r2, #3
34182a04:	fa02 f303 	lsl.w	r3, r2, r3
34182a08:	43db      	mvns	r3, r3
34182a0a:	693a      	ldr	r2, [r7, #16]
34182a0c:	4013      	ands	r3, r2
34182a0e:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34182a10:	683b      	ldr	r3, [r7, #0]
34182a12:	68da      	ldr	r2, [r3, #12]
34182a14:	697b      	ldr	r3, [r7, #20]
34182a16:	005b      	lsls	r3, r3, #1
34182a18:	fa02 f303 	lsl.w	r3, r2, r3
34182a1c:	693a      	ldr	r2, [r7, #16]
34182a1e:	4313      	orrs	r3, r2
34182a20:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
34182a22:	687b      	ldr	r3, [r7, #4]
34182a24:	693a      	ldr	r2, [r7, #16]
34182a26:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
34182a28:	687b      	ldr	r3, [r7, #4]
34182a2a:	685b      	ldr	r3, [r3, #4]
34182a2c:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
34182a2e:	2201      	movs	r2, #1
34182a30:	697b      	ldr	r3, [r7, #20]
34182a32:	fa02 f303 	lsl.w	r3, r2, r3
34182a36:	43db      	mvns	r3, r3
34182a38:	693a      	ldr	r2, [r7, #16]
34182a3a:	4013      	ands	r3, r2
34182a3c:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34182a3e:	683b      	ldr	r3, [r7, #0]
34182a40:	685b      	ldr	r3, [r3, #4]
34182a42:	091b      	lsrs	r3, r3, #4
34182a44:	f003 0201 	and.w	r2, r3, #1
34182a48:	697b      	ldr	r3, [r7, #20]
34182a4a:	fa02 f303 	lsl.w	r3, r2, r3
34182a4e:	693a      	ldr	r2, [r7, #16]
34182a50:	4313      	orrs	r3, r2
34182a52:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
34182a54:	687b      	ldr	r3, [r7, #4]
34182a56:	693a      	ldr	r2, [r7, #16]
34182a58:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34182a5a:	683b      	ldr	r3, [r7, #0]
34182a5c:	685b      	ldr	r3, [r3, #4]
34182a5e:	f003 0303 	and.w	r3, r3, #3
34182a62:	2b03      	cmp	r3, #3
34182a64:	d109      	bne.n	34182a7a <HAL_GPIO_Init+0xc2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34182a66:	683b      	ldr	r3, [r7, #0]
34182a68:	685b      	ldr	r3, [r3, #4]
34182a6a:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34182a6e:	2b03      	cmp	r3, #3
34182a70:	d11b      	bne.n	34182aaa <HAL_GPIO_Init+0xf2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34182a72:	683b      	ldr	r3, [r7, #0]
34182a74:	689b      	ldr	r3, [r3, #8]
34182a76:	2b01      	cmp	r3, #1
34182a78:	d017      	beq.n	34182aaa <HAL_GPIO_Init+0xf2>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
34182a7a:	687b      	ldr	r3, [r7, #4]
34182a7c:	68db      	ldr	r3, [r3, #12]
34182a7e:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34182a80:	697b      	ldr	r3, [r7, #20]
34182a82:	005b      	lsls	r3, r3, #1
34182a84:	2203      	movs	r2, #3
34182a86:	fa02 f303 	lsl.w	r3, r2, r3
34182a8a:	43db      	mvns	r3, r3
34182a8c:	693a      	ldr	r2, [r7, #16]
34182a8e:	4013      	ands	r3, r2
34182a90:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
34182a92:	683b      	ldr	r3, [r7, #0]
34182a94:	689a      	ldr	r2, [r3, #8]
34182a96:	697b      	ldr	r3, [r7, #20]
34182a98:	005b      	lsls	r3, r3, #1
34182a9a:	fa02 f303 	lsl.w	r3, r2, r3
34182a9e:	693a      	ldr	r2, [r7, #16]
34182aa0:	4313      	orrs	r3, r2
34182aa2:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
34182aa4:	687b      	ldr	r3, [r7, #4]
34182aa6:	693a      	ldr	r2, [r7, #16]
34182aa8:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
34182aaa:	683b      	ldr	r3, [r7, #0]
34182aac:	685b      	ldr	r3, [r3, #4]
34182aae:	f003 0303 	and.w	r3, r3, #3
34182ab2:	2b02      	cmp	r3, #2
34182ab4:	d123      	bne.n	34182afe <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
34182ab6:	697b      	ldr	r3, [r7, #20]
34182ab8:	08da      	lsrs	r2, r3, #3
34182aba:	687b      	ldr	r3, [r7, #4]
34182abc:	3208      	adds	r2, #8
34182abe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
34182ac2:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34182ac4:	697b      	ldr	r3, [r7, #20]
34182ac6:	f003 0307 	and.w	r3, r3, #7
34182aca:	009b      	lsls	r3, r3, #2
34182acc:	220f      	movs	r2, #15
34182ace:	fa02 f303 	lsl.w	r3, r2, r3
34182ad2:	43db      	mvns	r3, r3
34182ad4:	693a      	ldr	r2, [r7, #16]
34182ad6:	4013      	ands	r3, r2
34182ad8:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34182ada:	683b      	ldr	r3, [r7, #0]
34182adc:	691a      	ldr	r2, [r3, #16]
34182ade:	697b      	ldr	r3, [r7, #20]
34182ae0:	f003 0307 	and.w	r3, r3, #7
34182ae4:	009b      	lsls	r3, r3, #2
34182ae6:	fa02 f303 	lsl.w	r3, r2, r3
34182aea:	693a      	ldr	r2, [r7, #16]
34182aec:	4313      	orrs	r3, r2
34182aee:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
34182af0:	697b      	ldr	r3, [r7, #20]
34182af2:	08da      	lsrs	r2, r3, #3
34182af4:	687b      	ldr	r3, [r7, #4]
34182af6:	3208      	adds	r2, #8
34182af8:	6939      	ldr	r1, [r7, #16]
34182afa:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
34182afe:	687b      	ldr	r3, [r7, #4]
34182b00:	681b      	ldr	r3, [r3, #0]
34182b02:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34182b04:	697b      	ldr	r3, [r7, #20]
34182b06:	005b      	lsls	r3, r3, #1
34182b08:	2203      	movs	r2, #3
34182b0a:	fa02 f303 	lsl.w	r3, r2, r3
34182b0e:	43db      	mvns	r3, r3
34182b10:	693a      	ldr	r2, [r7, #16]
34182b12:	4013      	ands	r3, r2
34182b14:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
34182b16:	683b      	ldr	r3, [r7, #0]
34182b18:	685b      	ldr	r3, [r3, #4]
34182b1a:	f003 0203 	and.w	r2, r3, #3
34182b1e:	697b      	ldr	r3, [r7, #20]
34182b20:	005b      	lsls	r3, r3, #1
34182b22:	fa02 f303 	lsl.w	r3, r2, r3
34182b26:	693a      	ldr	r2, [r7, #16]
34182b28:	4313      	orrs	r3, r2
34182b2a:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
34182b2c:	687b      	ldr	r3, [r7, #4]
34182b2e:	693a      	ldr	r2, [r7, #16]
34182b30:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
34182b32:	683b      	ldr	r3, [r7, #0]
34182b34:	685b      	ldr	r3, [r3, #4]
34182b36:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
34182b3a:	2b00      	cmp	r3, #0
34182b3c:	f000 80c2 	beq.w	34182cc4 <HAL_GPIO_Init+0x30c>
      {
        temp = EXTI->EXTICR[position >> 2u];
34182b40:	4a69      	ldr	r2, [pc, #420]	@ (34182ce8 <HAL_GPIO_Init+0x330>)
34182b42:	697b      	ldr	r3, [r7, #20]
34182b44:	089b      	lsrs	r3, r3, #2
34182b46:	3318      	adds	r3, #24
34182b48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34182b4c:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34182b4e:	697b      	ldr	r3, [r7, #20]
34182b50:	f003 0303 	and.w	r3, r3, #3
34182b54:	00db      	lsls	r3, r3, #3
34182b56:	220f      	movs	r2, #15
34182b58:	fa02 f303 	lsl.w	r3, r2, r3
34182b5c:	43db      	mvns	r3, r3
34182b5e:	693a      	ldr	r2, [r7, #16]
34182b60:	4013      	ands	r3, r2
34182b62:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34182b64:	687b      	ldr	r3, [r7, #4]
34182b66:	4a61      	ldr	r2, [pc, #388]	@ (34182cec <HAL_GPIO_Init+0x334>)
34182b68:	4293      	cmp	r3, r2
34182b6a:	d043      	beq.n	34182bf4 <HAL_GPIO_Init+0x23c>
34182b6c:	687b      	ldr	r3, [r7, #4]
34182b6e:	4a60      	ldr	r2, [pc, #384]	@ (34182cf0 <HAL_GPIO_Init+0x338>)
34182b70:	4293      	cmp	r3, r2
34182b72:	d03d      	beq.n	34182bf0 <HAL_GPIO_Init+0x238>
34182b74:	687b      	ldr	r3, [r7, #4]
34182b76:	4a5f      	ldr	r2, [pc, #380]	@ (34182cf4 <HAL_GPIO_Init+0x33c>)
34182b78:	4293      	cmp	r3, r2
34182b7a:	d037      	beq.n	34182bec <HAL_GPIO_Init+0x234>
34182b7c:	687b      	ldr	r3, [r7, #4]
34182b7e:	4a5e      	ldr	r2, [pc, #376]	@ (34182cf8 <HAL_GPIO_Init+0x340>)
34182b80:	4293      	cmp	r3, r2
34182b82:	d031      	beq.n	34182be8 <HAL_GPIO_Init+0x230>
34182b84:	687b      	ldr	r3, [r7, #4]
34182b86:	4a5d      	ldr	r2, [pc, #372]	@ (34182cfc <HAL_GPIO_Init+0x344>)
34182b88:	4293      	cmp	r3, r2
34182b8a:	d02b      	beq.n	34182be4 <HAL_GPIO_Init+0x22c>
34182b8c:	687b      	ldr	r3, [r7, #4]
34182b8e:	4a5c      	ldr	r2, [pc, #368]	@ (34182d00 <HAL_GPIO_Init+0x348>)
34182b90:	4293      	cmp	r3, r2
34182b92:	d025      	beq.n	34182be0 <HAL_GPIO_Init+0x228>
34182b94:	687b      	ldr	r3, [r7, #4]
34182b96:	4a5b      	ldr	r2, [pc, #364]	@ (34182d04 <HAL_GPIO_Init+0x34c>)
34182b98:	4293      	cmp	r3, r2
34182b9a:	d01f      	beq.n	34182bdc <HAL_GPIO_Init+0x224>
34182b9c:	687b      	ldr	r3, [r7, #4]
34182b9e:	4a5a      	ldr	r2, [pc, #360]	@ (34182d08 <HAL_GPIO_Init+0x350>)
34182ba0:	4293      	cmp	r3, r2
34182ba2:	d019      	beq.n	34182bd8 <HAL_GPIO_Init+0x220>
34182ba4:	687b      	ldr	r3, [r7, #4]
34182ba6:	4a59      	ldr	r2, [pc, #356]	@ (34182d0c <HAL_GPIO_Init+0x354>)
34182ba8:	4293      	cmp	r3, r2
34182baa:	d013      	beq.n	34182bd4 <HAL_GPIO_Init+0x21c>
34182bac:	687b      	ldr	r3, [r7, #4]
34182bae:	4a58      	ldr	r2, [pc, #352]	@ (34182d10 <HAL_GPIO_Init+0x358>)
34182bb0:	4293      	cmp	r3, r2
34182bb2:	d00d      	beq.n	34182bd0 <HAL_GPIO_Init+0x218>
34182bb4:	687b      	ldr	r3, [r7, #4]
34182bb6:	4a57      	ldr	r2, [pc, #348]	@ (34182d14 <HAL_GPIO_Init+0x35c>)
34182bb8:	4293      	cmp	r3, r2
34182bba:	d007      	beq.n	34182bcc <HAL_GPIO_Init+0x214>
34182bbc:	687b      	ldr	r3, [r7, #4]
34182bbe:	4a56      	ldr	r2, [pc, #344]	@ (34182d18 <HAL_GPIO_Init+0x360>)
34182bc0:	4293      	cmp	r3, r2
34182bc2:	d101      	bne.n	34182bc8 <HAL_GPIO_Init+0x210>
34182bc4:	230b      	movs	r3, #11
34182bc6:	e016      	b.n	34182bf6 <HAL_GPIO_Init+0x23e>
34182bc8:	2310      	movs	r3, #16
34182bca:	e014      	b.n	34182bf6 <HAL_GPIO_Init+0x23e>
34182bcc:	230a      	movs	r3, #10
34182bce:	e012      	b.n	34182bf6 <HAL_GPIO_Init+0x23e>
34182bd0:	2309      	movs	r3, #9
34182bd2:	e010      	b.n	34182bf6 <HAL_GPIO_Init+0x23e>
34182bd4:	2308      	movs	r3, #8
34182bd6:	e00e      	b.n	34182bf6 <HAL_GPIO_Init+0x23e>
34182bd8:	2307      	movs	r3, #7
34182bda:	e00c      	b.n	34182bf6 <HAL_GPIO_Init+0x23e>
34182bdc:	2306      	movs	r3, #6
34182bde:	e00a      	b.n	34182bf6 <HAL_GPIO_Init+0x23e>
34182be0:	2305      	movs	r3, #5
34182be2:	e008      	b.n	34182bf6 <HAL_GPIO_Init+0x23e>
34182be4:	2304      	movs	r3, #4
34182be6:	e006      	b.n	34182bf6 <HAL_GPIO_Init+0x23e>
34182be8:	2303      	movs	r3, #3
34182bea:	e004      	b.n	34182bf6 <HAL_GPIO_Init+0x23e>
34182bec:	2302      	movs	r3, #2
34182bee:	e002      	b.n	34182bf6 <HAL_GPIO_Init+0x23e>
34182bf0:	2301      	movs	r3, #1
34182bf2:	e000      	b.n	34182bf6 <HAL_GPIO_Init+0x23e>
34182bf4:	2300      	movs	r3, #0
34182bf6:	697a      	ldr	r2, [r7, #20]
34182bf8:	f002 0203 	and.w	r2, r2, #3
34182bfc:	00d2      	lsls	r2, r2, #3
34182bfe:	4093      	lsls	r3, r2
34182c00:	693a      	ldr	r2, [r7, #16]
34182c02:	4313      	orrs	r3, r2
34182c04:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2u] = temp;
34182c06:	4938      	ldr	r1, [pc, #224]	@ (34182ce8 <HAL_GPIO_Init+0x330>)
34182c08:	697b      	ldr	r3, [r7, #20]
34182c0a:	089b      	lsrs	r3, r3, #2
34182c0c:	3318      	adds	r3, #24
34182c0e:	693a      	ldr	r2, [r7, #16]
34182c10:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
34182c14:	4b34      	ldr	r3, [pc, #208]	@ (34182ce8 <HAL_GPIO_Init+0x330>)
34182c16:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34182c1a:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34182c1c:	68fb      	ldr	r3, [r7, #12]
34182c1e:	43db      	mvns	r3, r3
34182c20:	693a      	ldr	r2, [r7, #16]
34182c22:	4013      	ands	r3, r2
34182c24:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
34182c26:	683b      	ldr	r3, [r7, #0]
34182c28:	685b      	ldr	r3, [r3, #4]
34182c2a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34182c2e:	2b00      	cmp	r3, #0
34182c30:	d003      	beq.n	34182c3a <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
34182c32:	693a      	ldr	r2, [r7, #16]
34182c34:	68fb      	ldr	r3, [r7, #12]
34182c36:	4313      	orrs	r3, r2
34182c38:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
34182c3a:	4a2b      	ldr	r2, [pc, #172]	@ (34182ce8 <HAL_GPIO_Init+0x330>)
34182c3c:	693b      	ldr	r3, [r7, #16]
34182c3e:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80

        temp = EXTI->EMR1;
34182c42:	4b29      	ldr	r3, [pc, #164]	@ (34182ce8 <HAL_GPIO_Init+0x330>)
34182c44:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34182c48:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34182c4a:	68fb      	ldr	r3, [r7, #12]
34182c4c:	43db      	mvns	r3, r3
34182c4e:	693a      	ldr	r2, [r7, #16]
34182c50:	4013      	ands	r3, r2
34182c52:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
34182c54:	683b      	ldr	r3, [r7, #0]
34182c56:	685b      	ldr	r3, [r3, #4]
34182c58:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34182c5c:	2b00      	cmp	r3, #0
34182c5e:	d003      	beq.n	34182c68 <HAL_GPIO_Init+0x2b0>
        {
          temp |= iocurrent;
34182c60:	693a      	ldr	r2, [r7, #16]
34182c62:	68fb      	ldr	r3, [r7, #12]
34182c64:	4313      	orrs	r3, r2
34182c66:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
34182c68:	4a1f      	ldr	r2, [pc, #124]	@ (34182ce8 <HAL_GPIO_Init+0x330>)
34182c6a:	693b      	ldr	r3, [r7, #16]
34182c6c:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
34182c70:	4b1d      	ldr	r3, [pc, #116]	@ (34182ce8 <HAL_GPIO_Init+0x330>)
34182c72:	681b      	ldr	r3, [r3, #0]
34182c74:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34182c76:	68fb      	ldr	r3, [r7, #12]
34182c78:	43db      	mvns	r3, r3
34182c7a:	693a      	ldr	r2, [r7, #16]
34182c7c:	4013      	ands	r3, r2
34182c7e:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
34182c80:	683b      	ldr	r3, [r7, #0]
34182c82:	685b      	ldr	r3, [r3, #4]
34182c84:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34182c88:	2b00      	cmp	r3, #0
34182c8a:	d003      	beq.n	34182c94 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
34182c8c:	693a      	ldr	r2, [r7, #16]
34182c8e:	68fb      	ldr	r3, [r7, #12]
34182c90:	4313      	orrs	r3, r2
34182c92:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
34182c94:	4a14      	ldr	r2, [pc, #80]	@ (34182ce8 <HAL_GPIO_Init+0x330>)
34182c96:	693b      	ldr	r3, [r7, #16]
34182c98:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
34182c9a:	4b13      	ldr	r3, [pc, #76]	@ (34182ce8 <HAL_GPIO_Init+0x330>)
34182c9c:	685b      	ldr	r3, [r3, #4]
34182c9e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34182ca0:	68fb      	ldr	r3, [r7, #12]
34182ca2:	43db      	mvns	r3, r3
34182ca4:	693a      	ldr	r2, [r7, #16]
34182ca6:	4013      	ands	r3, r2
34182ca8:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
34182caa:	683b      	ldr	r3, [r7, #0]
34182cac:	685b      	ldr	r3, [r3, #4]
34182cae:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34182cb2:	2b00      	cmp	r3, #0
34182cb4:	d003      	beq.n	34182cbe <HAL_GPIO_Init+0x306>
        {
          temp |= iocurrent;
34182cb6:	693a      	ldr	r2, [r7, #16]
34182cb8:	68fb      	ldr	r3, [r7, #12]
34182cba:	4313      	orrs	r3, r2
34182cbc:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
34182cbe:	4a0a      	ldr	r2, [pc, #40]	@ (34182ce8 <HAL_GPIO_Init+0x330>)
34182cc0:	693b      	ldr	r3, [r7, #16]
34182cc2:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
34182cc4:	697b      	ldr	r3, [r7, #20]
34182cc6:	3301      	adds	r3, #1
34182cc8:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34182cca:	683b      	ldr	r3, [r7, #0]
34182ccc:	681a      	ldr	r2, [r3, #0]
34182cce:	697b      	ldr	r3, [r7, #20]
34182cd0:	fa22 f303 	lsr.w	r3, r2, r3
34182cd4:	2b00      	cmp	r3, #0
34182cd6:	f47f ae77 	bne.w	341829c8 <HAL_GPIO_Init+0x10>
  }
}
34182cda:	bf00      	nop
34182cdc:	bf00      	nop
34182cde:	371c      	adds	r7, #28
34182ce0:	46bd      	mov	sp, r7
34182ce2:	f85d 7b04 	ldr.w	r7, [sp], #4
34182ce6:	4770      	bx	lr
34182ce8:	56025000 	.word	0x56025000
34182cec:	56020000 	.word	0x56020000
34182cf0:	56020400 	.word	0x56020400
34182cf4:	56020800 	.word	0x56020800
34182cf8:	56020c00 	.word	0x56020c00
34182cfc:	56021000 	.word	0x56021000
34182d00:	56021400 	.word	0x56021400
34182d04:	56021800 	.word	0x56021800
34182d08:	56021c00 	.word	0x56021c00
34182d0c:	56023400 	.word	0x56023400
34182d10:	56023800 	.word	0x56023800
34182d14:	56023c00 	.word	0x56023c00
34182d18:	56024000 	.word	0x56024000

34182d1c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
34182d1c:	b480      	push	{r7}
34182d1e:	b083      	sub	sp, #12
34182d20:	af00      	add	r7, sp, #0
34182d22:	6078      	str	r0, [r7, #4]
34182d24:	460b      	mov	r3, r1
34182d26:	807b      	strh	r3, [r7, #2]
34182d28:	4613      	mov	r3, r2
34182d2a:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
34182d2c:	787b      	ldrb	r3, [r7, #1]
34182d2e:	2b00      	cmp	r3, #0
34182d30:	d003      	beq.n	34182d3a <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
34182d32:	887a      	ldrh	r2, [r7, #2]
34182d34:	687b      	ldr	r3, [r7, #4]
34182d36:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
34182d38:	e002      	b.n	34182d40 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
34182d3a:	887a      	ldrh	r2, [r7, #2]
34182d3c:	687b      	ldr	r3, [r7, #4]
34182d3e:	629a      	str	r2, [r3, #40]	@ 0x28
}
34182d40:	bf00      	nop
34182d42:	370c      	adds	r7, #12
34182d44:	46bd      	mov	sp, r7
34182d46:	f85d 7b04 	ldr.w	r7, [sp], #4
34182d4a:	4770      	bx	lr

34182d4c <HAL_LTDC_Init>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
{
34182d4c:	b580      	push	{r7, lr}
34182d4e:	b084      	sub	sp, #16
34182d50:	af00      	add	r7, sp, #0
34182d52:	6078      	str	r0, [r7, #4]
  uint32_t tmp;
  uint32_t tmp1;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
34182d54:	687b      	ldr	r3, [r7, #4]
34182d56:	2b00      	cmp	r3, #0
34182d58:	d101      	bne.n	34182d5e <HAL_LTDC_Init+0x12>
  {
    return HAL_ERROR;
34182d5a:	2301      	movs	r3, #1
34182d5c:	e09d      	b.n	34182e9a <HAL_LTDC_Init+0x14e>
    }
    /* Init the low level hardware */
    hltdc->MspInitCallback(hltdc);
  }
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
34182d5e:	687b      	ldr	r3, [r7, #4]
34182d60:	f893 30a1 	ldrb.w	r3, [r3, #161]	@ 0xa1
34182d64:	b2db      	uxtb	r3, r3
34182d66:	2b00      	cmp	r3, #0
34182d68:	d106      	bne.n	34182d78 <HAL_LTDC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
34182d6a:	687b      	ldr	r3, [r7, #4]
34182d6c:	2200      	movs	r2, #0
34182d6e:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0
    /* Init the low level hardware */
    HAL_LTDC_MspInit(hltdc);
34182d72:	6878      	ldr	r0, [r7, #4]
34182d74:	f000 f895 	bl	34182ea2 <HAL_LTDC_MspInit>
  }
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
34182d78:	687b      	ldr	r3, [r7, #4]
34182d7a:	2202      	movs	r2, #2
34182d7c:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Configure the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
34182d80:	687b      	ldr	r3, [r7, #4]
34182d82:	681b      	ldr	r3, [r3, #0]
34182d84:	699a      	ldr	r2, [r3, #24]
34182d86:	687b      	ldr	r3, [r7, #4]
34182d88:	681b      	ldr	r3, [r3, #0]
34182d8a:	f022 4270 	bic.w	r2, r2, #4026531840	@ 0xf0000000
34182d8e:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34182d90:	687b      	ldr	r3, [r7, #4]
34182d92:	681b      	ldr	r3, [r3, #0]
34182d94:	6999      	ldr	r1, [r3, #24]
34182d96:	687b      	ldr	r3, [r7, #4]
34182d98:	685a      	ldr	r2, [r3, #4]
34182d9a:	687b      	ldr	r3, [r7, #4]
34182d9c:	689b      	ldr	r3, [r3, #8]
34182d9e:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
34182da0:	687b      	ldr	r3, [r7, #4]
34182da2:	68db      	ldr	r3, [r3, #12]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34182da4:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
34182da6:	687b      	ldr	r3, [r7, #4]
34182da8:	691b      	ldr	r3, [r3, #16]
34182daa:	431a      	orrs	r2, r3
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34182dac:	687b      	ldr	r3, [r7, #4]
34182dae:	681b      	ldr	r3, [r3, #0]
34182db0:	430a      	orrs	r2, r1
34182db2:	619a      	str	r2, [r3, #24]

  /* Set Synchronization size */
  tmp = (hltdc->Init.HorizontalSync << 16U);
34182db4:	687b      	ldr	r3, [r7, #4]
34182db6:	695b      	ldr	r3, [r3, #20]
34182db8:	041b      	lsls	r3, r3, #16
34182dba:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->SSCR, (tmp | hltdc->Init.VerticalSync));
34182dbc:	687b      	ldr	r3, [r7, #4]
34182dbe:	6999      	ldr	r1, [r3, #24]
34182dc0:	687b      	ldr	r3, [r7, #4]
34182dc2:	681b      	ldr	r3, [r3, #0]
34182dc4:	68fa      	ldr	r2, [r7, #12]
34182dc6:	430a      	orrs	r2, r1
34182dc8:	609a      	str	r2, [r3, #8]

  /* Set Accumulated Back porch */
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
34182dca:	687b      	ldr	r3, [r7, #4]
34182dcc:	69db      	ldr	r3, [r3, #28]
34182dce:	041b      	lsls	r3, r3, #16
34182dd0:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->BPCR, (tmp | hltdc->Init.AccumulatedVBP));
34182dd2:	687b      	ldr	r3, [r7, #4]
34182dd4:	6a19      	ldr	r1, [r3, #32]
34182dd6:	687b      	ldr	r3, [r7, #4]
34182dd8:	681b      	ldr	r3, [r3, #0]
34182dda:	68fa      	ldr	r2, [r7, #12]
34182ddc:	430a      	orrs	r2, r1
34182dde:	60da      	str	r2, [r3, #12]

  /* Set Accumulated Active Width */
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
34182de0:	687b      	ldr	r3, [r7, #4]
34182de2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34182de4:	041b      	lsls	r3, r3, #16
34182de6:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->AWCR, (tmp | hltdc->Init.AccumulatedActiveH));
34182de8:	687b      	ldr	r3, [r7, #4]
34182dea:	6a99      	ldr	r1, [r3, #40]	@ 0x28
34182dec:	687b      	ldr	r3, [r7, #4]
34182dee:	681b      	ldr	r3, [r3, #0]
34182df0:	68fa      	ldr	r2, [r7, #12]
34182df2:	430a      	orrs	r2, r1
34182df4:	611a      	str	r2, [r3, #16]

  /* Set Total Width */
  tmp = (hltdc->Init.TotalWidth << 16U);
34182df6:	687b      	ldr	r3, [r7, #4]
34182df8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34182dfa:	041b      	lsls	r3, r3, #16
34182dfc:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->TWCR, (tmp | hltdc->Init.TotalHeigh));
34182dfe:	687b      	ldr	r3, [r7, #4]
34182e00:	6b19      	ldr	r1, [r3, #48]	@ 0x30
34182e02:	687b      	ldr	r3, [r7, #4]
34182e04:	681b      	ldr	r3, [r3, #0]
34182e06:	68fa      	ldr	r2, [r7, #12]
34182e08:	430a      	orrs	r2, r1
34182e0a:	615a      	str	r2, [r3, #20]

  /* Set the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
34182e0c:	687b      	ldr	r3, [r7, #4]
34182e0e:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
34182e12:	021b      	lsls	r3, r3, #8
34182e14:	60fb      	str	r3, [r7, #12]
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
34182e16:	687b      	ldr	r3, [r7, #4]
34182e18:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
34182e1c:	041b      	lsls	r3, r3, #16
34182e1e:	60bb      	str	r3, [r7, #8]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34182e20:	687b      	ldr	r3, [r7, #4]
34182e22:	681b      	ldr	r3, [r3, #0]
34182e24:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34182e26:	687b      	ldr	r3, [r7, #4]
34182e28:	681b      	ldr	r3, [r3, #0]
34182e2a:	f002 427f 	and.w	r2, r2, #4278190080	@ 0xff000000
34182e2e:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
34182e30:	687b      	ldr	r3, [r7, #4]
34182e32:	681b      	ldr	r3, [r3, #0]
34182e34:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
34182e36:	68ba      	ldr	r2, [r7, #8]
34182e38:	68fb      	ldr	r3, [r7, #12]
34182e3a:	4313      	orrs	r3, r2
34182e3c:	687a      	ldr	r2, [r7, #4]
34182e3e:	f892 2034 	ldrb.w	r2, [r2, #52]	@ 0x34
34182e42:	431a      	orrs	r2, r3
34182e44:	687b      	ldr	r3, [r7, #4]
34182e46:	681b      	ldr	r3, [r3, #0]
34182e48:	430a      	orrs	r2, r1
34182e4a:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Activate Global Reload for Layer 1 and Layer 2 */
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_1)->RCR, LTDC_LxRCR_GRMSK);
34182e4c:	687b      	ldr	r3, [r7, #4]
34182e4e:	681b      	ldr	r3, [r3, #0]
34182e50:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34182e54:	461a      	mov	r2, r3
34182e56:	2304      	movs	r3, #4
34182e58:	6093      	str	r3, [r2, #8]
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_2)->RCR, LTDC_LxRCR_GRMSK);
34182e5a:	687b      	ldr	r3, [r7, #4]
34182e5c:	681b      	ldr	r3, [r3, #0]
34182e5e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
34182e62:	461a      	mov	r2, r3
34182e64:	2304      	movs	r3, #4
34182e66:	6093      	str	r3, [r2, #8]

  /* Enable the Transfer Error and FIFO underrun interrupts */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
34182e68:	687b      	ldr	r3, [r7, #4]
34182e6a:	681b      	ldr	r3, [r3, #0]
34182e6c:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
34182e6e:	687b      	ldr	r3, [r7, #4]
34182e70:	681b      	ldr	r3, [r3, #0]
34182e72:	f042 0244 	orr.w	r2, r2, #68	@ 0x44
34182e76:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);
34182e78:	687b      	ldr	r3, [r7, #4]
34182e7a:	681b      	ldr	r3, [r3, #0]
34182e7c:	699a      	ldr	r2, [r3, #24]
34182e7e:	687b      	ldr	r3, [r7, #4]
34182e80:	681b      	ldr	r3, [r3, #0]
34182e82:	f042 0201 	orr.w	r2, r2, #1
34182e86:	619a      	str	r2, [r3, #24]

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
34182e88:	687b      	ldr	r3, [r7, #4]
34182e8a:	2200      	movs	r2, #0
34182e8c:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
34182e90:	687b      	ldr	r3, [r7, #4]
34182e92:	2201      	movs	r2, #1
34182e94:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  return HAL_OK;
34182e98:	2300      	movs	r3, #0
}
34182e9a:	4618      	mov	r0, r3
34182e9c:	3710      	adds	r7, #16
34182e9e:	46bd      	mov	sp, r7
34182ea0:	bd80      	pop	{r7, pc}

34182ea2 <HAL_LTDC_MspInit>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  */
__weak void HAL_LTDC_MspInit(LTDC_HandleTypeDef *hltdc)
{
34182ea2:	b480      	push	{r7}
34182ea4:	b083      	sub	sp, #12
34182ea6:	af00      	add	r7, sp, #0
34182ea8:	6078      	str	r0, [r7, #4]
  UNUSED(hltdc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_MspInit could be implemented in the user file
   */
}
34182eaa:	bf00      	nop
34182eac:	370c      	adds	r7, #12
34182eae:	46bd      	mov	sp, r7
34182eb0:	f85d 7b04 	ldr.w	r7, [sp], #4
34182eb4:	4770      	bx	lr

34182eb6 <HAL_LTDC_ConfigLayer>:
  *                    This parameter can be one of the following values:
  *                    LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
34182eb6:	b5b0      	push	{r4, r5, r7, lr}
34182eb8:	b086      	sub	sp, #24
34182eba:	af02      	add	r7, sp, #8
34182ebc:	60f8      	str	r0, [r7, #12]
34182ebe:	60b9      	str	r1, [r7, #8]
34182ec0:	607a      	str	r2, [r7, #4]
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));

  /* Process locked */
  __HAL_LOCK(hltdc);
34182ec2:	68fb      	ldr	r3, [r7, #12]
34182ec4:	f893 30a0 	ldrb.w	r3, [r3, #160]	@ 0xa0
34182ec8:	2b01      	cmp	r3, #1
34182eca:	d101      	bne.n	34182ed0 <HAL_LTDC_ConfigLayer+0x1a>
34182ecc:	2302      	movs	r3, #2
34182ece:	e052      	b.n	34182f76 <HAL_LTDC_ConfigLayer+0xc0>
34182ed0:	68fb      	ldr	r3, [r7, #12]
34182ed2:	2201      	movs	r2, #1
34182ed4:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
34182ed8:	68fb      	ldr	r3, [r7, #12]
34182eda:	2202      	movs	r2, #2
34182edc:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Copy new layer configuration into handle structure */
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34182ee0:	68fa      	ldr	r2, [r7, #12]
34182ee2:	687b      	ldr	r3, [r7, #4]
34182ee4:	2134      	movs	r1, #52	@ 0x34
34182ee6:	fb01 f303 	mul.w	r3, r1, r3
34182eea:	4413      	add	r3, r2
34182eec:	f103 0238 	add.w	r2, r3, #56	@ 0x38
34182ef0:	68bb      	ldr	r3, [r7, #8]
34182ef2:	4614      	mov	r4, r2
34182ef4:	461d      	mov	r5, r3
34182ef6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34182ef8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34182efa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34182efc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34182efe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34182f00:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34182f02:	682b      	ldr	r3, [r5, #0]
34182f04:	6023      	str	r3, [r4, #0]

  /* Configure Predefined format */
  LTDC_SetPredefFormat(hltdc, LayerIdx);
34182f06:	6879      	ldr	r1, [r7, #4]
34182f08:	68f8      	ldr	r0, [r7, #12]
34182f0a:	f000 ff6d 	bl	34183de8 <LTDC_SetPredefFormat>

  /* Configure composition and blending*/
  LTDC_SetCompositionConfig(hltdc, LayerIdx);
34182f0e:	6879      	ldr	r1, [r7, #4]
34182f10:	68f8      	ldr	r0, [r7, #12]
34182f12:	f000 fec1 	bl	34183c98 <LTDC_SetCompositionConfig>

  /* Disable YUV format */
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34182f16:	68fb      	ldr	r3, [r7, #12]
34182f18:	681b      	ldr	r3, [r3, #0]
34182f1a:	461a      	mov	r2, r3
34182f1c:	687b      	ldr	r3, [r7, #4]
34182f1e:	021b      	lsls	r3, r3, #8
34182f20:	4413      	add	r3, r2
34182f22:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34182f26:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34182f28:	68fa      	ldr	r2, [r7, #12]
34182f2a:	6812      	ldr	r2, [r2, #0]
34182f2c:	4611      	mov	r1, r2
34182f2e:	687a      	ldr	r2, [r7, #4]
34182f30:	0212      	lsls	r2, r2, #8
34182f32:	440a      	add	r2, r1
34182f34:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34182f38:	f023 0308 	bic.w	r3, r3, #8
34182f3c:	6313      	str	r3, [r2, #48]	@ 0x30

  /* Configure the LTDC Layer */
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34182f3e:	687b      	ldr	r3, [r7, #4]
34182f40:	9300      	str	r3, [sp, #0]
34182f42:	2303      	movs	r3, #3
34182f44:	2200      	movs	r2, #0
34182f46:	2100      	movs	r1, #0
34182f48:	68f8      	ldr	r0, [r7, #12]
34182f4a:	f000 f818 	bl	34182f7e <LTDC_SetConfig>

  /* Set the Immediate Reload type */
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
34182f4e:	68fb      	ldr	r3, [r7, #12]
34182f50:	681b      	ldr	r3, [r3, #0]
34182f52:	461a      	mov	r2, r3
34182f54:	687b      	ldr	r3, [r7, #4]
34182f56:	021b      	lsls	r3, r3, #8
34182f58:	4413      	add	r3, r2
34182f5a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34182f5e:	461a      	mov	r2, r3
34182f60:	2305      	movs	r3, #5
34182f62:	6093      	str	r3, [r2, #8]

  /* Initialize the LTDC state*/
  hltdc->State  = HAL_LTDC_STATE_READY;
34182f64:	68fb      	ldr	r3, [r7, #12]
34182f66:	2201      	movs	r2, #1
34182f68:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
34182f6c:	68fb      	ldr	r3, [r7, #12]
34182f6e:	2200      	movs	r2, #0
34182f70:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  return HAL_OK;
34182f74:	2300      	movs	r3, #0
}
34182f76:	4618      	mov	r0, r3
34182f78:	3710      	adds	r7, #16
34182f7a:	46bd      	mov	sp, r7
34182f7c:	bdb0      	pop	{r4, r5, r7, pc}

34182f7e <LTDC_SetConfig>:
  *       This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, uint32_t Aux0Addr, uint32_t Aux1Addr, uint32_t Mirror,
                           uint32_t LayerIdx)
{
34182f7e:	b4b0      	push	{r4, r5, r7}
34182f80:	b087      	sub	sp, #28
34182f82:	af00      	add	r7, sp, #0
34182f84:	60f8      	str	r0, [r7, #12]
34182f86:	60b9      	str	r1, [r7, #8]
34182f88:	607a      	str	r2, [r7, #4]
34182f8a:	603b      	str	r3, [r7, #0]
  uint32_t stride;
  uint32_t tmp;

  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
34182f8c:	68fb      	ldr	r3, [r7, #12]
34182f8e:	681b      	ldr	r3, [r3, #0]
34182f90:	461a      	mov	r2, r3
34182f92:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34182f94:	021b      	lsls	r3, r3, #8
34182f96:	4413      	add	r3, r2
34182f98:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34182f9c:	4618      	mov	r0, r3
34182f9e:	68fa      	ldr	r2, [r7, #12]
34182fa0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34182fa2:	2134      	movs	r1, #52	@ 0x34
34182fa4:	fb01 f303 	mul.w	r3, r1, r3
34182fa8:	4413      	add	r3, r2
34182faa:	3364      	adds	r3, #100	@ 0x64
34182fac:	681b      	ldr	r3, [r3, #0]
34182fae:	63c3      	str	r3, [r0, #60]	@ 0x3c

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34182fb0:	68fa      	ldr	r2, [r7, #12]
34182fb2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34182fb4:	2134      	movs	r1, #52	@ 0x34
34182fb6:	fb01 f303 	mul.w	r3, r1, r3
34182fba:	4413      	add	r3, r2
34182fbc:	3348      	adds	r3, #72	@ 0x48
34182fbe:	681b      	ldr	r3, [r3, #0]
34182fc0:	2b03      	cmp	r3, #3
34182fc2:	d821      	bhi.n	34183008 <LTDC_SetConfig+0x8a>
34182fc4:	e025      	b.n	34183012 <LTDC_SetConfig+0x94>
34182fc6:	3b04      	subs	r3, #4
34182fc8:	2201      	movs	r2, #1
34182fca:	fa02 f303 	lsl.w	r3, r2, r3
34182fce:	f240 229b 	movw	r2, #667	@ 0x29b
34182fd2:	401a      	ands	r2, r3
34182fd4:	2a00      	cmp	r2, #0
34182fd6:	bf14      	ite	ne
34182fd8:	2201      	movne	r2, #1
34182fda:	2200      	moveq	r2, #0
34182fdc:	b2d2      	uxtb	r2, r2
34182fde:	2a00      	cmp	r2, #0
34182fe0:	d11d      	bne.n	3418301e <LTDC_SetConfig+0xa0>
34182fe2:	f403 7280 	and.w	r2, r3, #256	@ 0x100
34182fe6:	2a00      	cmp	r2, #0
34182fe8:	bf14      	ite	ne
34182fea:	2201      	movne	r2, #1
34182fec:	2200      	moveq	r2, #0
34182fee:	b2d2      	uxtb	r2, r2
34182ff0:	2a00      	cmp	r2, #0
34182ff2:	d117      	bne.n	34183024 <LTDC_SetConfig+0xa6>
34182ff4:	f003 0304 	and.w	r3, r3, #4
34182ff8:	2b00      	cmp	r3, #0
34182ffa:	bf14      	ite	ne
34182ffc:	2301      	movne	r3, #1
34182ffe:	2300      	moveq	r3, #0
34183000:	b2db      	uxtb	r3, r3
34183002:	2b00      	cmp	r3, #0
34183004:	d108      	bne.n	34183018 <LTDC_SetConfig+0x9a>
34183006:	e01b      	b.n	34183040 <LTDC_SetConfig+0xc2>
34183008:	2b0d      	cmp	r3, #13
3418300a:	d819      	bhi.n	34183040 <LTDC_SetConfig+0xc2>
3418300c:	2b04      	cmp	r3, #4
3418300e:	d2da      	bcs.n	34182fc6 <LTDC_SetConfig+0x48>
34183010:	e016      	b.n	34183040 <LTDC_SetConfig+0xc2>
  {
    case LTDC_PIXEL_FORMAT_ARGB8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_ABGR8888:
    case LTDC_PIXEL_FORMAT_RGBA8888:
      stride = 4U;
34183012:	2304      	movs	r3, #4
34183014:	617b      	str	r3, [r7, #20]
      break;
34183016:	e016      	b.n	34183046 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_RGB888:
      stride = 3U;
34183018:	2303      	movs	r3, #3
3418301a:	617b      	str	r3, [r7, #20]
      break;
3418301c:	e013      	b.n	34183046 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_AL88:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_COPLANAR:
      stride = 2U;
3418301e:	2302      	movs	r3, #2
34183020:	617b      	str	r3, [r7, #20]
      break;
34183022:	e010      	b.n	34183046 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_FLEX_ARGB:
      stride = (((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos);
34183024:	68fb      	ldr	r3, [r7, #12]
34183026:	681b      	ldr	r3, [r3, #0]
34183028:	461a      	mov	r2, r3
3418302a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418302c:	021b      	lsls	r3, r3, #8
3418302e:	4413      	add	r3, r2
34183030:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183034:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34183036:	0c9b      	lsrs	r3, r3, #18
34183038:	f003 0307 	and.w	r3, r3, #7
3418303c:	617b      	str	r3, [r7, #20]
      break;
3418303e:	e002      	b.n	34183046 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_SEMIPLANAR:
    default:
      stride = 1U;
34183040:	2301      	movs	r3, #1
34183042:	617b      	str	r3, [r7, #20]
      break;
34183044:	bf00      	nop
  }

  /* Configure the horizontal start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34183046:	68fa      	ldr	r2, [r7, #12]
34183048:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418304a:	2134      	movs	r1, #52	@ 0x34
3418304c:	fb01 f303 	mul.w	r3, r1, r3
34183050:	4413      	add	r3, r2
34183052:	333c      	adds	r3, #60	@ 0x3c
34183054:	681a      	ldr	r2, [r3, #0]
34183056:	68fb      	ldr	r3, [r7, #12]
34183058:	681b      	ldr	r3, [r3, #0]
3418305a:	68db      	ldr	r3, [r3, #12]
3418305c:	0c1b      	lsrs	r3, r3, #16
3418305e:	f3c3 030b 	ubfx	r3, r3, #0, #12
34183062:	4413      	add	r3, r2
34183064:	041b      	lsls	r3, r3, #16
34183066:	613b      	str	r3, [r7, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
34183068:	68fa      	ldr	r2, [r7, #12]
3418306a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418306c:	2134      	movs	r1, #52	@ 0x34
3418306e:	fb01 f303 	mul.w	r3, r1, r3
34183072:	4413      	add	r3, r2
34183074:	3338      	adds	r3, #56	@ 0x38
34183076:	681a      	ldr	r2, [r3, #0]
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34183078:	68fb      	ldr	r3, [r7, #12]
3418307a:	681b      	ldr	r3, [r3, #0]
3418307c:	68db      	ldr	r3, [r3, #12]
3418307e:	0c1b      	lsrs	r3, r3, #16
34183080:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
34183084:	4413      	add	r3, r2
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34183086:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
34183088:	68fb      	ldr	r3, [r7, #12]
3418308a:	681b      	ldr	r3, [r3, #0]
3418308c:	4619      	mov	r1, r3
3418308e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183090:	021b      	lsls	r3, r3, #8
34183092:	440b      	add	r3, r1
34183094:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183098:	4619      	mov	r1, r3
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3418309a:	693b      	ldr	r3, [r7, #16]
3418309c:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3418309e:	610b      	str	r3, [r1, #16]

  /* Configure the vertical start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
341830a0:	68fa      	ldr	r2, [r7, #12]
341830a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341830a4:	2134      	movs	r1, #52	@ 0x34
341830a6:	fb01 f303 	mul.w	r3, r1, r3
341830aa:	4413      	add	r3, r2
341830ac:	3344      	adds	r3, #68	@ 0x44
341830ae:	681a      	ldr	r2, [r3, #0]
341830b0:	68fb      	ldr	r3, [r7, #12]
341830b2:	681b      	ldr	r3, [r3, #0]
341830b4:	68db      	ldr	r3, [r3, #12]
341830b6:	f3c3 030b 	ubfx	r3, r3, #0, #12
341830ba:	4413      	add	r3, r2
341830bc:	041b      	lsls	r3, r3, #16
341830be:	613b      	str	r3, [r7, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
341830c0:	68fa      	ldr	r2, [r7, #12]
341830c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341830c4:	2134      	movs	r1, #52	@ 0x34
341830c6:	fb01 f303 	mul.w	r3, r1, r3
341830ca:	4413      	add	r3, r2
341830cc:	3340      	adds	r3, #64	@ 0x40
341830ce:	681a      	ldr	r2, [r3, #0]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
341830d0:	68fb      	ldr	r3, [r7, #12]
341830d2:	681b      	ldr	r3, [r3, #0]
341830d4:	68db      	ldr	r3, [r3, #12]
341830d6:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
341830da:	4413      	add	r3, r2
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
341830dc:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
341830de:	68fb      	ldr	r3, [r7, #12]
341830e0:	681b      	ldr	r3, [r3, #0]
341830e2:	4619      	mov	r1, r3
341830e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341830e6:	021b      	lsls	r3, r3, #8
341830e8:	440b      	add	r3, r1
341830ea:	f503 7380 	add.w	r3, r3, #256	@ 0x100
341830ee:	4619      	mov	r1, r3
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
341830f0:	693b      	ldr	r3, [r7, #16]
341830f2:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
341830f4:	614b      	str	r3, [r1, #20]

  if (Mirror == LTDC_MIRROR_NONE)
341830f6:	683b      	ldr	r3, [r7, #0]
341830f8:	2b03      	cmp	r3, #3
341830fa:	f040 80fb 	bne.w	341832f4 <LTDC_SetConfig+0x376>
  {
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
341830fe:	68fb      	ldr	r3, [r7, #12]
34183100:	681b      	ldr	r3, [r3, #0]
34183102:	461a      	mov	r2, r3
34183104:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183106:	021b      	lsls	r3, r3, #8
34183108:	4413      	add	r3, r2
3418310a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418310e:	4618      	mov	r0, r3
34183110:	68fa      	ldr	r2, [r7, #12]
34183112:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183114:	2134      	movs	r1, #52	@ 0x34
34183116:	fb01 f303 	mul.w	r3, r1, r3
3418311a:	4413      	add	r3, r2
3418311c:	335c      	adds	r3, #92	@ 0x5c
3418311e:	681b      	ldr	r3, [r3, #0]
34183120:	6343      	str	r3, [r0, #52]	@ 0x34

    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34183122:	68fa      	ldr	r2, [r7, #12]
34183124:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183126:	2134      	movs	r1, #52	@ 0x34
34183128:	fb01 f303 	mul.w	r3, r1, r3
3418312c:	4413      	add	r3, r2
3418312e:	3348      	adds	r3, #72	@ 0x48
34183130:	681b      	ldr	r3, [r3, #0]
34183132:	f240 120d 	movw	r2, #269	@ 0x10d
34183136:	4293      	cmp	r3, r2
34183138:	d004      	beq.n	34183144 <LTDC_SetConfig+0x1c6>
3418313a:	f240 220d 	movw	r2, #525	@ 0x20d
3418313e:	4293      	cmp	r3, r2
34183140:	d043      	beq.n	341831ca <LTDC_SetConfig+0x24c>
        /* Configure the frame buffer line number */
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
        break;
      default:
        /* Nothing to do */
        break;
34183142:	e092      	b.n	3418326a <LTDC_SetConfig+0x2ec>
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
34183144:	68fb      	ldr	r3, [r7, #12]
34183146:	681b      	ldr	r3, [r3, #0]
34183148:	461a      	mov	r2, r3
3418314a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418314c:	021b      	lsls	r3, r3, #8
3418314e:	4413      	add	r3, r2
34183150:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183154:	461a      	mov	r2, r3
34183156:	68bb      	ldr	r3, [r7, #8]
34183158:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3418315a:	68fa      	ldr	r2, [r7, #12]
3418315c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418315e:	2134      	movs	r1, #52	@ 0x34
34183160:	fb01 f303 	mul.w	r3, r1, r3
34183164:	4413      	add	r3, r2
34183166:	3360      	adds	r3, #96	@ 0x60
34183168:	681b      	ldr	r3, [r3, #0]
3418316a:	041a      	lsls	r2, r3, #16
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418316c:	68f9      	ldr	r1, [r7, #12]
3418316e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183170:	2034      	movs	r0, #52	@ 0x34
34183172:	fb00 f303 	mul.w	r3, r0, r3
34183176:	440b      	add	r3, r1
34183178:	333c      	adds	r3, #60	@ 0x3c
3418317a:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
3418317c:	68f8      	ldr	r0, [r7, #12]
3418317e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183180:	2434      	movs	r4, #52	@ 0x34
34183182:	fb04 f303 	mul.w	r3, r4, r3
34183186:	4403      	add	r3, r0
34183188:	3338      	adds	r3, #56	@ 0x38
3418318a:	681b      	ldr	r3, [r3, #0]
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418318c:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
3418318e:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
34183190:	68f9      	ldr	r1, [r7, #12]
34183192:	6809      	ldr	r1, [r1, #0]
34183194:	4608      	mov	r0, r1
34183196:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34183198:	0209      	lsls	r1, r1, #8
3418319a:	4401      	add	r1, r0
3418319c:	f501 7180 	add.w	r1, r1, #256	@ 0x100
341831a0:	4313      	orrs	r3, r2
341831a2:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
341831a4:	68fa      	ldr	r2, [r7, #12]
341831a6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341831a8:	2134      	movs	r1, #52	@ 0x34
341831aa:	fb01 f303 	mul.w	r3, r1, r3
341831ae:	4413      	add	r3, r2
341831b0:	3364      	adds	r3, #100	@ 0x64
341831b2:	681b      	ldr	r3, [r3, #0]
341831b4:	68fa      	ldr	r2, [r7, #12]
341831b6:	6812      	ldr	r2, [r2, #0]
341831b8:	4611      	mov	r1, r2
341831ba:	6aba      	ldr	r2, [r7, #40]	@ 0x28
341831bc:	0212      	lsls	r2, r2, #8
341831be:	440a      	add	r2, r1
341831c0:	f502 7280 	add.w	r2, r2, #256	@ 0x100
341831c4:	085b      	lsrs	r3, r3, #1
341831c6:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
341831c8:	e04f      	b.n	3418326a <LTDC_SetConfig+0x2ec>
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
341831ca:	68fb      	ldr	r3, [r7, #12]
341831cc:	681b      	ldr	r3, [r3, #0]
341831ce:	461a      	mov	r2, r3
341831d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341831d2:	021b      	lsls	r3, r3, #8
341831d4:	4413      	add	r3, r2
341831d6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
341831da:	461a      	mov	r2, r3
341831dc:	68bb      	ldr	r3, [r7, #8]
341831de:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
341831e0:	68fb      	ldr	r3, [r7, #12]
341831e2:	681b      	ldr	r3, [r3, #0]
341831e4:	461a      	mov	r2, r3
341831e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341831e8:	021b      	lsls	r3, r3, #8
341831ea:	4413      	add	r3, r2
341831ec:	f503 7380 	add.w	r3, r3, #256	@ 0x100
341831f0:	461a      	mov	r2, r3
341831f2:	687b      	ldr	r3, [r7, #4]
341831f4:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
341831f6:	68fa      	ldr	r2, [r7, #12]
341831f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341831fa:	2134      	movs	r1, #52	@ 0x34
341831fc:	fb01 f303 	mul.w	r3, r1, r3
34183200:	4413      	add	r3, r2
34183202:	3360      	adds	r3, #96	@ 0x60
34183204:	681b      	ldr	r3, [r3, #0]
34183206:	085b      	lsrs	r3, r3, #1
34183208:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418320a:	68f9      	ldr	r1, [r7, #12]
3418320c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418320e:	2034      	movs	r0, #52	@ 0x34
34183210:	fb00 f303 	mul.w	r3, r0, r3
34183214:	440b      	add	r3, r1
34183216:	333c      	adds	r3, #60	@ 0x3c
34183218:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3418321a:	68f8      	ldr	r0, [r7, #12]
3418321c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418321e:	2434      	movs	r4, #52	@ 0x34
34183220:	fb04 f303 	mul.w	r3, r4, r3
34183224:	4403      	add	r3, r0
34183226:	3338      	adds	r3, #56	@ 0x38
34183228:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418322a:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3418322c:	085b      	lsrs	r3, r3, #1
3418322e:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34183230:	68f9      	ldr	r1, [r7, #12]
34183232:	6809      	ldr	r1, [r1, #0]
34183234:	4608      	mov	r0, r1
34183236:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34183238:	0209      	lsls	r1, r1, #8
3418323a:	4401      	add	r1, r0
3418323c:	f501 7180 	add.w	r1, r1, #256	@ 0x100
34183240:	4313      	orrs	r3, r2
34183242:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
34183244:	68fa      	ldr	r2, [r7, #12]
34183246:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183248:	2134      	movs	r1, #52	@ 0x34
3418324a:	fb01 f303 	mul.w	r3, r1, r3
3418324e:	4413      	add	r3, r2
34183250:	3364      	adds	r3, #100	@ 0x64
34183252:	681b      	ldr	r3, [r3, #0]
34183254:	68fa      	ldr	r2, [r7, #12]
34183256:	6812      	ldr	r2, [r2, #0]
34183258:	4611      	mov	r1, r2
3418325a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418325c:	0212      	lsls	r2, r2, #8
3418325e:	440a      	add	r2, r1
34183260:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34183264:	085b      	lsrs	r3, r3, #1
34183266:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
34183268:	bf00      	nop
    }

    /* Configure the color frame buffer pitch in byte */
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3418326a:	68fa      	ldr	r2, [r7, #12]
3418326c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418326e:	2134      	movs	r1, #52	@ 0x34
34183270:	fb01 f303 	mul.w	r3, r1, r3
34183274:	4413      	add	r3, r2
34183276:	3360      	adds	r3, #96	@ 0x60
34183278:	681b      	ldr	r3, [r3, #0]
3418327a:	697a      	ldr	r2, [r7, #20]
3418327c:	fb02 f303 	mul.w	r3, r2, r3
34183280:	041a      	lsls	r2, r3, #16
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0) *
34183282:	68f9      	ldr	r1, [r7, #12]
34183284:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183286:	2034      	movs	r0, #52	@ 0x34
34183288:	fb00 f303 	mul.w	r3, r0, r3
3418328c:	440b      	add	r3, r1
3418328e:	333c      	adds	r3, #60	@ 0x3c
34183290:	6819      	ldr	r1, [r3, #0]
34183292:	68f8      	ldr	r0, [r7, #12]
34183294:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183296:	2434      	movs	r4, #52	@ 0x34
34183298:	fb04 f303 	mul.w	r3, r4, r3
3418329c:	4403      	add	r3, r0
3418329e:	3338      	adds	r3, #56	@ 0x38
341832a0:	681b      	ldr	r3, [r3, #0]
341832a2:	1acb      	subs	r3, r1, r3
341832a4:	6979      	ldr	r1, [r7, #20]
341832a6:	fb01 f303 	mul.w	r3, r1, r3
                                            stride)  + 7U));
341832aa:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
341832ac:	68f9      	ldr	r1, [r7, #12]
341832ae:	6809      	ldr	r1, [r1, #0]
341832b0:	4608      	mov	r0, r1
341832b2:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
341832b4:	0209      	lsls	r1, r1, #8
341832b6:	4401      	add	r1, r0
341832b8:	f501 7180 	add.w	r1, r1, #256	@ 0x100
341832bc:	4313      	orrs	r3, r2
341832be:	638b      	str	r3, [r1, #56]	@ 0x38

    /* Enable LTDC_Layer by setting LEN bit */
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR,LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
341832c0:	68fb      	ldr	r3, [r7, #12]
341832c2:	681b      	ldr	r3, [r3, #0]
341832c4:	461a      	mov	r2, r3
341832c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341832c8:	021b      	lsls	r3, r3, #8
341832ca:	4413      	add	r3, r2
341832cc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
341832d0:	68db      	ldr	r3, [r3, #12]
341832d2:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
341832d6:	f023 0301 	bic.w	r3, r3, #1
341832da:	68fa      	ldr	r2, [r7, #12]
341832dc:	6812      	ldr	r2, [r2, #0]
341832de:	4611      	mov	r1, r2
341832e0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
341832e2:	0212      	lsls	r2, r2, #8
341832e4:	440a      	add	r2, r1
341832e6:	f502 7280 	add.w	r2, r2, #256	@ 0x100
341832ea:	f043 0301 	orr.w	r3, r3, #1
341832ee:	60d3      	str	r3, [r2, #12]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable horizontal mirroring bit & LTDC_Layer by setting LEN bit */
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
  }
}
341832f0:	f000 bccc 	b.w	34183c8c <LTDC_SetConfig+0xd0e>
  else if (Mirror == LTDC_MIRROR_HORIZONTAL)
341832f4:	683b      	ldr	r3, [r7, #0]
341832f6:	2b00      	cmp	r3, #0
341832f8:	f040 814e 	bne.w	34183598 <LTDC_SetConfig+0x61a>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
341832fc:	68fa      	ldr	r2, [r7, #12]
341832fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183300:	2134      	movs	r1, #52	@ 0x34
34183302:	fb01 f303 	mul.w	r3, r1, r3
34183306:	4413      	add	r3, r2
34183308:	335c      	adds	r3, #92	@ 0x5c
3418330a:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418330c:	68f9      	ldr	r1, [r7, #12]
3418330e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183310:	2034      	movs	r0, #52	@ 0x34
34183312:	fb00 f303 	mul.w	r3, r0, r3
34183316:	440b      	add	r3, r1
34183318:	333c      	adds	r3, #60	@ 0x3c
3418331a:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3418331c:	68f8      	ldr	r0, [r7, #12]
3418331e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183320:	2434      	movs	r4, #52	@ 0x34
34183322:	fb04 f303 	mul.w	r3, r4, r3
34183326:	4403      	add	r3, r0
34183328:	3338      	adds	r3, #56	@ 0x38
3418332a:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418332c:	1acb      	subs	r3, r1, r3
3418332e:	6979      	ldr	r1, [r7, #20]
34183330:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34183334:	4413      	add	r3, r2
34183336:	68fa      	ldr	r2, [r7, #12]
34183338:	6812      	ldr	r2, [r2, #0]
3418333a:	4611      	mov	r1, r2
3418333c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418333e:	0212      	lsls	r2, r2, #8
34183340:	440a      	add	r2, r1
34183342:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
34183346:	3b01      	subs	r3, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34183348:	6353      	str	r3, [r2, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418334a:	68fa      	ldr	r2, [r7, #12]
3418334c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418334e:	2134      	movs	r1, #52	@ 0x34
34183350:	fb01 f303 	mul.w	r3, r1, r3
34183354:	4413      	add	r3, r2
34183356:	3348      	adds	r3, #72	@ 0x48
34183358:	681b      	ldr	r3, [r3, #0]
3418335a:	f240 120d 	movw	r2, #269	@ 0x10d
3418335e:	4293      	cmp	r3, r2
34183360:	d004      	beq.n	3418336c <LTDC_SetConfig+0x3ee>
34183362:	f240 220d 	movw	r2, #525	@ 0x20d
34183366:	4293      	cmp	r3, r2
34183368:	d058      	beq.n	3418341c <LTDC_SetConfig+0x49e>
        break;
3418336a:	e0d3      	b.n	34183514 <LTDC_SetConfig+0x596>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418336c:	68fa      	ldr	r2, [r7, #12]
3418336e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183370:	2134      	movs	r1, #52	@ 0x34
34183372:	fb01 f303 	mul.w	r3, r1, r3
34183376:	4413      	add	r3, r2
34183378:	333c      	adds	r3, #60	@ 0x3c
3418337a:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3418337c:	68f9      	ldr	r1, [r7, #12]
3418337e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183380:	2034      	movs	r0, #52	@ 0x34
34183382:	fb00 f303 	mul.w	r3, r0, r3
34183386:	440b      	add	r3, r1
34183388:	3338      	adds	r3, #56	@ 0x38
3418338a:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418338c:	1ad3      	subs	r3, r2, r3
3418338e:	697a      	ldr	r2, [r7, #20]
34183390:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34183394:	68bb      	ldr	r3, [r7, #8]
34183396:	4413      	add	r3, r2
34183398:	68fa      	ldr	r2, [r7, #12]
3418339a:	6812      	ldr	r2, [r2, #0]
3418339c:	4611      	mov	r1, r2
3418339e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
341833a0:	0212      	lsls	r2, r2, #8
341833a2:	440a      	add	r2, r1
341833a4:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
341833a8:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
341833aa:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
341833ac:	68fa      	ldr	r2, [r7, #12]
341833ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341833b0:	2134      	movs	r1, #52	@ 0x34
341833b2:	fb01 f303 	mul.w	r3, r1, r3
341833b6:	4413      	add	r3, r2
341833b8:	3360      	adds	r3, #96	@ 0x60
341833ba:	681b      	ldr	r3, [r3, #0]
341833bc:	041a      	lsls	r2, r3, #16
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0 +
341833be:	68f9      	ldr	r1, [r7, #12]
341833c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341833c2:	2034      	movs	r0, #52	@ 0x34
341833c4:	fb00 f303 	mul.w	r3, r0, r3
341833c8:	440b      	add	r3, r1
341833ca:	333c      	adds	r3, #60	@ 0x3c
341833cc:	6819      	ldr	r1, [r3, #0]
341833ce:	68f8      	ldr	r0, [r7, #12]
341833d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341833d2:	2434      	movs	r4, #52	@ 0x34
341833d4:	fb04 f303 	mul.w	r3, r4, r3
341833d8:	4403      	add	r3, r0
341833da:	3338      	adds	r3, #56	@ 0x38
341833dc:	681b      	ldr	r3, [r3, #0]
341833de:	1acb      	subs	r3, r1, r3
341833e0:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
341833e2:	68f9      	ldr	r1, [r7, #12]
341833e4:	6809      	ldr	r1, [r1, #0]
341833e6:	4608      	mov	r0, r1
341833e8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
341833ea:	0209      	lsls	r1, r1, #8
341833ec:	4401      	add	r1, r0
341833ee:	f501 7180 	add.w	r1, r1, #256	@ 0x100
341833f2:	4313      	orrs	r3, r2
341833f4:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U ;
341833f6:	68fa      	ldr	r2, [r7, #12]
341833f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341833fa:	2134      	movs	r1, #52	@ 0x34
341833fc:	fb01 f303 	mul.w	r3, r1, r3
34183400:	4413      	add	r3, r2
34183402:	3364      	adds	r3, #100	@ 0x64
34183404:	681b      	ldr	r3, [r3, #0]
34183406:	68fa      	ldr	r2, [r7, #12]
34183408:	6812      	ldr	r2, [r2, #0]
3418340a:	4611      	mov	r1, r2
3418340c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418340e:	0212      	lsls	r2, r2, #8
34183410:	440a      	add	r2, r1
34183412:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34183416:	085b      	lsrs	r3, r3, #1
34183418:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418341a:	e07b      	b.n	34183514 <LTDC_SetConfig+0x596>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418341c:	68fa      	ldr	r2, [r7, #12]
3418341e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183420:	2134      	movs	r1, #52	@ 0x34
34183422:	fb01 f303 	mul.w	r3, r1, r3
34183426:	4413      	add	r3, r2
34183428:	333c      	adds	r3, #60	@ 0x3c
3418342a:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418342c:	68f9      	ldr	r1, [r7, #12]
3418342e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183430:	2034      	movs	r0, #52	@ 0x34
34183432:	fb00 f303 	mul.w	r3, r0, r3
34183436:	440b      	add	r3, r1
34183438:	3338      	adds	r3, #56	@ 0x38
3418343a:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418343c:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418343e:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183440:	697a      	ldr	r2, [r7, #20]
34183442:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34183446:	68bb      	ldr	r3, [r7, #8]
34183448:	4413      	add	r3, r2
3418344a:	68fa      	ldr	r2, [r7, #12]
3418344c:	6812      	ldr	r2, [r2, #0]
3418344e:	4611      	mov	r1, r2
34183450:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183452:	0212      	lsls	r2, r2, #8
34183454:	440a      	add	r2, r1
34183456:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418345a:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418345c:	6413      	str	r3, [r2, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418345e:	68fa      	ldr	r2, [r7, #12]
34183460:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183462:	2134      	movs	r1, #52	@ 0x34
34183464:	fb01 f303 	mul.w	r3, r1, r3
34183468:	4413      	add	r3, r2
3418346a:	333c      	adds	r3, #60	@ 0x3c
3418346c:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418346e:	68f9      	ldr	r1, [r7, #12]
34183470:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183472:	2034      	movs	r0, #52	@ 0x34
34183474:	fb00 f303 	mul.w	r3, r0, r3
34183478:	440b      	add	r3, r1
3418347a:	3338      	adds	r3, #56	@ 0x38
3418347c:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418347e:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34183480:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183482:	697a      	ldr	r2, [r7, #20]
34183484:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34183488:	687b      	ldr	r3, [r7, #4]
3418348a:	4413      	add	r3, r2
3418348c:	68fa      	ldr	r2, [r7, #12]
3418348e:	6812      	ldr	r2, [r2, #0]
34183490:	4611      	mov	r1, r2
34183492:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183494:	0212      	lsls	r2, r2, #8
34183496:	440a      	add	r2, r1
34183498:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418349c:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3418349e:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
341834a0:	68fa      	ldr	r2, [r7, #12]
341834a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341834a4:	2134      	movs	r1, #52	@ 0x34
341834a6:	fb01 f303 	mul.w	r3, r1, r3
341834aa:	4413      	add	r3, r2
341834ac:	3360      	adds	r3, #96	@ 0x60
341834ae:	681b      	ldr	r3, [r3, #0]
341834b0:	085b      	lsrs	r3, r3, #1
341834b2:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
341834b4:	68f9      	ldr	r1, [r7, #12]
341834b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341834b8:	2034      	movs	r0, #52	@ 0x34
341834ba:	fb00 f303 	mul.w	r3, r0, r3
341834be:	440b      	add	r3, r1
341834c0:	333c      	adds	r3, #60	@ 0x3c
341834c2:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
341834c4:	68f8      	ldr	r0, [r7, #12]
341834c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341834c8:	2434      	movs	r4, #52	@ 0x34
341834ca:	fb04 f303 	mul.w	r3, r4, r3
341834ce:	4403      	add	r3, r0
341834d0:	3338      	adds	r3, #56	@ 0x38
341834d2:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
341834d4:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
341834d6:	085b      	lsrs	r3, r3, #1
341834d8:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
341834da:	68f9      	ldr	r1, [r7, #12]
341834dc:	6809      	ldr	r1, [r1, #0]
341834de:	4608      	mov	r0, r1
341834e0:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
341834e2:	0209      	lsls	r1, r1, #8
341834e4:	4401      	add	r1, r0
341834e6:	f501 7180 	add.w	r1, r1, #256	@ 0x100
341834ea:	4313      	orrs	r3, r2
341834ec:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
341834ee:	68fa      	ldr	r2, [r7, #12]
341834f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341834f2:	2134      	movs	r1, #52	@ 0x34
341834f4:	fb01 f303 	mul.w	r3, r1, r3
341834f8:	4413      	add	r3, r2
341834fa:	3364      	adds	r3, #100	@ 0x64
341834fc:	681b      	ldr	r3, [r3, #0]
341834fe:	68fa      	ldr	r2, [r7, #12]
34183500:	6812      	ldr	r2, [r2, #0]
34183502:	4611      	mov	r1, r2
34183504:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183506:	0212      	lsls	r2, r2, #8
34183508:	440a      	add	r2, r1
3418350a:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418350e:	085b      	lsrs	r3, r3, #1
34183510:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
34183512:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34183514:	68fa      	ldr	r2, [r7, #12]
34183516:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183518:	2134      	movs	r1, #52	@ 0x34
3418351a:	fb01 f303 	mul.w	r3, r1, r3
3418351e:	4413      	add	r3, r2
34183520:	3360      	adds	r3, #96	@ 0x60
34183522:	681b      	ldr	r3, [r3, #0]
34183524:	697a      	ldr	r2, [r7, #20]
34183526:	fb02 f303 	mul.w	r3, r2, r3
3418352a:	041a      	lsls	r2, r3, #16
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418352c:	68f9      	ldr	r1, [r7, #12]
3418352e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183530:	2034      	movs	r0, #52	@ 0x34
34183532:	fb00 f303 	mul.w	r3, r0, r3
34183536:	440b      	add	r3, r1
34183538:	333c      	adds	r3, #60	@ 0x3c
3418353a:	6819      	ldr	r1, [r3, #0]
                                             hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U));
3418353c:	68f8      	ldr	r0, [r7, #12]
3418353e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183540:	2434      	movs	r4, #52	@ 0x34
34183542:	fb04 f303 	mul.w	r3, r4, r3
34183546:	4403      	add	r3, r0
34183548:	3338      	adds	r3, #56	@ 0x38
3418354a:	681b      	ldr	r3, [r3, #0]
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418354c:	1acb      	subs	r3, r1, r3
                                             hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U));
3418354e:	6979      	ldr	r1, [r7, #20]
34183550:	fb01 f303 	mul.w	r3, r1, r3
34183554:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34183556:	68f9      	ldr	r1, [r7, #12]
34183558:	6809      	ldr	r1, [r1, #0]
3418355a:	4608      	mov	r0, r1
3418355c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418355e:	0209      	lsls	r1, r1, #8
34183560:	4401      	add	r1, r0
34183562:	f501 7180 	add.w	r1, r1, #256	@ 0x100
34183566:	4313      	orrs	r3, r2
34183568:	638b      	str	r3, [r1, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
3418356a:	68fb      	ldr	r3, [r7, #12]
3418356c:	681b      	ldr	r3, [r3, #0]
3418356e:	461a      	mov	r2, r3
34183570:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183572:	021b      	lsls	r3, r3, #8
34183574:	4413      	add	r3, r2
34183576:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418357a:	68db      	ldr	r3, [r3, #12]
3418357c:	68fa      	ldr	r2, [r7, #12]
3418357e:	6812      	ldr	r2, [r2, #0]
34183580:	4611      	mov	r1, r2
34183582:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183584:	0212      	lsls	r2, r2, #8
34183586:	440a      	add	r2, r1
34183588:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418358c:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34183590:	f043 0301 	orr.w	r3, r3, #1
34183594:	60d3      	str	r3, [r2, #12]
}
34183596:	e379      	b.n	34183c8c <LTDC_SetConfig+0xd0e>
  else if (Mirror == LTDC_MIRROR_VERTICAL)
34183598:	683b      	ldr	r3, [r7, #0]
3418359a:	2b01      	cmp	r3, #1
3418359c:	f040 81b4 	bne.w	34183908 <LTDC_SetConfig+0x98a>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
341835a0:	68fa      	ldr	r2, [r7, #12]
341835a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341835a4:	2134      	movs	r1, #52	@ 0x34
341835a6:	fb01 f303 	mul.w	r3, r1, r3
341835aa:	4413      	add	r3, r2
341835ac:	335c      	adds	r3, #92	@ 0x5c
341835ae:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
341835b0:	68f9      	ldr	r1, [r7, #12]
341835b2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341835b4:	2034      	movs	r0, #52	@ 0x34
341835b6:	fb00 f303 	mul.w	r3, r0, r3
341835ba:	440b      	add	r3, r1
341835bc:	333c      	adds	r3, #60	@ 0x3c
341835be:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
341835c0:	68f8      	ldr	r0, [r7, #12]
341835c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341835c4:	2434      	movs	r4, #52	@ 0x34
341835c6:	fb04 f303 	mul.w	r3, r4, r3
341835ca:	4403      	add	r3, r0
341835cc:	3338      	adds	r3, #56	@ 0x38
341835ce:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
341835d0:	1acb      	subs	r3, r1, r3
341835d2:	6979      	ldr	r1, [r7, #20]
341835d4:	fb01 f303 	mul.w	r3, r1, r3
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
341835d8:	68f8      	ldr	r0, [r7, #12]
341835da:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
341835dc:	2434      	movs	r4, #52	@ 0x34
341835de:	fb04 f101 	mul.w	r1, r4, r1
341835e2:	4401      	add	r1, r0
341835e4:	3144      	adds	r1, #68	@ 0x44
341835e6:	6808      	ldr	r0, [r1, #0]
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
341835e8:	68fc      	ldr	r4, [r7, #12]
341835ea:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
341835ec:	2534      	movs	r5, #52	@ 0x34
341835ee:	fb05 f101 	mul.w	r1, r5, r1
341835f2:	4421      	add	r1, r4
341835f4:	3140      	adds	r1, #64	@ 0x40
341835f6:	6809      	ldr	r1, [r1, #0]
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
341835f8:	1a41      	subs	r1, r0, r1
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
341835fa:	3901      	subs	r1, #1
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
341835fc:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34183600:	68f9      	ldr	r1, [r7, #12]
34183602:	6809      	ldr	r1, [r1, #0]
34183604:	4608      	mov	r0, r1
34183606:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34183608:	0209      	lsls	r1, r1, #8
3418360a:	4401      	add	r1, r0
3418360c:	f501 7180 	add.w	r1, r1, #256	@ 0x100
34183610:	4413      	add	r3, r2
34183612:	634b      	str	r3, [r1, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34183614:	68fa      	ldr	r2, [r7, #12]
34183616:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183618:	2134      	movs	r1, #52	@ 0x34
3418361a:	fb01 f303 	mul.w	r3, r1, r3
3418361e:	4413      	add	r3, r2
34183620:	3348      	adds	r3, #72	@ 0x48
34183622:	681b      	ldr	r3, [r3, #0]
34183624:	f240 120d 	movw	r2, #269	@ 0x10d
34183628:	4293      	cmp	r3, r2
3418362a:	d004      	beq.n	34183636 <LTDC_SetConfig+0x6b8>
3418362c:	f240 220d 	movw	r2, #525	@ 0x20d
34183630:	4293      	cmp	r3, r2
34183632:	d075      	beq.n	34183720 <LTDC_SetConfig+0x7a2>
        break;
34183634:	e122      	b.n	3418387c <LTDC_SetConfig+0x8fe>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
34183636:	68fa      	ldr	r2, [r7, #12]
34183638:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418363a:	2134      	movs	r1, #52	@ 0x34
3418363c:	fb01 f303 	mul.w	r3, r1, r3
34183640:	4413      	add	r3, r2
34183642:	333c      	adds	r3, #60	@ 0x3c
34183644:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
34183646:	68f9      	ldr	r1, [r7, #12]
34183648:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418364a:	2034      	movs	r0, #52	@ 0x34
3418364c:	fb00 f303 	mul.w	r3, r0, r3
34183650:	440b      	add	r3, r1
34183652:	3338      	adds	r3, #56	@ 0x38
34183654:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
34183656:	1ad3      	subs	r3, r2, r3
34183658:	697a      	ldr	r2, [r7, #20]
3418365a:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418365e:	68f9      	ldr	r1, [r7, #12]
34183660:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183662:	2034      	movs	r0, #52	@ 0x34
34183664:	fb00 f202 	mul.w	r2, r0, r2
34183668:	440a      	add	r2, r1
3418366a:	3244      	adds	r2, #68	@ 0x44
3418366c:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418366e:	68f8      	ldr	r0, [r7, #12]
34183670:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183672:	2434      	movs	r4, #52	@ 0x34
34183674:	fb04 f202 	mul.w	r2, r4, r2
34183678:	4402      	add	r2, r0
3418367a:	3240      	adds	r2, #64	@ 0x40
3418367c:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418367e:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34183680:	0852      	lsrs	r2, r2, #1
34183682:	3a01      	subs	r2, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
34183684:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34183688:	68fb      	ldr	r3, [r7, #12]
3418368a:	681b      	ldr	r3, [r3, #0]
3418368c:	4619      	mov	r1, r3
3418368e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183690:	021b      	lsls	r3, r3, #8
34183692:	440b      	add	r3, r1
34183694:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183698:	4619      	mov	r1, r3
3418369a:	68bb      	ldr	r3, [r7, #8]
3418369c:	4413      	add	r3, r2
3418369e:	640b      	str	r3, [r1, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
341836a0:	68fa      	ldr	r2, [r7, #12]
341836a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341836a4:	2134      	movs	r1, #52	@ 0x34
341836a6:	fb01 f303 	mul.w	r3, r1, r3
341836aa:	4413      	add	r3, r2
341836ac:	3360      	adds	r3, #96	@ 0x60
341836ae:	681b      	ldr	r3, [r3, #0]
341836b0:	697a      	ldr	r2, [r7, #20]
341836b2:	fb02 f303 	mul.w	r3, r2, r3
341836b6:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
341836ba:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
341836bc:	68f9      	ldr	r1, [r7, #12]
341836be:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341836c0:	2034      	movs	r0, #52	@ 0x34
341836c2:	fb00 f303 	mul.w	r3, r0, r3
341836c6:	440b      	add	r3, r1
341836c8:	333c      	adds	r3, #60	@ 0x3c
341836ca:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U);
341836cc:	68f8      	ldr	r0, [r7, #12]
341836ce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341836d0:	2434      	movs	r4, #52	@ 0x34
341836d2:	fb04 f303 	mul.w	r3, r4, r3
341836d6:	4403      	add	r3, r0
341836d8:	3338      	adds	r3, #56	@ 0x38
341836da:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
341836dc:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U);
341836de:	6979      	ldr	r1, [r7, #20]
341836e0:	fb01 f303 	mul.w	r3, r1, r3
341836e4:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
341836e6:	68f9      	ldr	r1, [r7, #12]
341836e8:	6809      	ldr	r1, [r1, #0]
341836ea:	4608      	mov	r0, r1
341836ec:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
341836ee:	0209      	lsls	r1, r1, #8
341836f0:	4401      	add	r1, r0
341836f2:	f501 7180 	add.w	r1, r1, #256	@ 0x100
341836f6:	4313      	orrs	r3, r2
341836f8:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
341836fa:	68fa      	ldr	r2, [r7, #12]
341836fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341836fe:	2134      	movs	r1, #52	@ 0x34
34183700:	fb01 f303 	mul.w	r3, r1, r3
34183704:	4413      	add	r3, r2
34183706:	3364      	adds	r3, #100	@ 0x64
34183708:	681b      	ldr	r3, [r3, #0]
3418370a:	68fa      	ldr	r2, [r7, #12]
3418370c:	6812      	ldr	r2, [r2, #0]
3418370e:	4611      	mov	r1, r2
34183710:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183712:	0212      	lsls	r2, r2, #8
34183714:	440a      	add	r2, r1
34183716:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418371a:	085b      	lsrs	r3, r3, #1
3418371c:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418371e:	e0ad      	b.n	3418387c <LTDC_SetConfig+0x8fe>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183720:	68fa      	ldr	r2, [r7, #12]
34183722:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183724:	2134      	movs	r1, #52	@ 0x34
34183726:	fb01 f303 	mul.w	r3, r1, r3
3418372a:	4413      	add	r3, r2
3418372c:	333c      	adds	r3, #60	@ 0x3c
3418372e:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34183730:	68f9      	ldr	r1, [r7, #12]
34183732:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183734:	2034      	movs	r0, #52	@ 0x34
34183736:	fb00 f303 	mul.w	r3, r0, r3
3418373a:	440b      	add	r3, r1
3418373c:	3338      	adds	r3, #56	@ 0x38
3418373e:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183740:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34183742:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183744:	697a      	ldr	r2, [r7, #20]
34183746:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418374a:	68f9      	ldr	r1, [r7, #12]
3418374c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418374e:	2034      	movs	r0, #52	@ 0x34
34183750:	fb00 f202 	mul.w	r2, r0, r2
34183754:	440a      	add	r2, r1
34183756:	3244      	adds	r2, #68	@ 0x44
34183758:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418375a:	68f8      	ldr	r0, [r7, #12]
3418375c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418375e:	2434      	movs	r4, #52	@ 0x34
34183760:	fb04 f202 	mul.w	r2, r4, r2
34183764:	4402      	add	r2, r0
34183766:	3240      	adds	r2, #64	@ 0x40
34183768:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418376a:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418376c:	0852      	lsrs	r2, r2, #1
3418376e:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34183770:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34183774:	68fb      	ldr	r3, [r7, #12]
34183776:	681b      	ldr	r3, [r3, #0]
34183778:	4619      	mov	r1, r3
3418377a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418377c:	021b      	lsls	r3, r3, #8
3418377e:	440b      	add	r3, r1
34183780:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183784:	4619      	mov	r1, r3
34183786:	68bb      	ldr	r3, [r7, #8]
34183788:	4413      	add	r3, r2
3418378a:	640b      	str	r3, [r1, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418378c:	68fa      	ldr	r2, [r7, #12]
3418378e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183790:	2134      	movs	r1, #52	@ 0x34
34183792:	fb01 f303 	mul.w	r3, r1, r3
34183796:	4413      	add	r3, r2
34183798:	333c      	adds	r3, #60	@ 0x3c
3418379a:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418379c:	68f9      	ldr	r1, [r7, #12]
3418379e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341837a0:	2034      	movs	r0, #52	@ 0x34
341837a2:	fb00 f303 	mul.w	r3, r0, r3
341837a6:	440b      	add	r3, r1
341837a8:	3338      	adds	r3, #56	@ 0x38
341837aa:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
341837ac:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
341837ae:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
341837b0:	697a      	ldr	r2, [r7, #20]
341837b2:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
341837b6:	68f9      	ldr	r1, [r7, #12]
341837b8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
341837ba:	2034      	movs	r0, #52	@ 0x34
341837bc:	fb00 f202 	mul.w	r2, r0, r2
341837c0:	440a      	add	r2, r1
341837c2:	3244      	adds	r2, #68	@ 0x44
341837c4:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
341837c6:	68f8      	ldr	r0, [r7, #12]
341837c8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
341837ca:	2434      	movs	r4, #52	@ 0x34
341837cc:	fb04 f202 	mul.w	r2, r4, r2
341837d0:	4402      	add	r2, r0
341837d2:	3240      	adds	r2, #64	@ 0x40
341837d4:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
341837d6:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
341837d8:	0852      	lsrs	r2, r2, #1
341837da:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
341837dc:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
341837e0:	68fb      	ldr	r3, [r7, #12]
341837e2:	681b      	ldr	r3, [r3, #0]
341837e4:	4619      	mov	r1, r3
341837e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341837e8:	021b      	lsls	r3, r3, #8
341837ea:	440b      	add	r3, r1
341837ec:	f503 7380 	add.w	r3, r3, #256	@ 0x100
341837f0:	4619      	mov	r1, r3
341837f2:	687b      	ldr	r3, [r7, #4]
341837f4:	4413      	add	r3, r2
341837f6:	644b      	str	r3, [r1, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
341837f8:	68fa      	ldr	r2, [r7, #12]
341837fa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341837fc:	2134      	movs	r1, #52	@ 0x34
341837fe:	fb01 f303 	mul.w	r3, r1, r3
34183802:	4413      	add	r3, r2
34183804:	3360      	adds	r3, #96	@ 0x60
34183806:	681b      	ldr	r3, [r3, #0]
34183808:	085b      	lsrs	r3, r3, #1
3418380a:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418380e:	697a      	ldr	r2, [r7, #20]
34183810:	fb02 f303 	mul.w	r3, r2, r3
                                               stride) << 16U) |
34183814:	041a      	lsls	r2, r3, #16
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183816:	68f9      	ldr	r1, [r7, #12]
34183818:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418381a:	2034      	movs	r0, #52	@ 0x34
3418381c:	fb00 f303 	mul.w	r3, r0, r3
34183820:	440b      	add	r3, r1
34183822:	333c      	adds	r3, #60	@ 0x3c
34183824:	6819      	ldr	r1, [r3, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34183826:	68f8      	ldr	r0, [r7, #12]
34183828:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418382a:	2434      	movs	r4, #52	@ 0x34
3418382c:	fb04 f303 	mul.w	r3, r4, r3
34183830:	4403      	add	r3, r0
34183832:	3338      	adds	r3, #56	@ 0x38
34183834:	681b      	ldr	r3, [r3, #0]
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183836:	1acb      	subs	r3, r1, r3
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34183838:	085b      	lsrs	r3, r3, #1
3418383a:	6979      	ldr	r1, [r7, #20]
3418383c:	fb01 f303 	mul.w	r3, r1, r3
34183840:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34183842:	68f9      	ldr	r1, [r7, #12]
34183844:	6809      	ldr	r1, [r1, #0]
34183846:	4608      	mov	r0, r1
34183848:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418384a:	0209      	lsls	r1, r1, #8
3418384c:	4401      	add	r1, r0
3418384e:	f501 7180 	add.w	r1, r1, #256	@ 0x100
                                               stride) << 16U) |
34183852:	4313      	orrs	r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34183854:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34183856:	68fa      	ldr	r2, [r7, #12]
34183858:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418385a:	2134      	movs	r1, #52	@ 0x34
3418385c:	fb01 f303 	mul.w	r3, r1, r3
34183860:	4413      	add	r3, r2
34183862:	3364      	adds	r3, #100	@ 0x64
34183864:	681b      	ldr	r3, [r3, #0]
34183866:	68fa      	ldr	r2, [r7, #12]
34183868:	6812      	ldr	r2, [r2, #0]
3418386a:	4611      	mov	r1, r2
3418386c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418386e:	0212      	lsls	r2, r2, #8
34183870:	440a      	add	r2, r1
34183872:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34183876:	085b      	lsrs	r3, r3, #1
34183878:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418387a:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3418387c:	68fa      	ldr	r2, [r7, #12]
3418387e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183880:	2134      	movs	r1, #52	@ 0x34
34183882:	fb01 f303 	mul.w	r3, r1, r3
34183886:	4413      	add	r3, r2
34183888:	3360      	adds	r3, #96	@ 0x60
3418388a:	681b      	ldr	r3, [r3, #0]
3418388c:	697a      	ldr	r2, [r7, #20]
3418388e:	fb02 f303 	mul.w	r3, r2, r3
34183892:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
34183896:	041a      	lsls	r2, r3, #16
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183898:	68f9      	ldr	r1, [r7, #12]
3418389a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418389c:	2034      	movs	r0, #52	@ 0x34
3418389e:	fb00 f303 	mul.w	r3, r0, r3
341838a2:	440b      	add	r3, r1
341838a4:	333c      	adds	r3, #60	@ 0x3c
341838a6:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
341838a8:	68f8      	ldr	r0, [r7, #12]
341838aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341838ac:	2434      	movs	r4, #52	@ 0x34
341838ae:	fb04 f303 	mul.w	r3, r4, r3
341838b2:	4403      	add	r3, r0
341838b4:	3338      	adds	r3, #56	@ 0x38
341838b6:	681b      	ldr	r3, [r3, #0]
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
341838b8:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
341838ba:	6979      	ldr	r1, [r7, #20]
341838bc:	fb01 f303 	mul.w	r3, r1, r3
341838c0:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
341838c2:	68f9      	ldr	r1, [r7, #12]
341838c4:	6809      	ldr	r1, [r1, #0]
341838c6:	4608      	mov	r0, r1
341838c8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
341838ca:	0209      	lsls	r1, r1, #8
341838cc:	4401      	add	r1, r0
341838ce:	f501 7180 	add.w	r1, r1, #256	@ 0x100
341838d2:	4313      	orrs	r3, r2
341838d4:	638b      	str	r3, [r1, #56]	@ 0x38
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
341838d6:	68fb      	ldr	r3, [r7, #12]
341838d8:	681b      	ldr	r3, [r3, #0]
341838da:	461a      	mov	r2, r3
341838dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341838de:	021b      	lsls	r3, r3, #8
341838e0:	4413      	add	r3, r2
341838e2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
341838e6:	68db      	ldr	r3, [r3, #12]
341838e8:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
341838ec:	f023 0301 	bic.w	r3, r3, #1
341838f0:	68fa      	ldr	r2, [r7, #12]
341838f2:	6812      	ldr	r2, [r2, #0]
341838f4:	4611      	mov	r1, r2
341838f6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
341838f8:	0212      	lsls	r2, r2, #8
341838fa:	440a      	add	r2, r1
341838fc:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34183900:	f043 0301 	orr.w	r3, r3, #1
34183904:	60d3      	str	r3, [r2, #12]
}
34183906:	e1c1      	b.n	34183c8c <LTDC_SetConfig+0xd0e>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34183908:	68fa      	ldr	r2, [r7, #12]
3418390a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418390c:	2134      	movs	r1, #52	@ 0x34
3418390e:	fb01 f303 	mul.w	r3, r1, r3
34183912:	4413      	add	r3, r2
34183914:	335c      	adds	r3, #92	@ 0x5c
34183916:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
34183918:	68f9      	ldr	r1, [r7, #12]
3418391a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418391c:	2034      	movs	r0, #52	@ 0x34
3418391e:	fb00 f303 	mul.w	r3, r0, r3
34183922:	440b      	add	r3, r1
34183924:	333c      	adds	r3, #60	@ 0x3c
34183926:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
34183928:	68f8      	ldr	r0, [r7, #12]
3418392a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418392c:	2434      	movs	r4, #52	@ 0x34
3418392e:	fb04 f303 	mul.w	r3, r4, r3
34183932:	4403      	add	r3, r0
34183934:	3338      	adds	r3, #56	@ 0x38
34183936:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
34183938:	1acb      	subs	r3, r1, r3
3418393a:	6979      	ldr	r1, [r7, #20]
3418393c:	fb01 f303 	mul.w	r3, r1, r3
                                          (hltdc->LayerCfg[LayerIdx].WindowY1 - \
34183940:	68f8      	ldr	r0, [r7, #12]
34183942:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34183944:	2434      	movs	r4, #52	@ 0x34
34183946:	fb04 f101 	mul.w	r1, r4, r1
3418394a:	4401      	add	r1, r0
3418394c:	3144      	adds	r1, #68	@ 0x44
3418394e:	6808      	ldr	r0, [r1, #0]
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
34183950:	68fc      	ldr	r4, [r7, #12]
34183952:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34183954:	2534      	movs	r5, #52	@ 0x34
34183956:	fb05 f101 	mul.w	r1, r5, r1
3418395a:	4421      	add	r1, r4
3418395c:	3140      	adds	r1, #64	@ 0x40
3418395e:	6809      	ldr	r1, [r1, #0]
                                          (hltdc->LayerCfg[LayerIdx].WindowY1 - \
34183960:	1a41      	subs	r1, r0, r1
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
34183962:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34183966:	4413      	add	r3, r2
34183968:	68fa      	ldr	r2, [r7, #12]
3418396a:	6812      	ldr	r2, [r2, #0]
3418396c:	4611      	mov	r1, r2
3418396e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183970:	0212      	lsls	r2, r2, #8
34183972:	440a      	add	r2, r1
34183974:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
34183978:	3b01      	subs	r3, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418397a:	6353      	str	r3, [r2, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418397c:	68fa      	ldr	r2, [r7, #12]
3418397e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183980:	2134      	movs	r1, #52	@ 0x34
34183982:	fb01 f303 	mul.w	r3, r1, r3
34183986:	4413      	add	r3, r2
34183988:	3348      	adds	r3, #72	@ 0x48
3418398a:	681b      	ldr	r3, [r3, #0]
3418398c:	f240 120d 	movw	r2, #269	@ 0x10d
34183990:	4293      	cmp	r3, r2
34183992:	d004      	beq.n	3418399e <LTDC_SetConfig+0xa20>
34183994:	f240 220d 	movw	r2, #525	@ 0x20d
34183998:	4293      	cmp	r3, r2
3418399a:	d074      	beq.n	34183a86 <LTDC_SetConfig+0xb08>
        break;
3418399c:	e133      	b.n	34183c06 <LTDC_SetConfig+0xc88>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418399e:	68fa      	ldr	r2, [r7, #12]
341839a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341839a2:	2134      	movs	r1, #52	@ 0x34
341839a4:	fb01 f303 	mul.w	r3, r1, r3
341839a8:	4413      	add	r3, r2
341839aa:	333c      	adds	r3, #60	@ 0x3c
341839ac:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
341839ae:	68f9      	ldr	r1, [r7, #12]
341839b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341839b2:	2034      	movs	r0, #52	@ 0x34
341839b4:	fb00 f303 	mul.w	r3, r0, r3
341839b8:	440b      	add	r3, r1
341839ba:	3338      	adds	r3, #56	@ 0x38
341839bc:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
341839be:	1ad3      	subs	r3, r2, r3
341839c0:	697a      	ldr	r2, [r7, #20]
341839c2:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
341839c6:	68f9      	ldr	r1, [r7, #12]
341839c8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
341839ca:	2034      	movs	r0, #52	@ 0x34
341839cc:	fb00 f202 	mul.w	r2, r0, r2
341839d0:	440a      	add	r2, r1
341839d2:	3244      	adds	r2, #68	@ 0x44
341839d4:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
341839d6:	68f8      	ldr	r0, [r7, #12]
341839d8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
341839da:	2434      	movs	r4, #52	@ 0x34
341839dc:	fb04 f202 	mul.w	r2, r4, r2
341839e0:	4402      	add	r2, r0
341839e2:	3240      	adds	r2, #64	@ 0x40
341839e4:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
341839e6:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
341839e8:	0852      	lsrs	r2, r2, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
341839ea:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
341839ee:	68bb      	ldr	r3, [r7, #8]
341839f0:	4413      	add	r3, r2
341839f2:	68fa      	ldr	r2, [r7, #12]
341839f4:	6812      	ldr	r2, [r2, #0]
341839f6:	4611      	mov	r1, r2
341839f8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
341839fa:	0212      	lsls	r2, r2, #8
341839fc:	440a      	add	r2, r1
341839fe:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34183a02:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34183a04:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34183a06:	68fa      	ldr	r2, [r7, #12]
34183a08:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183a0a:	2134      	movs	r1, #52	@ 0x34
34183a0c:	fb01 f303 	mul.w	r3, r1, r3
34183a10:	4413      	add	r3, r2
34183a12:	3360      	adds	r3, #96	@ 0x60
34183a14:	681b      	ldr	r3, [r3, #0]
34183a16:	697a      	ldr	r2, [r7, #20]
34183a18:	fb02 f303 	mul.w	r3, r2, r3
34183a1c:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
34183a20:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183a22:	68f9      	ldr	r1, [r7, #12]
34183a24:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183a26:	2034      	movs	r0, #52	@ 0x34
34183a28:	fb00 f303 	mul.w	r3, r0, r3
34183a2c:	440b      	add	r3, r1
34183a2e:	333c      	adds	r3, #60	@ 0x3c
34183a30:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U);
34183a32:	68f8      	ldr	r0, [r7, #12]
34183a34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183a36:	2434      	movs	r4, #52	@ 0x34
34183a38:	fb04 f303 	mul.w	r3, r4, r3
34183a3c:	4403      	add	r3, r0
34183a3e:	3338      	adds	r3, #56	@ 0x38
34183a40:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183a42:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U);
34183a44:	6979      	ldr	r1, [r7, #20]
34183a46:	fb01 f303 	mul.w	r3, r1, r3
34183a4a:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34183a4c:	68f9      	ldr	r1, [r7, #12]
34183a4e:	6809      	ldr	r1, [r1, #0]
34183a50:	4608      	mov	r0, r1
34183a52:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34183a54:	0209      	lsls	r1, r1, #8
34183a56:	4401      	add	r1, r0
34183a58:	f501 7180 	add.w	r1, r1, #256	@ 0x100
34183a5c:	4313      	orrs	r3, r2
34183a5e:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34183a60:	68fa      	ldr	r2, [r7, #12]
34183a62:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183a64:	2134      	movs	r1, #52	@ 0x34
34183a66:	fb01 f303 	mul.w	r3, r1, r3
34183a6a:	4413      	add	r3, r2
34183a6c:	3364      	adds	r3, #100	@ 0x64
34183a6e:	681b      	ldr	r3, [r3, #0]
34183a70:	68fa      	ldr	r2, [r7, #12]
34183a72:	6812      	ldr	r2, [r2, #0]
34183a74:	4611      	mov	r1, r2
34183a76:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183a78:	0212      	lsls	r2, r2, #8
34183a7a:	440a      	add	r2, r1
34183a7c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34183a80:	085b      	lsrs	r3, r3, #1
34183a82:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
34183a84:	e0bf      	b.n	34183c06 <LTDC_SetConfig+0xc88>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183a86:	68fa      	ldr	r2, [r7, #12]
34183a88:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183a8a:	2134      	movs	r1, #52	@ 0x34
34183a8c:	fb01 f303 	mul.w	r3, r1, r3
34183a90:	4413      	add	r3, r2
34183a92:	333c      	adds	r3, #60	@ 0x3c
34183a94:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34183a96:	68f9      	ldr	r1, [r7, #12]
34183a98:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183a9a:	2034      	movs	r0, #52	@ 0x34
34183a9c:	fb00 f303 	mul.w	r3, r0, r3
34183aa0:	440b      	add	r3, r1
34183aa2:	3338      	adds	r3, #56	@ 0x38
34183aa4:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183aa6:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34183aa8:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183aaa:	697a      	ldr	r2, [r7, #20]
34183aac:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34183ab0:	68f9      	ldr	r1, [r7, #12]
34183ab2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183ab4:	2034      	movs	r0, #52	@ 0x34
34183ab6:	fb00 f202 	mul.w	r2, r0, r2
34183aba:	440a      	add	r2, r1
34183abc:	3244      	adds	r2, #68	@ 0x44
34183abe:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34183ac0:	68f8      	ldr	r0, [r7, #12]
34183ac2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183ac4:	2434      	movs	r4, #52	@ 0x34
34183ac6:	fb04 f202 	mul.w	r2, r4, r2
34183aca:	4402      	add	r2, r0
34183acc:	3240      	adds	r2, #64	@ 0x40
34183ace:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34183ad0:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34183ad2:	0852      	lsrs	r2, r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34183ad4:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34183ad8:	68bb      	ldr	r3, [r7, #8]
34183ada:	4413      	add	r3, r2
34183adc:	68fa      	ldr	r2, [r7, #12]
34183ade:	6812      	ldr	r2, [r2, #0]
34183ae0:	4611      	mov	r1, r2
34183ae2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183ae4:	0212      	lsls	r2, r2, #8
34183ae6:	440a      	add	r2, r1
34183ae8:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34183aec:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34183aee:	6413      	str	r3, [r2, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183af0:	68fa      	ldr	r2, [r7, #12]
34183af2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183af4:	2134      	movs	r1, #52	@ 0x34
34183af6:	fb01 f303 	mul.w	r3, r1, r3
34183afa:	4413      	add	r3, r2
34183afc:	333c      	adds	r3, #60	@ 0x3c
34183afe:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34183b00:	68f9      	ldr	r1, [r7, #12]
34183b02:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183b04:	2034      	movs	r0, #52	@ 0x34
34183b06:	fb00 f303 	mul.w	r3, r0, r3
34183b0a:	440b      	add	r3, r1
34183b0c:	3338      	adds	r3, #56	@ 0x38
34183b0e:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183b10:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34183b12:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183b14:	697a      	ldr	r2, [r7, #20]
34183b16:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34183b1a:	68f9      	ldr	r1, [r7, #12]
34183b1c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183b1e:	2034      	movs	r0, #52	@ 0x34
34183b20:	fb00 f202 	mul.w	r2, r0, r2
34183b24:	440a      	add	r2, r1
34183b26:	3244      	adds	r2, #68	@ 0x44
34183b28:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34183b2a:	68f8      	ldr	r0, [r7, #12]
34183b2c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183b2e:	2434      	movs	r4, #52	@ 0x34
34183b30:	fb04 f202 	mul.w	r2, r4, r2
34183b34:	4402      	add	r2, r0
34183b36:	3240      	adds	r2, #64	@ 0x40
34183b38:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34183b3a:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34183b3c:	0852      	lsrs	r2, r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34183b3e:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34183b42:	687b      	ldr	r3, [r7, #4]
34183b44:	4413      	add	r3, r2
34183b46:	68fa      	ldr	r2, [r7, #12]
34183b48:	6812      	ldr	r2, [r2, #0]
34183b4a:	4611      	mov	r1, r2
34183b4c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183b4e:	0212      	lsls	r2, r2, #8
34183b50:	440a      	add	r2, r1
34183b52:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34183b56:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34183b58:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34183b5a:	68fa      	ldr	r2, [r7, #12]
34183b5c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183b5e:	2134      	movs	r1, #52	@ 0x34
34183b60:	fb01 f303 	mul.w	r3, r1, r3
34183b64:	4413      	add	r3, r2
34183b66:	3360      	adds	r3, #96	@ 0x60
34183b68:	681b      	ldr	r3, [r3, #0]
34183b6a:	085b      	lsrs	r3, r3, #1
34183b6c:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
34183b70:	697a      	ldr	r2, [r7, #20]
34183b72:	fb02 f303 	mul.w	r3, r2, r3
                                              << 16U) |
34183b76:	041a      	lsls	r2, r3, #16
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183b78:	68f9      	ldr	r1, [r7, #12]
34183b7a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183b7c:	2034      	movs	r0, #52	@ 0x34
34183b7e:	fb00 f303 	mul.w	r3, r0, r3
34183b82:	440b      	add	r3, r1
34183b84:	333c      	adds	r3, #60	@ 0x3c
34183b86:	6819      	ldr	r1, [r3, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34183b88:	68f8      	ldr	r0, [r7, #12]
34183b8a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183b8c:	2434      	movs	r4, #52	@ 0x34
34183b8e:	fb04 f303 	mul.w	r3, r4, r3
34183b92:	4403      	add	r3, r0
34183b94:	3338      	adds	r3, #56	@ 0x38
34183b96:	681b      	ldr	r3, [r3, #0]
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183b98:	1acb      	subs	r3, r1, r3
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34183b9a:	085b      	lsrs	r3, r3, #1
34183b9c:	6979      	ldr	r1, [r7, #20]
34183b9e:	fb01 f303 	mul.w	r3, r1, r3
34183ba2:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34183ba4:	68f9      	ldr	r1, [r7, #12]
34183ba6:	6809      	ldr	r1, [r1, #0]
34183ba8:	4608      	mov	r0, r1
34183baa:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34183bac:	0209      	lsls	r1, r1, #8
34183bae:	4401      	add	r1, r0
34183bb0:	f501 7180 	add.w	r1, r1, #256	@ 0x100
                                              << 16U) |
34183bb4:	4313      	orrs	r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34183bb6:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR &= ~(LTDC_L1AFBLNR_AFBLNBR);
34183bb8:	68fb      	ldr	r3, [r7, #12]
34183bba:	681b      	ldr	r3, [r3, #0]
34183bbc:	461a      	mov	r2, r3
34183bbe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183bc0:	021b      	lsls	r3, r3, #8
34183bc2:	4413      	add	r3, r2
34183bc4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183bc8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34183bca:	68fa      	ldr	r2, [r7, #12]
34183bcc:	6812      	ldr	r2, [r2, #0]
34183bce:	4611      	mov	r1, r2
34183bd0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183bd2:	0212      	lsls	r2, r2, #8
34183bd4:	440a      	add	r2, r1
34183bd6:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34183bda:	0c1b      	lsrs	r3, r3, #16
34183bdc:	041b      	lsls	r3, r3, #16
34183bde:	64d3      	str	r3, [r2, #76]	@ 0x4c
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34183be0:	68fa      	ldr	r2, [r7, #12]
34183be2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183be4:	2134      	movs	r1, #52	@ 0x34
34183be6:	fb01 f303 	mul.w	r3, r1, r3
34183bea:	4413      	add	r3, r2
34183bec:	3364      	adds	r3, #100	@ 0x64
34183bee:	681b      	ldr	r3, [r3, #0]
34183bf0:	68fa      	ldr	r2, [r7, #12]
34183bf2:	6812      	ldr	r2, [r2, #0]
34183bf4:	4611      	mov	r1, r2
34183bf6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183bf8:	0212      	lsls	r2, r2, #8
34183bfa:	440a      	add	r2, r1
34183bfc:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34183c00:	085b      	lsrs	r3, r3, #1
34183c02:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
34183c04:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
34183c06:	68fa      	ldr	r2, [r7, #12]
34183c08:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183c0a:	2134      	movs	r1, #52	@ 0x34
34183c0c:	fb01 f303 	mul.w	r3, r1, r3
34183c10:	4413      	add	r3, r2
34183c12:	3360      	adds	r3, #96	@ 0x60
34183c14:	681b      	ldr	r3, [r3, #0]
34183c16:	697a      	ldr	r2, [r7, #20]
34183c18:	fb02 f303 	mul.w	r3, r2, r3
34183c1c:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
34183c20:	041a      	lsls	r2, r3, #16
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183c22:	68f9      	ldr	r1, [r7, #12]
34183c24:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183c26:	2034      	movs	r0, #52	@ 0x34
34183c28:	fb00 f303 	mul.w	r3, r0, r3
34183c2c:	440b      	add	r3, r1
34183c2e:	333c      	adds	r3, #60	@ 0x3c
34183c30:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
34183c32:	68f8      	ldr	r0, [r7, #12]
34183c34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183c36:	2434      	movs	r4, #52	@ 0x34
34183c38:	fb04 f303 	mul.w	r3, r4, r3
34183c3c:	4403      	add	r3, r0
34183c3e:	3338      	adds	r3, #56	@ 0x38
34183c40:	681b      	ldr	r3, [r3, #0]
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34183c42:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
34183c44:	6979      	ldr	r1, [r7, #20]
34183c46:	fb01 f303 	mul.w	r3, r1, r3
34183c4a:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
34183c4c:	68f9      	ldr	r1, [r7, #12]
34183c4e:	6809      	ldr	r1, [r1, #0]
34183c50:	4608      	mov	r0, r1
34183c52:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34183c54:	0209      	lsls	r1, r1, #8
34183c56:	4401      	add	r1, r0
34183c58:	f501 7180 	add.w	r1, r1, #256	@ 0x100
34183c5c:	4313      	orrs	r3, r2
34183c5e:	638b      	str	r3, [r1, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
34183c60:	68fb      	ldr	r3, [r7, #12]
34183c62:	681b      	ldr	r3, [r3, #0]
34183c64:	461a      	mov	r2, r3
34183c66:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183c68:	021b      	lsls	r3, r3, #8
34183c6a:	4413      	add	r3, r2
34183c6c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183c70:	68db      	ldr	r3, [r3, #12]
34183c72:	68fa      	ldr	r2, [r7, #12]
34183c74:	6812      	ldr	r2, [r2, #0]
34183c76:	4611      	mov	r1, r2
34183c78:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183c7a:	0212      	lsls	r2, r2, #8
34183c7c:	440a      	add	r2, r1
34183c7e:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34183c82:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34183c86:	f043 0301 	orr.w	r3, r3, #1
34183c8a:	60d3      	str	r3, [r2, #12]
}
34183c8c:	bf00      	nop
34183c8e:	371c      	adds	r7, #28
34183c90:	46bd      	mov	sp, r7
34183c92:	bcb0      	pop	{r4, r5, r7}
34183c94:	4770      	bx	lr
	...

34183c98 <LTDC_SetCompositionConfig>:
  *                 - Other layer indices as defined by the hardware and used within the driver.
  *
  * @note This function is intended for internal use within the LTDC driver and does not return a value.
 */
static void LTDC_SetCompositionConfig(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
34183c98:	b480      	push	{r7}
34183c9a:	b087      	sub	sp, #28
34183c9c:	af00      	add	r7, sp, #0
34183c9e:	6078      	str	r0, [r7, #4]
34183ca0:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the default color values */
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
34183ca2:	687a      	ldr	r2, [r7, #4]
34183ca4:	683b      	ldr	r3, [r7, #0]
34183ca6:	2134      	movs	r1, #52	@ 0x34
34183ca8:	fb01 f303 	mul.w	r3, r1, r3
34183cac:	4413      	add	r3, r2
34183cae:	3369      	adds	r3, #105	@ 0x69
34183cb0:	781b      	ldrb	r3, [r3, #0]
34183cb2:	021b      	lsls	r3, r3, #8
34183cb4:	617b      	str	r3, [r7, #20]
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
34183cb6:	687a      	ldr	r2, [r7, #4]
34183cb8:	683b      	ldr	r3, [r7, #0]
34183cba:	2134      	movs	r1, #52	@ 0x34
34183cbc:	fb01 f303 	mul.w	r3, r1, r3
34183cc0:	4413      	add	r3, r2
34183cc2:	336a      	adds	r3, #106	@ 0x6a
34183cc4:	781b      	ldrb	r3, [r3, #0]
34183cc6:	041b      	lsls	r3, r3, #16
34183cc8:	613b      	str	r3, [r7, #16]
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
34183cca:	687a      	ldr	r2, [r7, #4]
34183ccc:	683b      	ldr	r3, [r7, #0]
34183cce:	2134      	movs	r1, #52	@ 0x34
34183cd0:	fb01 f303 	mul.w	r3, r1, r3
34183cd4:	4413      	add	r3, r2
34183cd6:	3350      	adds	r3, #80	@ 0x50
34183cd8:	681b      	ldr	r3, [r3, #0]
34183cda:	061b      	lsls	r3, r3, #24
34183cdc:	60fb      	str	r3, [r7, #12]
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34183cde:	687a      	ldr	r2, [r7, #4]
34183ce0:	683b      	ldr	r3, [r7, #0]
34183ce2:	2134      	movs	r1, #52	@ 0x34
34183ce4:	fb01 f303 	mul.w	r3, r1, r3
34183ce8:	4413      	add	r3, r2
34183cea:	3368      	adds	r3, #104	@ 0x68
34183cec:	781b      	ldrb	r3, [r3, #0]
34183cee:	461a      	mov	r2, r3
34183cf0:	697b      	ldr	r3, [r7, #20]
34183cf2:	431a      	orrs	r2, r3
34183cf4:	693b      	ldr	r3, [r7, #16]
34183cf6:	431a      	orrs	r2, r3
34183cf8:	687b      	ldr	r3, [r7, #4]
34183cfa:	681b      	ldr	r3, [r3, #0]
34183cfc:	4619      	mov	r1, r3
34183cfe:	683b      	ldr	r3, [r7, #0]
34183d00:	021b      	lsls	r3, r3, #8
34183d02:	440b      	add	r3, r1
34183d04:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183d08:	4619      	mov	r1, r3
34183d0a:	68fb      	ldr	r3, [r7, #12]
34183d0c:	4313      	orrs	r3, r2
34183d0e:	624b      	str	r3, [r1, #36]	@ 0x24

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
34183d10:	687b      	ldr	r3, [r7, #4]
34183d12:	681b      	ldr	r3, [r3, #0]
34183d14:	461a      	mov	r2, r3
34183d16:	683b      	ldr	r3, [r7, #0]
34183d18:	021b      	lsls	r3, r3, #8
34183d1a:	4413      	add	r3, r2
34183d1c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183d20:	6a1b      	ldr	r3, [r3, #32]
34183d22:	687a      	ldr	r2, [r7, #4]
34183d24:	6812      	ldr	r2, [r2, #0]
34183d26:	4611      	mov	r1, r2
34183d28:	683a      	ldr	r2, [r7, #0]
34183d2a:	0212      	lsls	r2, r2, #8
34183d2c:	440a      	add	r2, r1
34183d2e:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34183d32:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
34183d36:	6213      	str	r3, [r2, #32]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (hltdc->LayerCfg[LayerIdx].Alpha);
34183d38:	687b      	ldr	r3, [r7, #4]
34183d3a:	681b      	ldr	r3, [r3, #0]
34183d3c:	461a      	mov	r2, r3
34183d3e:	683b      	ldr	r3, [r7, #0]
34183d40:	021b      	lsls	r3, r3, #8
34183d42:	4413      	add	r3, r2
34183d44:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183d48:	4618      	mov	r0, r3
34183d4a:	687a      	ldr	r2, [r7, #4]
34183d4c:	683b      	ldr	r3, [r7, #0]
34183d4e:	2134      	movs	r1, #52	@ 0x34
34183d50:	fb01 f303 	mul.w	r3, r1, r3
34183d54:	4413      	add	r3, r2
34183d56:	334c      	adds	r3, #76	@ 0x4c
34183d58:	681b      	ldr	r3, [r3, #0]
34183d5a:	6203      	str	r3, [r0, #32]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BOR | LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
34183d5c:	687b      	ldr	r3, [r7, #4]
34183d5e:	681b      	ldr	r3, [r3, #0]
34183d60:	461a      	mov	r2, r3
34183d62:	683b      	ldr	r3, [r7, #0]
34183d64:	021b      	lsls	r3, r3, #8
34183d66:	4413      	add	r3, r2
34183d68:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183d6c:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34183d6e:	687b      	ldr	r3, [r7, #4]
34183d70:	681b      	ldr	r3, [r3, #0]
34183d72:	4619      	mov	r1, r3
34183d74:	683b      	ldr	r3, [r7, #0]
34183d76:	021b      	lsls	r3, r3, #8
34183d78:	440b      	add	r3, r1
34183d7a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183d7e:	4619      	mov	r1, r3
34183d80:	4b18      	ldr	r3, [pc, #96]	@ (34183de4 <LTDC_SetCompositionConfig+0x14c>)
34183d82:	4013      	ands	r3, r2
34183d84:	628b      	str	r3, [r1, #40]	@ 0x28
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
34183d86:	687b      	ldr	r3, [r7, #4]
34183d88:	681b      	ldr	r3, [r3, #0]
34183d8a:	461a      	mov	r2, r3
34183d8c:	683b      	ldr	r3, [r7, #0]
34183d8e:	021b      	lsls	r3, r3, #8
34183d90:	4413      	add	r3, r2
34183d92:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183d96:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34183d98:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34183d9c:	617b      	str	r3, [r7, #20]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
34183d9e:	687a      	ldr	r2, [r7, #4]
34183da0:	683b      	ldr	r3, [r7, #0]
34183da2:	2134      	movs	r1, #52	@ 0x34
34183da4:	fb01 f303 	mul.w	r3, r1, r3
34183da8:	4413      	add	r3, r2
34183daa:	3354      	adds	r3, #84	@ 0x54
34183dac:	681a      	ldr	r2, [r3, #0]
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
34183dae:	6879      	ldr	r1, [r7, #4]
34183db0:	683b      	ldr	r3, [r7, #0]
34183db2:	2034      	movs	r0, #52	@ 0x34
34183db4:	fb00 f303 	mul.w	r3, r0, r3
34183db8:	440b      	add	r3, r1
34183dba:	3358      	adds	r3, #88	@ 0x58
34183dbc:	681b      	ldr	r3, [r3, #0]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
34183dbe:	431a      	orrs	r2, r3
34183dc0:	687b      	ldr	r3, [r7, #4]
34183dc2:	681b      	ldr	r3, [r3, #0]
34183dc4:	4619      	mov	r1, r3
34183dc6:	683b      	ldr	r3, [r7, #0]
34183dc8:	021b      	lsls	r3, r3, #8
34183dca:	440b      	add	r3, r1
34183dcc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183dd0:	4619      	mov	r1, r3
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
34183dd2:	697b      	ldr	r3, [r7, #20]
34183dd4:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
34183dd6:	628b      	str	r3, [r1, #40]	@ 0x28
}
34183dd8:	bf00      	nop
34183dda:	371c      	adds	r7, #28
34183ddc:	46bd      	mov	sp, r7
34183dde:	f85d 7b04 	ldr.w	r7, [sp], #4
34183de2:	4770      	bx	lr
34183de4:	fffef8f8 	.word	0xfffef8f8

34183de8 <LTDC_SetPredefFormat>:
  *
  *  @note This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetPredefFormat(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
34183de8:	b480      	push	{r7}
34183dea:	b08d      	sub	sp, #52	@ 0x34
34183dec:	af00      	add	r7, sp, #0
34183dee:	6078      	str	r0, [r7, #4]
34183df0:	6039      	str	r1, [r7, #0]
  uint32_t PSIZE = 0U;
34183df2:	2300      	movs	r3, #0
34183df4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t ALEN = 0U;
34183df6:	2300      	movs	r3, #0
34183df8:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t APOS = 0U;
34183dfa:	2300      	movs	r3, #0
34183dfc:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t RLEN = 0U;
34183dfe:	2300      	movs	r3, #0
34183e00:	623b      	str	r3, [r7, #32]
  uint32_t RPOS = 0U;
34183e02:	2300      	movs	r3, #0
34183e04:	61fb      	str	r3, [r7, #28]
  uint32_t BLEN = 0U;
34183e06:	2300      	movs	r3, #0
34183e08:	61bb      	str	r3, [r7, #24]
  uint32_t BPOS = 0U;
34183e0a:	2300      	movs	r3, #0
34183e0c:	617b      	str	r3, [r7, #20]
  uint32_t GLEN = 0U;
34183e0e:	2300      	movs	r3, #0
34183e10:	613b      	str	r3, [r7, #16]
  uint32_t GPOS = 0U;
34183e12:	2300      	movs	r3, #0
34183e14:	60fb      	str	r3, [r7, #12]

  /* Specify Flex ARGB parameters according to pixel format */
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34183e16:	687a      	ldr	r2, [r7, #4]
34183e18:	683b      	ldr	r3, [r7, #0]
34183e1a:	2134      	movs	r1, #52	@ 0x34
34183e1c:	fb01 f303 	mul.w	r3, r1, r3
34183e20:	4413      	add	r3, r2
34183e22:	3348      	adds	r3, #72	@ 0x48
34183e24:	681b      	ldr	r3, [r3, #0]
34183e26:	3b07      	subs	r3, #7
34183e28:	2b04      	cmp	r3, #4
34183e2a:	d86c      	bhi.n	34183f06 <LTDC_SetPredefFormat+0x11e>
34183e2c:	a201      	add	r2, pc, #4	@ (adr r2, 34183e34 <LTDC_SetPredefFormat+0x4c>)
34183e2e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34183e32:	bf00      	nop
34183e34:	34183e49 	.word	0x34183e49
34183e38:	34183e6f 	.word	0x34183e6f
34183e3c:	34183e95 	.word	0x34183e95
34183e40:	34183ebb 	.word	0x34183ebb
34183e44:	34183ee1 	.word	0x34183ee1
  {
    case LTDC_PIXEL_FORMAT_ARGB1555:
      PSIZE = 2U;
34183e48:	2302      	movs	r3, #2
34183e4a:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 1U;
34183e4c:	2301      	movs	r3, #1
34183e4e:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 15U;
34183e50:	230f      	movs	r3, #15
34183e52:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 5U;
34183e54:	2305      	movs	r3, #5
34183e56:	623b      	str	r3, [r7, #32]
      RPOS = 10U;
34183e58:	230a      	movs	r3, #10
34183e5a:	61fb      	str	r3, [r7, #28]
      GLEN = 5U;
34183e5c:	2305      	movs	r3, #5
34183e5e:	613b      	str	r3, [r7, #16]
      GPOS = 5U;
34183e60:	2305      	movs	r3, #5
34183e62:	60fb      	str	r3, [r7, #12]
      BLEN = 5U;
34183e64:	2305      	movs	r3, #5
34183e66:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
34183e68:	2300      	movs	r3, #0
34183e6a:	617b      	str	r3, [r7, #20]
      break;
34183e6c:	e04c      	b.n	34183f08 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_ARGB4444:
      PSIZE = 2U;
34183e6e:	2302      	movs	r3, #2
34183e70:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 4U;
34183e72:	2304      	movs	r3, #4
34183e74:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 12U;
34183e76:	230c      	movs	r3, #12
34183e78:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 4U;
34183e7a:	2304      	movs	r3, #4
34183e7c:	623b      	str	r3, [r7, #32]
      RPOS = 8U;
34183e7e:	2308      	movs	r3, #8
34183e80:	61fb      	str	r3, [r7, #28]
      GLEN = 4U;
34183e82:	2304      	movs	r3, #4
34183e84:	613b      	str	r3, [r7, #16]
      GPOS = 4U;
34183e86:	2304      	movs	r3, #4
34183e88:	60fb      	str	r3, [r7, #12]
      BLEN = 4U;
34183e8a:	2304      	movs	r3, #4
34183e8c:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
34183e8e:	2300      	movs	r3, #0
34183e90:	617b      	str	r3, [r7, #20]
      break;
34183e92:	e039      	b.n	34183f08 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_L8:
      PSIZE = 1U;
34183e94:	2301      	movs	r3, #1
34183e96:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 0U;
34183e98:	2300      	movs	r3, #0
34183e9a:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 0U;
34183e9c:	2300      	movs	r3, #0
34183e9e:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 8U;
34183ea0:	2308      	movs	r3, #8
34183ea2:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
34183ea4:	2300      	movs	r3, #0
34183ea6:	61fb      	str	r3, [r7, #28]
      GLEN = 8U;
34183ea8:	2308      	movs	r3, #8
34183eaa:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
34183eac:	2300      	movs	r3, #0
34183eae:	60fb      	str	r3, [r7, #12]
      BLEN = 8U;
34183eb0:	2308      	movs	r3, #8
34183eb2:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
34183eb4:	2300      	movs	r3, #0
34183eb6:	617b      	str	r3, [r7, #20]
      break;
34183eb8:	e026      	b.n	34183f08 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_AL44:
      PSIZE = 1U;
34183eba:	2301      	movs	r3, #1
34183ebc:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 4U;
34183ebe:	2304      	movs	r3, #4
34183ec0:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 4U;
34183ec2:	2304      	movs	r3, #4
34183ec4:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 4U;
34183ec6:	2304      	movs	r3, #4
34183ec8:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
34183eca:	2300      	movs	r3, #0
34183ecc:	61fb      	str	r3, [r7, #28]
      GLEN = 4U;
34183ece:	2304      	movs	r3, #4
34183ed0:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
34183ed2:	2300      	movs	r3, #0
34183ed4:	60fb      	str	r3, [r7, #12]
      BLEN = 4U;
34183ed6:	2304      	movs	r3, #4
34183ed8:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
34183eda:	2300      	movs	r3, #0
34183edc:	617b      	str	r3, [r7, #20]
      break;
34183ede:	e013      	b.n	34183f08 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_AL88:
      PSIZE = 2U;
34183ee0:	2302      	movs	r3, #2
34183ee2:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 8U;
34183ee4:	2308      	movs	r3, #8
34183ee6:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 8U;
34183ee8:	2308      	movs	r3, #8
34183eea:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 8U;
34183eec:	2308      	movs	r3, #8
34183eee:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
34183ef0:	2300      	movs	r3, #0
34183ef2:	61fb      	str	r3, [r7, #28]
      GLEN = 8U;
34183ef4:	2308      	movs	r3, #8
34183ef6:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
34183ef8:	2300      	movs	r3, #0
34183efa:	60fb      	str	r3, [r7, #12]
      BLEN = 8U;
34183efc:	2308      	movs	r3, #8
34183efe:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
34183f00:	2300      	movs	r3, #0
34183f02:	617b      	str	r3, [r7, #20]
      break;
34183f04:	e000      	b.n	34183f08 <LTDC_SetPredefFormat+0x120>
    default:
      break;
34183f06:	bf00      	nop
  }

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34183f08:	687a      	ldr	r2, [r7, #4]
34183f0a:	683b      	ldr	r3, [r7, #0]
34183f0c:	2134      	movs	r1, #52	@ 0x34
34183f0e:	fb01 f303 	mul.w	r3, r1, r3
34183f12:	4413      	add	r3, r2
34183f14:	3348      	adds	r3, #72	@ 0x48
34183f16:	681b      	ldr	r3, [r3, #0]
34183f18:	2b06      	cmp	r3, #6
34183f1a:	d903      	bls.n	34183f24 <LTDC_SetPredefFormat+0x13c>
34183f1c:	3b07      	subs	r3, #7
34183f1e:	2b04      	cmp	r3, #4
34183f20:	d860      	bhi.n	34183fe4 <LTDC_SetPredefFormat+0x1fc>
34183f22:	e028      	b.n	34183f76 <LTDC_SetPredefFormat+0x18e>
    case LTDC_PIXEL_FORMAT_RGBA8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_RGB565:
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_RGB888:
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
34183f24:	687b      	ldr	r3, [r7, #4]
34183f26:	681b      	ldr	r3, [r3, #0]
34183f28:	461a      	mov	r2, r3
34183f2a:	683b      	ldr	r3, [r7, #0]
34183f2c:	021b      	lsls	r3, r3, #8
34183f2e:	4413      	add	r3, r2
34183f30:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183f34:	4618      	mov	r0, r3
34183f36:	687a      	ldr	r2, [r7, #4]
34183f38:	683b      	ldr	r3, [r7, #0]
34183f3a:	2134      	movs	r1, #52	@ 0x34
34183f3c:	fb01 f303 	mul.w	r3, r1, r3
34183f40:	4413      	add	r3, r2
34183f42:	3348      	adds	r3, #72	@ 0x48
34183f44:	681b      	ldr	r3, [r3, #0]
34183f46:	61c3      	str	r3, [r0, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
34183f48:	687b      	ldr	r3, [r7, #4]
34183f4a:	681b      	ldr	r3, [r3, #0]
34183f4c:	461a      	mov	r2, r3
34183f4e:	683b      	ldr	r3, [r7, #0]
34183f50:	021b      	lsls	r3, r3, #8
34183f52:	4413      	add	r3, r2
34183f54:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183f58:	461a      	mov	r2, r3
34183f5a:	2300      	movs	r3, #0
34183f5c:	6753      	str	r3, [r2, #116]	@ 0x74
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = 0U;
34183f5e:	687b      	ldr	r3, [r7, #4]
34183f60:	681b      	ldr	r3, [r3, #0]
34183f62:	461a      	mov	r2, r3
34183f64:	683b      	ldr	r3, [r7, #0]
34183f66:	021b      	lsls	r3, r3, #8
34183f68:	4413      	add	r3, r2
34183f6a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183f6e:	461a      	mov	r2, r3
34183f70:	2300      	movs	r3, #0
34183f72:	6793      	str	r3, [r2, #120]	@ 0x78
      break;
34183f74:	e037      	b.n	34183fe6 <LTDC_SetPredefFormat+0x1fe>
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_AL88:
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
34183f76:	687b      	ldr	r3, [r7, #4]
34183f78:	681b      	ldr	r3, [r3, #0]
34183f7a:	461a      	mov	r2, r3
34183f7c:	683b      	ldr	r3, [r7, #0]
34183f7e:	021b      	lsls	r3, r3, #8
34183f80:	4413      	add	r3, r2
34183f82:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183f86:	461a      	mov	r2, r3
34183f88:	2307      	movs	r3, #7
34183f8a:	61d3      	str	r3, [r2, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
34183f8c:	6a3b      	ldr	r3, [r7, #32]
34183f8e:	039a      	lsls	r2, r3, #14
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
34183f90:	69fb      	ldr	r3, [r7, #28]
34183f92:	025b      	lsls	r3, r3, #9
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
34183f94:	441a      	add	r2, r3
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
34183f96:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183f98:	015b      	lsls	r3, r3, #5
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
34183f9a:	441a      	add	r2, r3
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
34183f9c:	687b      	ldr	r3, [r7, #4]
34183f9e:	681b      	ldr	r3, [r3, #0]
34183fa0:	4619      	mov	r1, r3
34183fa2:	683b      	ldr	r3, [r7, #0]
34183fa4:	021b      	lsls	r3, r3, #8
34183fa6:	440b      	add	r3, r1
34183fa8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183fac:	4619      	mov	r1, r3
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
34183fae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34183fb0:	4413      	add	r3, r2
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
34183fb2:	674b      	str	r3, [r1, #116]	@ 0x74
                                           APOS;
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
34183fb4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34183fb6:	049a      	lsls	r2, r3, #18
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
34183fb8:	69bb      	ldr	r3, [r7, #24]
34183fba:	039b      	lsls	r3, r3, #14
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
34183fbc:	441a      	add	r2, r3
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
34183fbe:	697b      	ldr	r3, [r7, #20]
34183fc0:	025b      	lsls	r3, r3, #9
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
34183fc2:	441a      	add	r2, r3
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
34183fc4:	693b      	ldr	r3, [r7, #16]
34183fc6:	015b      	lsls	r3, r3, #5
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
34183fc8:	441a      	add	r2, r3
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
34183fca:	687b      	ldr	r3, [r7, #4]
34183fcc:	681b      	ldr	r3, [r3, #0]
34183fce:	4619      	mov	r1, r3
34183fd0:	683b      	ldr	r3, [r7, #0]
34183fd2:	021b      	lsls	r3, r3, #8
34183fd4:	440b      	add	r3, r1
34183fd6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34183fda:	4619      	mov	r1, r3
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
34183fdc:	68fb      	ldr	r3, [r7, #12]
34183fde:	4413      	add	r3, r2
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
34183fe0:	678b      	str	r3, [r1, #120]	@ 0x78
                                           GPOS;
      break;
34183fe2:	e000      	b.n	34183fe6 <LTDC_SetPredefFormat+0x1fe>
    default:
      break;
34183fe4:	bf00      	nop
  }
}
34183fe6:	bf00      	nop
34183fe8:	3734      	adds	r7, #52	@ 0x34
34183fea:	46bd      	mov	sp, r7
34183fec:	f85d 7b04 	ldr.w	r7, [sp], #4
34183ff0:	4770      	bx	lr
34183ff2:	bf00      	nop

34183ff4 <HAL_PWREx_ConfigSupply>:
  * @note: The power supply configuration is not reset by wakeup from Standby mode and
  *        application reset, but only reset by VDD POR.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply(uint32_t SupplySource)
{
34183ff4:	b580      	push	{r7, lr}
34183ff6:	b084      	sub	sp, #16
34183ff8:	af00      	add	r7, sp, #0
34183ffa:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_PWR_SUPPLY(SupplySource));

  /* Set the power supply configuration */
  MODIFY_REG(PWR->CR1, PWR_SUPPLY_CONFIG_MASK, SupplySource);
34183ffc:	4b10      	ldr	r3, [pc, #64]	@ (34184040 <HAL_PWREx_ConfigSupply+0x4c>)
34183ffe:	681b      	ldr	r3, [r3, #0]
34184000:	f023 0204 	bic.w	r2, r3, #4
34184004:	490e      	ldr	r1, [pc, #56]	@ (34184040 <HAL_PWREx_ConfigSupply+0x4c>)
34184006:	687b      	ldr	r3, [r7, #4]
34184008:	4313      	orrs	r3, r2
3418400a:	600b      	str	r3, [r1, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
3418400c:	f7fe f90e 	bl	3418222c <HAL_GetTick>
34184010:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
34184012:	e009      	b.n	34184028 <HAL_PWREx_ConfigSupply+0x34>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
34184014:	f7fe f90a 	bl	3418222c <HAL_GetTick>
34184018:	4602      	mov	r2, r0
3418401a:	68fb      	ldr	r3, [r7, #12]
3418401c:	1ad3      	subs	r3, r2, r3
3418401e:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
34184022:	d901      	bls.n	34184028 <HAL_PWREx_ConfigSupply+0x34>
    {
      return HAL_ERROR;
34184024:	2301      	movs	r3, #1
34184026:	e006      	b.n	34184036 <HAL_PWREx_ConfigSupply+0x42>
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
34184028:	4b05      	ldr	r3, [pc, #20]	@ (34184040 <HAL_PWREx_ConfigSupply+0x4c>)
3418402a:	6a1b      	ldr	r3, [r3, #32]
3418402c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34184030:	2b00      	cmp	r3, #0
34184032:	d0ef      	beq.n	34184014 <HAL_PWREx_ConfigSupply+0x20>
    }
  }

  return HAL_OK;
34184034:	2300      	movs	r3, #0
}
34184036:	4618      	mov	r0, r3
34184038:	3710      	adds	r7, #16
3418403a:	46bd      	mov	sp, r7
3418403c:	bd80      	pop	{r7, pc}
3418403e:	bf00      	nop
34184040:	56024800 	.word	0x56024800

34184044 <HAL_PWREx_EnableVddIO2>:
  * @brief  Enable VDDIO2 supply valid.
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
34184044:	b480      	push	{r7}
34184046:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
34184048:	4b05      	ldr	r3, [pc, #20]	@ (34184060 <HAL_PWREx_EnableVddIO2+0x1c>)
3418404a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418404c:	4a04      	ldr	r2, [pc, #16]	@ (34184060 <HAL_PWREx_EnableVddIO2+0x1c>)
3418404e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34184052:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34184054:	bf00      	nop
34184056:	46bd      	mov	sp, r7
34184058:	f85d 7b04 	ldr.w	r7, [sp], #4
3418405c:	4770      	bx	lr
3418405e:	bf00      	nop
34184060:	56024800 	.word	0x56024800

34184064 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll SR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
34184064:	b480      	push	{r7}
34184066:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34184068:	4b06      	ldr	r3, [pc, #24]	@ (34184084 <LL_RCC_HSE_IsReady+0x20>)
3418406a:	685b      	ldr	r3, [r3, #4]
3418406c:	f003 0310 	and.w	r3, r3, #16
34184070:	2b00      	cmp	r3, #0
34184072:	d001      	beq.n	34184078 <LL_RCC_HSE_IsReady+0x14>
34184074:	2301      	movs	r3, #1
34184076:	e000      	b.n	3418407a <LL_RCC_HSE_IsReady+0x16>
34184078:	2300      	movs	r3, #0
}
3418407a:	4618      	mov	r0, r3
3418407c:	46bd      	mov	sp, r7
3418407e:	f85d 7b04 	ldr.w	r7, [sp], #4
34184082:	4770      	bx	lr
34184084:	56028000 	.word	0x56028000

34184088 <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI oscillator
  * @rmtoll CSR          HSIONS        LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
34184088:	b480      	push	{r7}
3418408a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_HSIONS);
3418408c:	4b04      	ldr	r3, [pc, #16]	@ (341840a0 <LL_RCC_HSI_Enable+0x18>)
3418408e:	2208      	movs	r2, #8
34184090:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
34184094:	bf00      	nop
34184096:	46bd      	mov	sp, r7
34184098:	f85d 7b04 	ldr.w	r7, [sp], #4
3418409c:	4770      	bx	lr
3418409e:	bf00      	nop
341840a0:	56028000 	.word	0x56028000

341840a4 <LL_RCC_HSI_Disable>:
  * @brief  Disable HSI oscillator
  * @rmtoll CCR          HSIONC        LL_RCC_HSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Disable(void)
{
341840a4:	b480      	push	{r7}
341840a6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_HSIONC);
341840a8:	4b05      	ldr	r3, [pc, #20]	@ (341840c0 <LL_RCC_HSI_Disable+0x1c>)
341840aa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341840ae:	461a      	mov	r2, r3
341840b0:	2308      	movs	r3, #8
341840b2:	6013      	str	r3, [r2, #0]
}
341840b4:	bf00      	nop
341840b6:	46bd      	mov	sp, r7
341840b8:	f85d 7b04 	ldr.w	r7, [sp], #4
341840bc:	4770      	bx	lr
341840be:	bf00      	nop
341840c0:	56028000 	.word	0x56028000

341840c4 <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll SR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
341840c4:	b480      	push	{r7}
341840c6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
341840c8:	4b06      	ldr	r3, [pc, #24]	@ (341840e4 <LL_RCC_HSI_IsReady+0x20>)
341840ca:	685b      	ldr	r3, [r3, #4]
341840cc:	f003 0308 	and.w	r3, r3, #8
341840d0:	2b00      	cmp	r3, #0
341840d2:	d001      	beq.n	341840d8 <LL_RCC_HSI_IsReady+0x14>
341840d4:	2301      	movs	r3, #1
341840d6:	e000      	b.n	341840da <LL_RCC_HSI_IsReady+0x16>
341840d8:	2300      	movs	r3, #0
}
341840da:	4618      	mov	r0, r3
341840dc:	46bd      	mov	sp, r7
341840de:	f85d 7b04 	ldr.w	r7, [sp], #4
341840e2:	4770      	bx	lr
341840e4:	56028000 	.word	0x56028000

341840e8 <LL_RCC_HSI_SetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_HSI_SetDivider(uint32_t Divider)
{
341840e8:	b480      	push	{r7}
341840ea:	b083      	sub	sp, #12
341840ec:	af00      	add	r7, sp, #0
341840ee:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSIDIV, Divider);
341840f0:	4b06      	ldr	r3, [pc, #24]	@ (3418410c <LL_RCC_HSI_SetDivider+0x24>)
341840f2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341840f4:	f423 72c0 	bic.w	r2, r3, #384	@ 0x180
341840f8:	4904      	ldr	r1, [pc, #16]	@ (3418410c <LL_RCC_HSI_SetDivider+0x24>)
341840fa:	687b      	ldr	r3, [r7, #4]
341840fc:	4313      	orrs	r3, r2
341840fe:	648b      	str	r3, [r1, #72]	@ 0x48
}
34184100:	bf00      	nop
34184102:	370c      	adds	r7, #12
34184104:	46bd      	mov	sp, r7
34184106:	f85d 7b04 	ldr.w	r7, [sp], #4
3418410a:	4770      	bx	lr
3418410c:	56028000 	.word	0x56028000

34184110 <LL_RCC_HSI_GetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_2
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_GetDivider(void)
{
34184110:	b480      	push	{r7}
34184112:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34184114:	4b04      	ldr	r3, [pc, #16]	@ (34184128 <LL_RCC_HSI_GetDivider+0x18>)
34184116:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34184118:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
3418411c:	4618      	mov	r0, r3
3418411e:	46bd      	mov	sp, r7
34184120:	f85d 7b04 	ldr.w	r7, [sp], #4
34184124:	4770      	bx	lr
34184126:	bf00      	nop
34184128:	56028000 	.word	0x56028000

3418412c <LL_RCC_HSI_SetCalibTrimming>:
  * @rmtoll HSICFGR      HSITRIM       LL_RCC_HSI_SetCalibTrimming
  * @param  Value This parameter can be a value between 0 and 63
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_SetCalibTrimming(uint32_t Value)
{
3418412c:	b480      	push	{r7}
3418412e:	b083      	sub	sp, #12
34184130:	af00      	add	r7, sp, #0
34184132:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
34184134:	4b07      	ldr	r3, [pc, #28]	@ (34184154 <LL_RCC_HSI_SetCalibTrimming+0x28>)
34184136:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34184138:	f423 02fe 	bic.w	r2, r3, #8323072	@ 0x7f0000
3418413c:	687b      	ldr	r3, [r7, #4]
3418413e:	041b      	lsls	r3, r3, #16
34184140:	4904      	ldr	r1, [pc, #16]	@ (34184154 <LL_RCC_HSI_SetCalibTrimming+0x28>)
34184142:	4313      	orrs	r3, r2
34184144:	648b      	str	r3, [r1, #72]	@ 0x48
}
34184146:	bf00      	nop
34184148:	370c      	adds	r7, #12
3418414a:	46bd      	mov	sp, r7
3418414c:	f85d 7b04 	ldr.w	r7, [sp], #4
34184150:	4770      	bx	lr
34184152:	bf00      	nop
34184154:	56028000 	.word	0x56028000

34184158 <LL_RCC_MSI_Enable>:
  * @brief  Enable MSI oscillator
  * @rmtoll CSR          MSIONS        LL_RCC_MSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Enable(void)
{
34184158:	b480      	push	{r7}
3418415a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_MSIONS);
3418415c:	4b04      	ldr	r3, [pc, #16]	@ (34184170 <LL_RCC_MSI_Enable+0x18>)
3418415e:	2204      	movs	r2, #4
34184160:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
34184164:	bf00      	nop
34184166:	46bd      	mov	sp, r7
34184168:	f85d 7b04 	ldr.w	r7, [sp], #4
3418416c:	4770      	bx	lr
3418416e:	bf00      	nop
34184170:	56028000 	.word	0x56028000

34184174 <LL_RCC_MSI_Disable>:
  * @brief  Disable MSI oscillator
  * @rmtoll CCR          MSIONC        LL_RCC_MSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Disable(void)
{
34184174:	b480      	push	{r7}
34184176:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_MSIONC);
34184178:	4b05      	ldr	r3, [pc, #20]	@ (34184190 <LL_RCC_MSI_Disable+0x1c>)
3418417a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418417e:	461a      	mov	r2, r3
34184180:	2304      	movs	r3, #4
34184182:	6013      	str	r3, [r2, #0]
}
34184184:	bf00      	nop
34184186:	46bd      	mov	sp, r7
34184188:	f85d 7b04 	ldr.w	r7, [sp], #4
3418418c:	4770      	bx	lr
3418418e:	bf00      	nop
34184190:	56028000 	.word	0x56028000

34184194 <LL_RCC_MSI_IsReady>:
  * @brief  Check if MSI clock is ready
  * @rmtoll SR           MSIRDY        LL_RCC_MSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_IsReady(void)
{
34184194:	b480      	push	{r7}
34184196:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
34184198:	4b06      	ldr	r3, [pc, #24]	@ (341841b4 <LL_RCC_MSI_IsReady+0x20>)
3418419a:	685b      	ldr	r3, [r3, #4]
3418419c:	f003 0304 	and.w	r3, r3, #4
341841a0:	2b00      	cmp	r3, #0
341841a2:	d001      	beq.n	341841a8 <LL_RCC_MSI_IsReady+0x14>
341841a4:	2301      	movs	r3, #1
341841a6:	e000      	b.n	341841aa <LL_RCC_MSI_IsReady+0x16>
341841a8:	2300      	movs	r3, #0
}
341841aa:	4618      	mov	r0, r3
341841ac:	46bd      	mov	sp, r7
341841ae:	f85d 7b04 	ldr.w	r7, [sp], #4
341841b2:	4770      	bx	lr
341841b4:	56028000 	.word	0x56028000

341841b8 <LL_RCC_MSI_SetFrequency>:
  *         @arg @ref LL_RCC_MSI_FREQ_4MHZ
  *         @arg @ref LL_RCC_MSI_FREQ_16MHZ
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_MSI_SetFrequency(uint32_t Value)
{
341841b8:	b480      	push	{r7}
341841ba:	b083      	sub	sp, #12
341841bc:	af00      	add	r7, sp, #0
341841be:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL, Value);
341841c0:	4b06      	ldr	r3, [pc, #24]	@ (341841dc <LL_RCC_MSI_SetFrequency+0x24>)
341841c2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341841c4:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
341841c8:	4904      	ldr	r1, [pc, #16]	@ (341841dc <LL_RCC_MSI_SetFrequency+0x24>)
341841ca:	687b      	ldr	r3, [r7, #4]
341841cc:	4313      	orrs	r3, r2
341841ce:	644b      	str	r3, [r1, #68]	@ 0x44
}
341841d0:	bf00      	nop
341841d2:	370c      	adds	r7, #12
341841d4:	46bd      	mov	sp, r7
341841d6:	f85d 7b04 	ldr.w	r7, [sp], #4
341841da:	4770      	bx	lr
341841dc:	56028000 	.word	0x56028000

341841e0 <LL_RCC_MSI_GetFrequency>:
  * @retval can be one of the following values:
  *         @arg @ref LL_RCC_MSI_FREQ_4MHZ
  *         @arg @ref LL_RCC_MSI_FREQ_16MHZ
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_GetFrequency(void)
{
341841e0:	b480      	push	{r7}
341841e2:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
341841e4:	4b04      	ldr	r3, [pc, #16]	@ (341841f8 <LL_RCC_MSI_GetFrequency+0x18>)
341841e6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341841e8:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
341841ec:	4618      	mov	r0, r3
341841ee:	46bd      	mov	sp, r7
341841f0:	f85d 7b04 	ldr.w	r7, [sp], #4
341841f4:	4770      	bx	lr
341841f6:	bf00      	nop
341841f8:	56028000 	.word	0x56028000

341841fc <LL_RCC_MSI_SetCalibTrimming>:
  * @rmtoll MSICFGR      MSITRIM       LL_RCC_MSI_SetCalibTrimming
  * @param  Value can be a value between 0 and 31
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_SetCalibTrimming(uint32_t Value)
{
341841fc:	b480      	push	{r7}
341841fe:	b083      	sub	sp, #12
34184200:	af00      	add	r7, sp, #0
34184202:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSITRIM, Value << RCC_MSICFGR_MSITRIM_Pos);
34184204:	4b07      	ldr	r3, [pc, #28]	@ (34184224 <LL_RCC_MSI_SetCalibTrimming+0x28>)
34184206:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34184208:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
3418420c:	687b      	ldr	r3, [r7, #4]
3418420e:	041b      	lsls	r3, r3, #16
34184210:	4904      	ldr	r1, [pc, #16]	@ (34184224 <LL_RCC_MSI_SetCalibTrimming+0x28>)
34184212:	4313      	orrs	r3, r2
34184214:	644b      	str	r3, [r1, #68]	@ 0x44
}
34184216:	bf00      	nop
34184218:	370c      	adds	r7, #12
3418421a:	46bd      	mov	sp, r7
3418421c:	f85d 7b04 	ldr.w	r7, [sp], #4
34184220:	4770      	bx	lr
34184222:	bf00      	nop
34184224:	56028000 	.word	0x56028000

34184228 <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll SR           LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
34184228:	b480      	push	{r7}
3418422a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3418422c:	4b06      	ldr	r3, [pc, #24]	@ (34184248 <LL_RCC_LSE_IsReady+0x20>)
3418422e:	685b      	ldr	r3, [r3, #4]
34184230:	f003 0302 	and.w	r3, r3, #2
34184234:	2b00      	cmp	r3, #0
34184236:	d001      	beq.n	3418423c <LL_RCC_LSE_IsReady+0x14>
34184238:	2301      	movs	r3, #1
3418423a:	e000      	b.n	3418423e <LL_RCC_LSE_IsReady+0x16>
3418423c:	2300      	movs	r3, #0
}
3418423e:	4618      	mov	r0, r3
34184240:	46bd      	mov	sp, r7
34184242:	f85d 7b04 	ldr.w	r7, [sp], #4
34184246:	4770      	bx	lr
34184248:	56028000 	.word	0x56028000

3418424c <LL_RCC_LSI_Enable>:
  * @brief  Enable LSI Oscillator
  * @rmtoll CSR          LSIONS        LL_RCC_LSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Enable(void)
{
3418424c:	b480      	push	{r7}
3418424e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_LSIONS);
34184250:	4b04      	ldr	r3, [pc, #16]	@ (34184264 <LL_RCC_LSI_Enable+0x18>)
34184252:	2201      	movs	r2, #1
34184254:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
34184258:	bf00      	nop
3418425a:	46bd      	mov	sp, r7
3418425c:	f85d 7b04 	ldr.w	r7, [sp], #4
34184260:	4770      	bx	lr
34184262:	bf00      	nop
34184264:	56028000 	.word	0x56028000

34184268 <LL_RCC_LSI_Disable>:
  * @brief  Disable LSI Oscillator
  * @rmtoll CCR          LSIONC        LL_RCC_LSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Disable(void)
{
34184268:	b480      	push	{r7}
3418426a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
3418426c:	4b05      	ldr	r3, [pc, #20]	@ (34184284 <LL_RCC_LSI_Disable+0x1c>)
3418426e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34184272:	461a      	mov	r2, r3
34184274:	2301      	movs	r3, #1
34184276:	6013      	str	r3, [r2, #0]
}
34184278:	bf00      	nop
3418427a:	46bd      	mov	sp, r7
3418427c:	f85d 7b04 	ldr.w	r7, [sp], #4
34184280:	4770      	bx	lr
34184282:	bf00      	nop
34184284:	56028000 	.word	0x56028000

34184288 <LL_RCC_LSI_IsReady>:
  * @brief  Check if LSI is Ready
  * @rmtoll SR           LSIRDY        LL_RCC_LSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSI_IsReady(void)
{
34184288:	b480      	push	{r7}
3418428a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3418428c:	4b04      	ldr	r3, [pc, #16]	@ (341842a0 <LL_RCC_LSI_IsReady+0x18>)
3418428e:	685b      	ldr	r3, [r3, #4]
34184290:	f003 0301 	and.w	r3, r3, #1
}
34184294:	4618      	mov	r0, r3
34184296:	46bd      	mov	sp, r7
34184298:	f85d 7b04 	ldr.w	r7, [sp], #4
3418429c:	4770      	bx	lr
3418429e:	bf00      	nop
341842a0:	56028000 	.word	0x56028000

341842a4 <LL_RCC_GetCpuClkSource>:
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_IC1
  */
__STATIC_INLINE uint32_t LL_RCC_GetCpuClkSource(void)
{
341842a4:	b480      	push	{r7}
341842a6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
341842a8:	4b04      	ldr	r3, [pc, #16]	@ (341842bc <LL_RCC_GetCpuClkSource+0x18>)
341842aa:	6a1b      	ldr	r3, [r3, #32]
341842ac:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
341842b0:	4618      	mov	r0, r3
341842b2:	46bd      	mov	sp, r7
341842b4:	f85d 7b04 	ldr.w	r7, [sp], #4
341842b8:	4770      	bx	lr
341842ba:	bf00      	nop
341842bc:	56028000 	.word	0x56028000

341842c0 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_IC2_IC6_IC11
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
341842c0:	b480      	push	{r7}
341842c2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
341842c4:	4b04      	ldr	r3, [pc, #16]	@ (341842d8 <LL_RCC_GetSysClkSource+0x18>)
341842c6:	6a1b      	ldr	r3, [r3, #32]
341842c8:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
341842cc:	4618      	mov	r0, r3
341842ce:	46bd      	mov	sp, r7
341842d0:	f85d 7b04 	ldr.w	r7, [sp], #4
341842d4:	4770      	bx	lr
341842d6:	bf00      	nop
341842d8:	56028000 	.word	0x56028000

341842dc <LL_RCC_PLL1_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetSource(void)
{
341842dc:	b480      	push	{r7}
341842de:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
341842e0:	4b04      	ldr	r3, [pc, #16]	@ (341842f4 <LL_RCC_PLL1_GetSource+0x18>)
341842e2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341842e6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
341842ea:	4618      	mov	r0, r3
341842ec:	46bd      	mov	sp, r7
341842ee:	f85d 7b04 	ldr.w	r7, [sp], #4
341842f2:	4770      	bx	lr
341842f4:	56028000 	.word	0x56028000

341842f8 <LL_RCC_PLL1_IsReady>:
  * @brief  Check if PLL1 Ready
  * @rmtoll SR           PLL1RDY         LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
341842f8:	b480      	push	{r7}
341842fa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
341842fc:	4b07      	ldr	r3, [pc, #28]	@ (3418431c <LL_RCC_PLL1_IsReady+0x24>)
341842fe:	685b      	ldr	r3, [r3, #4]
34184300:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34184304:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34184308:	d101      	bne.n	3418430e <LL_RCC_PLL1_IsReady+0x16>
3418430a:	2301      	movs	r3, #1
3418430c:	e000      	b.n	34184310 <LL_RCC_PLL1_IsReady+0x18>
3418430e:	2300      	movs	r3, #0
}
34184310:	4618      	mov	r0, r3
34184312:	46bd      	mov	sp, r7
34184314:	f85d 7b04 	ldr.w	r7, [sp], #4
34184318:	4770      	bx	lr
3418431a:	bf00      	nop
3418431c:	56028000 	.word	0x56028000

34184320 <LL_RCC_PLL1_IsEnabledBypass>:
  * @brief  Check if PLL1 bypass is enabled
  * @rmtoll PLL1CFGR1    PLL1BYP         LL_RCC_PLL1_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsEnabledBypass(void)
{
34184320:	b480      	push	{r7}
34184322:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
34184324:	4b07      	ldr	r3, [pc, #28]	@ (34184344 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
34184326:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418432a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418432e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34184332:	d101      	bne.n	34184338 <LL_RCC_PLL1_IsEnabledBypass+0x18>
34184334:	2301      	movs	r3, #1
34184336:	e000      	b.n	3418433a <LL_RCC_PLL1_IsEnabledBypass+0x1a>
34184338:	2300      	movs	r3, #0
}
3418433a:	4618      	mov	r0, r3
3418433c:	46bd      	mov	sp, r7
3418433e:	f85d 7b04 	ldr.w	r7, [sp], #4
34184342:	4770      	bx	lr
34184344:	56028000 	.word	0x56028000

34184348 <LL_RCC_PLL2_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetSource(void)
{
34184348:	b480      	push	{r7}
3418434a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3418434c:	4b04      	ldr	r3, [pc, #16]	@ (34184360 <LL_RCC_PLL2_GetSource+0x18>)
3418434e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34184352:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34184356:	4618      	mov	r0, r3
34184358:	46bd      	mov	sp, r7
3418435a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418435e:	4770      	bx	lr
34184360:	56028000 	.word	0x56028000

34184364 <LL_RCC_PLL2_IsReady>:
  * @brief  Check if PLL2 Ready
  * @rmtoll SR           PLL2RDY         LL_RCC_PLL2_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsReady(void)
{
34184364:	b480      	push	{r7}
34184366:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34184368:	4b07      	ldr	r3, [pc, #28]	@ (34184388 <LL_RCC_PLL2_IsReady+0x24>)
3418436a:	685b      	ldr	r3, [r3, #4]
3418436c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34184370:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34184374:	d101      	bne.n	3418437a <LL_RCC_PLL2_IsReady+0x16>
34184376:	2301      	movs	r3, #1
34184378:	e000      	b.n	3418437c <LL_RCC_PLL2_IsReady+0x18>
3418437a:	2300      	movs	r3, #0
}
3418437c:	4618      	mov	r0, r3
3418437e:	46bd      	mov	sp, r7
34184380:	f85d 7b04 	ldr.w	r7, [sp], #4
34184384:	4770      	bx	lr
34184386:	bf00      	nop
34184388:	56028000 	.word	0x56028000

3418438c <LL_RCC_PLL2_IsEnabledBypass>:
  * @brief  Check if PLL2 bypass is enabled
  * @rmtoll PLL2CFGR1    PLL2BYP         LL_RCC_PLL2_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsEnabledBypass(void)
{
3418438c:	b480      	push	{r7}
3418438e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34184390:	4b07      	ldr	r3, [pc, #28]	@ (341843b0 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
34184392:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34184396:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418439a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418439e:	d101      	bne.n	341843a4 <LL_RCC_PLL2_IsEnabledBypass+0x18>
341843a0:	2301      	movs	r3, #1
341843a2:	e000      	b.n	341843a6 <LL_RCC_PLL2_IsEnabledBypass+0x1a>
341843a4:	2300      	movs	r3, #0
}
341843a6:	4618      	mov	r0, r3
341843a8:	46bd      	mov	sp, r7
341843aa:	f85d 7b04 	ldr.w	r7, [sp], #4
341843ae:	4770      	bx	lr
341843b0:	56028000 	.word	0x56028000

341843b4 <LL_RCC_PLL3_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetSource(void)
{
341843b4:	b480      	push	{r7}
341843b6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
341843b8:	4b04      	ldr	r3, [pc, #16]	@ (341843cc <LL_RCC_PLL3_GetSource+0x18>)
341843ba:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
341843be:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
341843c2:	4618      	mov	r0, r3
341843c4:	46bd      	mov	sp, r7
341843c6:	f85d 7b04 	ldr.w	r7, [sp], #4
341843ca:	4770      	bx	lr
341843cc:	56028000 	.word	0x56028000

341843d0 <LL_RCC_PLL3_IsReady>:
  * @brief  Check if PLL3 Ready
  * @rmtoll SR           PLL3RDY         LL_RCC_PLL3_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsReady(void)
{
341843d0:	b480      	push	{r7}
341843d2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
341843d4:	4b07      	ldr	r3, [pc, #28]	@ (341843f4 <LL_RCC_PLL3_IsReady+0x24>)
341843d6:	685b      	ldr	r3, [r3, #4]
341843d8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341843dc:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
341843e0:	d101      	bne.n	341843e6 <LL_RCC_PLL3_IsReady+0x16>
341843e2:	2301      	movs	r3, #1
341843e4:	e000      	b.n	341843e8 <LL_RCC_PLL3_IsReady+0x18>
341843e6:	2300      	movs	r3, #0
}
341843e8:	4618      	mov	r0, r3
341843ea:	46bd      	mov	sp, r7
341843ec:	f85d 7b04 	ldr.w	r7, [sp], #4
341843f0:	4770      	bx	lr
341843f2:	bf00      	nop
341843f4:	56028000 	.word	0x56028000

341843f8 <LL_RCC_PLL3_IsEnabledBypass>:
  * @brief  Check if PLL3 bypass is enabled
  * @rmtoll PLL3CFGR1    PLL3BYP         LL_RCC_PLL3_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsEnabledBypass(void)
{
341843f8:	b480      	push	{r7}
341843fa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
341843fc:	4b07      	ldr	r3, [pc, #28]	@ (3418441c <LL_RCC_PLL3_IsEnabledBypass+0x24>)
341843fe:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34184402:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34184406:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418440a:	d101      	bne.n	34184410 <LL_RCC_PLL3_IsEnabledBypass+0x18>
3418440c:	2301      	movs	r3, #1
3418440e:	e000      	b.n	34184412 <LL_RCC_PLL3_IsEnabledBypass+0x1a>
34184410:	2300      	movs	r3, #0
}
34184412:	4618      	mov	r0, r3
34184414:	46bd      	mov	sp, r7
34184416:	f85d 7b04 	ldr.w	r7, [sp], #4
3418441a:	4770      	bx	lr
3418441c:	56028000 	.word	0x56028000

34184420 <LL_RCC_PLL4_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_GetSource(void)
{
34184420:	b480      	push	{r7}
34184422:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
34184424:	4b04      	ldr	r3, [pc, #16]	@ (34184438 <LL_RCC_PLL4_GetSource+0x18>)
34184426:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418442a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418442e:	4618      	mov	r0, r3
34184430:	46bd      	mov	sp, r7
34184432:	f85d 7b04 	ldr.w	r7, [sp], #4
34184436:	4770      	bx	lr
34184438:	56028000 	.word	0x56028000

3418443c <LL_RCC_PLL4_IsReady>:
  * @brief  Check if PLL4 Ready
  * @rmtoll SR           PLL4RDY         LL_RCC_PLL4_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsReady(void)
{
3418443c:	b480      	push	{r7}
3418443e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34184440:	4b07      	ldr	r3, [pc, #28]	@ (34184460 <LL_RCC_PLL4_IsReady+0x24>)
34184442:	685b      	ldr	r3, [r3, #4]
34184444:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34184448:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3418444c:	d101      	bne.n	34184452 <LL_RCC_PLL4_IsReady+0x16>
3418444e:	2301      	movs	r3, #1
34184450:	e000      	b.n	34184454 <LL_RCC_PLL4_IsReady+0x18>
34184452:	2300      	movs	r3, #0
}
34184454:	4618      	mov	r0, r3
34184456:	46bd      	mov	sp, r7
34184458:	f85d 7b04 	ldr.w	r7, [sp], #4
3418445c:	4770      	bx	lr
3418445e:	bf00      	nop
34184460:	56028000 	.word	0x56028000

34184464 <LL_RCC_PLL4_IsEnabledBypass>:
  * @brief  Check if PLL4 bypass is enabled
  * @rmtoll PLL4CFGR1    PLL4BYP         LL_RCC_PLL4_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsEnabledBypass(void)
{
34184464:	b480      	push	{r7}
34184466:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34184468:	4b07      	ldr	r3, [pc, #28]	@ (34184488 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
3418446a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418446e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34184472:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34184476:	d101      	bne.n	3418447c <LL_RCC_PLL4_IsEnabledBypass+0x18>
34184478:	2301      	movs	r3, #1
3418447a:	e000      	b.n	3418447e <LL_RCC_PLL4_IsEnabledBypass+0x1a>
3418447c:	2300      	movs	r3, #0
}
3418447e:	4618      	mov	r0, r3
34184480:	46bd      	mov	sp, r7
34184482:	f85d 7b04 	ldr.w	r7, [sp], #4
34184486:	4770      	bx	lr
34184488:	56028000 	.word	0x56028000

3418448c <LL_RCC_IC1_Enable>:
  * @brief  Enable IC1
  * @rmtoll DIVENSR      IC1ENS        LL_RCC_IC1_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC1_Enable(void)
{
3418448c:	b480      	push	{r7}
3418448e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC1ENS);
34184490:	4b04      	ldr	r3, [pc, #16]	@ (341844a4 <LL_RCC_IC1_Enable+0x18>)
34184492:	2201      	movs	r2, #1
34184494:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34184498:	bf00      	nop
3418449a:	46bd      	mov	sp, r7
3418449c:	f85d 7b04 	ldr.w	r7, [sp], #4
341844a0:	4770      	bx	lr
341844a2:	bf00      	nop
341844a4:	56028000 	.word	0x56028000

341844a8 <LL_RCC_IC1_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetSource(void)
{
341844a8:	b480      	push	{r7}
341844aa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
341844ac:	4b04      	ldr	r3, [pc, #16]	@ (341844c0 <LL_RCC_IC1_GetSource+0x18>)
341844ae:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
341844b2:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
341844b6:	4618      	mov	r0, r3
341844b8:	46bd      	mov	sp, r7
341844ba:	f85d 7b04 	ldr.w	r7, [sp], #4
341844be:	4770      	bx	lr
341844c0:	56028000 	.word	0x56028000

341844c4 <LL_RCC_IC1_GetDivider>:
  * @brief  Get IC1 divider
  * @rmtoll IC1CFGR      IC1INT        LL_RCC_IC1_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetDivider(void)
{
341844c4:	b480      	push	{r7}
341844c6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
341844c8:	4b05      	ldr	r3, [pc, #20]	@ (341844e0 <LL_RCC_IC1_GetDivider+0x1c>)
341844ca:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
341844ce:	0c1b      	lsrs	r3, r3, #16
341844d0:	b2db      	uxtb	r3, r3
341844d2:	3301      	adds	r3, #1
}
341844d4:	4618      	mov	r0, r3
341844d6:	46bd      	mov	sp, r7
341844d8:	f85d 7b04 	ldr.w	r7, [sp], #4
341844dc:	4770      	bx	lr
341844de:	bf00      	nop
341844e0:	56028000 	.word	0x56028000

341844e4 <LL_RCC_IC2_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
341844e4:	b480      	push	{r7}
341844e6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
341844e8:	4b04      	ldr	r3, [pc, #16]	@ (341844fc <LL_RCC_IC2_GetSource+0x18>)
341844ea:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
341844ee:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
341844f2:	4618      	mov	r0, r3
341844f4:	46bd      	mov	sp, r7
341844f6:	f85d 7b04 	ldr.w	r7, [sp], #4
341844fa:	4770      	bx	lr
341844fc:	56028000 	.word	0x56028000

34184500 <LL_RCC_IC6_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC6_GetSource(void)
{
34184500:	b480      	push	{r7}
34184502:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34184504:	4b04      	ldr	r3, [pc, #16]	@ (34184518 <LL_RCC_IC6_GetSource+0x18>)
34184506:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3418450a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418450e:	4618      	mov	r0, r3
34184510:	46bd      	mov	sp, r7
34184512:	f85d 7b04 	ldr.w	r7, [sp], #4
34184516:	4770      	bx	lr
34184518:	56028000 	.word	0x56028000

3418451c <LL_RCC_IC11_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC11_GetSource(void)
{
3418451c:	b480      	push	{r7}
3418451e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34184520:	4b04      	ldr	r3, [pc, #16]	@ (34184534 <LL_RCC_IC11_GetSource+0x18>)
34184522:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34184526:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418452a:	4618      	mov	r0, r3
3418452c:	46bd      	mov	sp, r7
3418452e:	f85d 7b04 	ldr.w	r7, [sp], #4
34184532:	4770      	bx	lr
34184534:	56028000 	.word	0x56028000

34184538 <HAL_RCC_OscConfig>:
  * @note   This function activates HSE but does not wait for the startup time defined in the datasheet.
  *         This must be ensured by the application when the HSE is selected as PLL source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
34184538:	b580      	push	{r7, lr}
3418453a:	b0a2      	sub	sp, #136	@ 0x88
3418453c:	af00      	add	r7, sp, #0
3418453e:	6078      	str	r0, [r7, #4]
  uint32_t pll3src;
  uint32_t pll4src;
  uint32_t rccsr;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
34184540:	687b      	ldr	r3, [r7, #4]
34184542:	2b00      	cmp	r3, #0
34184544:	d101      	bne.n	3418454a <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
34184546:	2301      	movs	r3, #1
34184548:	e3d1      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));

  cpuclksrc = LL_RCC_GetCpuClkSource();
3418454a:	f7ff feab 	bl	341842a4 <LL_RCC_GetCpuClkSource>
3418454e:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
  sysclksrc = LL_RCC_GetSysClkSource();
34184552:	f7ff feb5 	bl	341842c0 <LL_RCC_GetSysClkSource>
34184556:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
  pll1src = LL_RCC_PLL1_GetSource();
3418455a:	f7ff febf 	bl	341842dc <LL_RCC_PLL1_GetSource>
3418455e:	67f8      	str	r0, [r7, #124]	@ 0x7c
  pll2src = LL_RCC_PLL2_GetSource();
34184560:	f7ff fef2 	bl	34184348 <LL_RCC_PLL2_GetSource>
34184564:	67b8      	str	r0, [r7, #120]	@ 0x78
  pll3src = LL_RCC_PLL3_GetSource();
34184566:	f7ff ff25 	bl	341843b4 <LL_RCC_PLL3_GetSource>
3418456a:	6778      	str	r0, [r7, #116]	@ 0x74
  pll4src = LL_RCC_PLL4_GetSource();
3418456c:	f7ff ff58 	bl	34184420 <LL_RCC_PLL4_GetSource>
34184570:	6738      	str	r0, [r7, #112]	@ 0x70
  rccsr = RCC->SR;
34184572:	4b91      	ldr	r3, [pc, #580]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
34184574:	685b      	ldr	r3, [r3, #4]
34184576:	66fb      	str	r3, [r7, #108]	@ 0x6c

  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
34184578:	687b      	ldr	r3, [r7, #4]
3418457a:	681b      	ldr	r3, [r3, #0]
3418457c:	f003 0301 	and.w	r3, r3, #1
34184580:	2b00      	cmp	r3, #0
34184582:	f000 80a8 	beq.w	341846d6 <HAL_RCC_OscConfig+0x19e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));

    /* When the HSE is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
34184586:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418458a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3418458e:	d028      	beq.n	341845e2 <HAL_RCC_OscConfig+0xaa>
34184590:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34184594:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34184598:	d023      	beq.n	341845e2 <HAL_RCC_OscConfig+0xaa>
3418459a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3418459c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341845a0:	d104      	bne.n	341845ac <HAL_RCC_OscConfig+0x74>
        ((pll1src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
341845a2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341845a4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
341845a8:	2b00      	cmp	r3, #0
341845aa:	d11a      	bne.n	341845e2 <HAL_RCC_OscConfig+0xaa>
341845ac:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
341845ae:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341845b2:	d104      	bne.n	341845be <HAL_RCC_OscConfig+0x86>
        ((pll2src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
341845b4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341845b6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341845ba:	2b00      	cmp	r3, #0
341845bc:	d111      	bne.n	341845e2 <HAL_RCC_OscConfig+0xaa>
341845be:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
341845c0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341845c4:	d104      	bne.n	341845d0 <HAL_RCC_OscConfig+0x98>
        ((pll3src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
341845c6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341845c8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341845cc:	2b00      	cmp	r3, #0
341845ce:	d108      	bne.n	341845e2 <HAL_RCC_OscConfig+0xaa>
341845d0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
341845d2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341845d6:	d10a      	bne.n	341845ee <HAL_RCC_OscConfig+0xb6>
        ((pll4src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
341845d8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341845da:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
341845de:	2b00      	cmp	r3, #0
341845e0:	d005      	beq.n	341845ee <HAL_RCC_OscConfig+0xb6>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
341845e2:	687b      	ldr	r3, [r7, #4]
341845e4:	685b      	ldr	r3, [r3, #4]
341845e6:	2b00      	cmp	r3, #0
341845e8:	d175      	bne.n	341846d6 <HAL_RCC_OscConfig+0x19e>
      {
        return HAL_ERROR;
341845ea:	2301      	movs	r3, #1
341845ec:	e37f      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      /* HSE ON , nothing to do */
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
341845ee:	687b      	ldr	r3, [r7, #4]
341845f0:	685b      	ldr	r3, [r3, #4]
341845f2:	2b10      	cmp	r3, #16
341845f4:	d104      	bne.n	34184600 <HAL_RCC_OscConfig+0xc8>
341845f6:	4b70      	ldr	r3, [pc, #448]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
341845f8:	2210      	movs	r2, #16
341845fa:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
341845fe:	e043      	b.n	34184688 <HAL_RCC_OscConfig+0x150>
34184600:	687b      	ldr	r3, [r7, #4]
34184602:	685b      	ldr	r3, [r3, #4]
34184604:	2b00      	cmp	r3, #0
34184606:	d10c      	bne.n	34184622 <HAL_RCC_OscConfig+0xea>
34184608:	4b6b      	ldr	r3, [pc, #428]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
3418460a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418460e:	461a      	mov	r2, r3
34184610:	2310      	movs	r3, #16
34184612:	6013      	str	r3, [r2, #0]
34184614:	4b68      	ldr	r3, [pc, #416]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
34184616:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34184618:	4a67      	ldr	r2, [pc, #412]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
3418461a:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
3418461e:	6553      	str	r3, [r2, #84]	@ 0x54
34184620:	e032      	b.n	34184688 <HAL_RCC_OscConfig+0x150>
34184622:	687b      	ldr	r3, [r7, #4]
34184624:	685b      	ldr	r3, [r3, #4]
34184626:	f248 0210 	movw	r2, #32784	@ 0x8010
3418462a:	4293      	cmp	r3, r2
3418462c:	d110      	bne.n	34184650 <HAL_RCC_OscConfig+0x118>
3418462e:	4b62      	ldr	r3, [pc, #392]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
34184630:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34184632:	4a61      	ldr	r2, [pc, #388]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
34184634:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34184638:	6553      	str	r3, [r2, #84]	@ 0x54
3418463a:	4b5f      	ldr	r3, [pc, #380]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
3418463c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418463e:	4a5e      	ldr	r2, [pc, #376]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
34184640:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34184644:	6553      	str	r3, [r2, #84]	@ 0x54
34184646:	4b5c      	ldr	r3, [pc, #368]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
34184648:	2210      	movs	r2, #16
3418464a:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418464e:	e01b      	b.n	34184688 <HAL_RCC_OscConfig+0x150>
34184650:	687b      	ldr	r3, [r7, #4]
34184652:	685b      	ldr	r3, [r3, #4]
34184654:	4a59      	ldr	r2, [pc, #356]	@ (341847bc <HAL_RCC_OscConfig+0x284>)
34184656:	4293      	cmp	r3, r2
34184658:	d10a      	bne.n	34184670 <HAL_RCC_OscConfig+0x138>
3418465a:	4b57      	ldr	r3, [pc, #348]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
3418465c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418465e:	4a56      	ldr	r2, [pc, #344]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
34184660:	f443 33c0 	orr.w	r3, r3, #98304	@ 0x18000
34184664:	6553      	str	r3, [r2, #84]	@ 0x54
34184666:	4b54      	ldr	r3, [pc, #336]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
34184668:	2210      	movs	r2, #16
3418466a:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418466e:	e00b      	b.n	34184688 <HAL_RCC_OscConfig+0x150>
34184670:	4b51      	ldr	r3, [pc, #324]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
34184672:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34184676:	461a      	mov	r2, r3
34184678:	2310      	movs	r3, #16
3418467a:	6013      	str	r3, [r2, #0]
3418467c:	4b4e      	ldr	r3, [pc, #312]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
3418467e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34184680:	4a4d      	ldr	r2, [pc, #308]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
34184682:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
34184686:	6553      	str	r3, [r2, #84]	@ 0x54

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34184688:	f7fd fdd0 	bl	3418222c <HAL_GetTick>
3418468c:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
3418468e:	687b      	ldr	r3, [r7, #4]
34184690:	685b      	ldr	r3, [r3, #4]
34184692:	2b00      	cmp	r3, #0
34184694:	d019      	beq.n	341846ca <HAL_RCC_OscConfig+0x192>
      {
        /* Wait till HSE is ready */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
34184696:	e008      	b.n	341846aa <HAL_RCC_OscConfig+0x172>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34184698:	f7fd fdc8 	bl	3418222c <HAL_GetTick>
3418469c:	4602      	mov	r2, r0
3418469e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341846a0:	1ad3      	subs	r3, r2, r3
341846a2:	2b64      	cmp	r3, #100	@ 0x64
341846a4:	d901      	bls.n	341846aa <HAL_RCC_OscConfig+0x172>
          {
            return HAL_TIMEOUT;
341846a6:	2303      	movs	r3, #3
341846a8:	e321      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
341846aa:	4b43      	ldr	r3, [pc, #268]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
341846ac:	685b      	ldr	r3, [r3, #4]
341846ae:	f003 0310 	and.w	r3, r3, #16
341846b2:	2b00      	cmp	r3, #0
341846b4:	d0f0      	beq.n	34184698 <HAL_RCC_OscConfig+0x160>
341846b6:	e00e      	b.n	341846d6 <HAL_RCC_OscConfig+0x19e>
      else
      {
        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
341846b8:	f7fd fdb8 	bl	3418222c <HAL_GetTick>
341846bc:	4602      	mov	r2, r0
341846be:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341846c0:	1ad3      	subs	r3, r2, r3
341846c2:	2b64      	cmp	r3, #100	@ 0x64
341846c4:	d901      	bls.n	341846ca <HAL_RCC_OscConfig+0x192>
          {
            return HAL_TIMEOUT;
341846c6:	2303      	movs	r3, #3
341846c8:	e311      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
341846ca:	4b3b      	ldr	r3, [pc, #236]	@ (341847b8 <HAL_RCC_OscConfig+0x280>)
341846cc:	685b      	ldr	r3, [r3, #4]
341846ce:	f003 0310 	and.w	r3, r3, #16
341846d2:	2b00      	cmp	r3, #0
341846d4:	d1f0      	bne.n	341846b8 <HAL_RCC_OscConfig+0x180>
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
341846d6:	687b      	ldr	r3, [r7, #4]
341846d8:	681b      	ldr	r3, [r3, #0]
341846da:	f003 0302 	and.w	r3, r3, #2
341846de:	2b00      	cmp	r3, #0
341846e0:	d073      	beq.n	341847ca <HAL_RCC_OscConfig+0x292>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));

    /* When the HSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
341846e2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341846e6:	2b00      	cmp	r3, #0
341846e8:	d023      	beq.n	34184732 <HAL_RCC_OscConfig+0x1fa>
341846ea:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
341846ee:	2b00      	cmp	r3, #0
341846f0:	d01f      	beq.n	34184732 <HAL_RCC_OscConfig+0x1fa>
341846f2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
341846f4:	2b00      	cmp	r3, #0
341846f6:	d104      	bne.n	34184702 <HAL_RCC_OscConfig+0x1ca>
        ((pll1src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
341846f8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341846fa:	f403 7380 	and.w	r3, r3, #256	@ 0x100
341846fe:	2b00      	cmp	r3, #0
34184700:	d117      	bne.n	34184732 <HAL_RCC_OscConfig+0x1fa>
34184702:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34184704:	2b00      	cmp	r3, #0
34184706:	d104      	bne.n	34184712 <HAL_RCC_OscConfig+0x1da>
        ((pll2src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
34184708:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418470a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418470e:	2b00      	cmp	r3, #0
34184710:	d10f      	bne.n	34184732 <HAL_RCC_OscConfig+0x1fa>
34184712:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34184714:	2b00      	cmp	r3, #0
34184716:	d104      	bne.n	34184722 <HAL_RCC_OscConfig+0x1ea>
        ((pll3src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
34184718:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418471a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418471e:	2b00      	cmp	r3, #0
34184720:	d107      	bne.n	34184732 <HAL_RCC_OscConfig+0x1fa>
34184722:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34184724:	2b00      	cmp	r3, #0
34184726:	d115      	bne.n	34184754 <HAL_RCC_OscConfig+0x21c>
        ((pll4src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34184728:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418472a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418472e:	2b00      	cmp	r3, #0
34184730:	d010      	beq.n	34184754 <HAL_RCC_OscConfig+0x21c>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
34184732:	687b      	ldr	r3, [r7, #4]
34184734:	68db      	ldr	r3, [r3, #12]
34184736:	2b00      	cmp	r3, #0
34184738:	d101      	bne.n	3418473e <HAL_RCC_OscConfig+0x206>
      {
        return HAL_ERROR;
3418473a:	2301      	movs	r3, #1
3418473c:	e2d7      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3418473e:	687b      	ldr	r3, [r7, #4]
34184740:	691b      	ldr	r3, [r3, #16]
34184742:	4618      	mov	r0, r3
34184744:	f7ff fcd0 	bl	341840e8 <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
34184748:	687b      	ldr	r3, [r7, #4]
3418474a:	695b      	ldr	r3, [r3, #20]
3418474c:	4618      	mov	r0, r3
3418474e:	f7ff fced 	bl	3418412c <LL_RCC_HSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
34184752:	e03a      	b.n	341847ca <HAL_RCC_OscConfig+0x292>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
34184754:	687b      	ldr	r3, [r7, #4]
34184756:	68db      	ldr	r3, [r3, #12]
34184758:	2b00      	cmp	r3, #0
3418475a:	d01e      	beq.n	3418479a <HAL_RCC_OscConfig+0x262>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
3418475c:	f7ff fc94 	bl	34184088 <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34184760:	f7fd fd64 	bl	3418222c <HAL_GetTick>
34184764:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
34184766:	e008      	b.n	3418477a <HAL_RCC_OscConfig+0x242>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
34184768:	f7fd fd60 	bl	3418222c <HAL_GetTick>
3418476c:	4602      	mov	r2, r0
3418476e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34184770:	1ad3      	subs	r3, r2, r3
34184772:	2b01      	cmp	r3, #1
34184774:	d901      	bls.n	3418477a <HAL_RCC_OscConfig+0x242>
          {
            return HAL_TIMEOUT;
34184776:	2303      	movs	r3, #3
34184778:	e2b9      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_HSI_IsReady() == 0U)
3418477a:	f7ff fca3 	bl	341840c4 <LL_RCC_HSI_IsReady>
3418477e:	4603      	mov	r3, r0
34184780:	2b00      	cmp	r3, #0
34184782:	d0f1      	beq.n	34184768 <HAL_RCC_OscConfig+0x230>
          }
        }

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
34184784:	687b      	ldr	r3, [r7, #4]
34184786:	691b      	ldr	r3, [r3, #16]
34184788:	4618      	mov	r0, r3
3418478a:	f7ff fcad 	bl	341840e8 <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
3418478e:	687b      	ldr	r3, [r7, #4]
34184790:	695b      	ldr	r3, [r3, #20]
34184792:	4618      	mov	r0, r3
34184794:	f7ff fcca 	bl	3418412c <LL_RCC_HSI_SetCalibTrimming>
34184798:	e017      	b.n	341847ca <HAL_RCC_OscConfig+0x292>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
3418479a:	f7ff fc83 	bl	341840a4 <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418479e:	f7fd fd45 	bl	3418222c <HAL_GetTick>
341847a2:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
341847a4:	e00c      	b.n	341847c0 <HAL_RCC_OscConfig+0x288>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
341847a6:	f7fd fd41 	bl	3418222c <HAL_GetTick>
341847aa:	4602      	mov	r2, r0
341847ac:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341847ae:	1ad3      	subs	r3, r2, r3
341847b0:	2b01      	cmp	r3, #1
341847b2:	d905      	bls.n	341847c0 <HAL_RCC_OscConfig+0x288>
          {
            return HAL_TIMEOUT;
341847b4:	2303      	movs	r3, #3
341847b6:	e29a      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
341847b8:	56028000 	.word	0x56028000
341847bc:	00018010 	.word	0x00018010
        while (LL_RCC_HSI_IsReady() != 0U)
341847c0:	f7ff fc80 	bl	341840c4 <LL_RCC_HSI_IsReady>
341847c4:	4603      	mov	r3, r0
341847c6:	2b00      	cmp	r3, #0
341847c8:	d1ed      	bne.n	341847a6 <HAL_RCC_OscConfig+0x26e>
      }
    }
  }

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
341847ca:	687b      	ldr	r3, [r7, #4]
341847cc:	681b      	ldr	r3, [r3, #0]
341847ce:	f003 0310 	and.w	r3, r3, #16
341847d2:	2b00      	cmp	r3, #0
341847d4:	d070      	beq.n	341848b8 <HAL_RCC_OscConfig+0x380>
    /* Check the parameters */
    assert_param(IS_RCC_MSI(pRCC_OscInitStruct->MSIState));

    /* When the MSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    /* but just to update the MSI calibration value */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
341847d6:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341847da:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
341847de:	d028      	beq.n	34184832 <HAL_RCC_OscConfig+0x2fa>
341847e0:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
341847e4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341847e8:	d023      	beq.n	34184832 <HAL_RCC_OscConfig+0x2fa>
341847ea:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
341847ec:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341847f0:	d104      	bne.n	341847fc <HAL_RCC_OscConfig+0x2c4>
        ((pll1src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
341847f2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341847f4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
341847f8:	2b00      	cmp	r3, #0
341847fa:	d11a      	bne.n	34184832 <HAL_RCC_OscConfig+0x2fa>
341847fc:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
341847fe:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34184802:	d104      	bne.n	3418480e <HAL_RCC_OscConfig+0x2d6>
        ((pll2src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
34184804:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34184806:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418480a:	2b00      	cmp	r3, #0
3418480c:	d111      	bne.n	34184832 <HAL_RCC_OscConfig+0x2fa>
3418480e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34184810:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34184814:	d104      	bne.n	34184820 <HAL_RCC_OscConfig+0x2e8>
        ((pll3src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
34184816:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34184818:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418481c:	2b00      	cmp	r3, #0
3418481e:	d108      	bne.n	34184832 <HAL_RCC_OscConfig+0x2fa>
34184820:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34184822:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34184826:	d110      	bne.n	3418484a <HAL_RCC_OscConfig+0x312>
        ((pll4src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34184828:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418482a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418482e:	2b00      	cmp	r3, #0
34184830:	d00b      	beq.n	3418484a <HAL_RCC_OscConfig+0x312>
    {
      /* When MSI is used as system clock it will not disabled */
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
34184832:	687b      	ldr	r3, [r7, #4]
34184834:	69db      	ldr	r3, [r3, #28]
34184836:	2b00      	cmp	r3, #0
34184838:	d101      	bne.n	3418483e <HAL_RCC_OscConfig+0x306>
      {
        return HAL_ERROR;
3418483a:	2301      	movs	r3, #1
3418483c:	e257      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      {
        /* Check the parameters */
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
3418483e:	687b      	ldr	r3, [r7, #4]
34184840:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184842:	4618      	mov	r0, r3
34184844:	f7ff fcda 	bl	341841fc <LL_RCC_MSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
34184848:	e036      	b.n	341848b8 <HAL_RCC_OscConfig+0x380>
      }
    }
    else
    {
      /* Check the MSI State */
      if ((pRCC_OscInitStruct->MSIState) != RCC_MSI_OFF)
3418484a:	687b      	ldr	r3, [r7, #4]
3418484c:	69db      	ldr	r3, [r3, #28]
3418484e:	2b00      	cmp	r3, #0
34184850:	d01e      	beq.n	34184890 <HAL_RCC_OscConfig+0x358>
        /* Check the parameters */
        assert_param(IS_RCC_MSI_FREQUENCY(pRCC_OscInitStruct->MSIFrequency));
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Set the frequency */
        __HAL_RCC_MSI_FREQUENCY_CONFIG(pRCC_OscInitStruct->MSIFrequency);
34184852:	687b      	ldr	r3, [r7, #4]
34184854:	6a1b      	ldr	r3, [r3, #32]
34184856:	4618      	mov	r0, r3
34184858:	f7ff fcae 	bl	341841b8 <LL_RCC_MSI_SetFrequency>

        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
3418485c:	f7ff fc7c 	bl	34184158 <LL_RCC_MSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34184860:	f7fd fce4 	bl	3418222c <HAL_GetTick>
34184864:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
34184866:	e008      	b.n	3418487a <HAL_RCC_OscConfig+0x342>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
34184868:	f7fd fce0 	bl	3418222c <HAL_GetTick>
3418486c:	4602      	mov	r2, r0
3418486e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34184870:	1ad3      	subs	r3, r2, r3
34184872:	2b01      	cmp	r3, #1
34184874:	d901      	bls.n	3418487a <HAL_RCC_OscConfig+0x342>
          {
            return HAL_TIMEOUT;
34184876:	2303      	movs	r3, #3
34184878:	e239      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() == 0U)
3418487a:	f7ff fc8b 	bl	34184194 <LL_RCC_MSI_IsReady>
3418487e:	4603      	mov	r3, r0
34184880:	2b00      	cmp	r3, #0
34184882:	d0f1      	beq.n	34184868 <HAL_RCC_OscConfig+0x330>
          }
        }

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
34184884:	687b      	ldr	r3, [r7, #4]
34184886:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184888:	4618      	mov	r0, r3
3418488a:	f7ff fcb7 	bl	341841fc <LL_RCC_MSI_SetCalibTrimming>
3418488e:	e013      	b.n	341848b8 <HAL_RCC_OscConfig+0x380>
      }
      else
      {
        /* Ignore MSI frequency and calibration values in disable case */
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
34184890:	f7ff fc70 	bl	34184174 <LL_RCC_MSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34184894:	f7fd fcca 	bl	3418222c <HAL_GetTick>
34184898:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
3418489a:	e008      	b.n	341848ae <HAL_RCC_OscConfig+0x376>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
3418489c:	f7fd fcc6 	bl	3418222c <HAL_GetTick>
341848a0:	4602      	mov	r2, r0
341848a2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341848a4:	1ad3      	subs	r3, r2, r3
341848a6:	2b01      	cmp	r3, #1
341848a8:	d901      	bls.n	341848ae <HAL_RCC_OscConfig+0x376>
          {
            return HAL_TIMEOUT;
341848aa:	2303      	movs	r3, #3
341848ac:	e21f      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() != 0U)
341848ae:	f7ff fc71 	bl	34184194 <LL_RCC_MSI_IsReady>
341848b2:	4603      	mov	r3, r0
341848b4:	2b00      	cmp	r3, #0
341848b6:	d1f1      	bne.n	3418489c <HAL_RCC_OscConfig+0x364>
      }
    }
  }

  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
341848b8:	687b      	ldr	r3, [r7, #4]
341848ba:	681b      	ldr	r3, [r3, #0]
341848bc:	f003 0308 	and.w	r3, r3, #8
341848c0:	2b00      	cmp	r3, #0
341848c2:	d02c      	beq.n	3418491e <HAL_RCC_OscConfig+0x3e6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((pRCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
341848c4:	687b      	ldr	r3, [r7, #4]
341848c6:	699b      	ldr	r3, [r3, #24]
341848c8:	2b00      	cmp	r3, #0
341848ca:	d014      	beq.n	341848f6 <HAL_RCC_OscConfig+0x3be>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
341848cc:	f7ff fcbe 	bl	3418424c <LL_RCC_LSI_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
341848d0:	f7fd fcac 	bl	3418222c <HAL_GetTick>
341848d4:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() == 0U)
341848d6:	e008      	b.n	341848ea <HAL_RCC_OscConfig+0x3b2>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
341848d8:	f7fd fca8 	bl	3418222c <HAL_GetTick>
341848dc:	4602      	mov	r2, r0
341848de:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341848e0:	1ad3      	subs	r3, r2, r3
341848e2:	2b01      	cmp	r3, #1
341848e4:	d901      	bls.n	341848ea <HAL_RCC_OscConfig+0x3b2>
        {
          return HAL_TIMEOUT;
341848e6:	2303      	movs	r3, #3
341848e8:	e201      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() == 0U)
341848ea:	f7ff fccd 	bl	34184288 <LL_RCC_LSI_IsReady>
341848ee:	4603      	mov	r3, r0
341848f0:	2b00      	cmp	r3, #0
341848f2:	d0f1      	beq.n	341848d8 <HAL_RCC_OscConfig+0x3a0>
341848f4:	e013      	b.n	3418491e <HAL_RCC_OscConfig+0x3e6>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
341848f6:	f7ff fcb7 	bl	34184268 <LL_RCC_LSI_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
341848fa:	f7fd fc97 	bl	3418222c <HAL_GetTick>
341848fe:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() != 0U)
34184900:	e008      	b.n	34184914 <HAL_RCC_OscConfig+0x3dc>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
34184902:	f7fd fc93 	bl	3418222c <HAL_GetTick>
34184906:	4602      	mov	r2, r0
34184908:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418490a:	1ad3      	subs	r3, r2, r3
3418490c:	2b01      	cmp	r3, #1
3418490e:	d901      	bls.n	34184914 <HAL_RCC_OscConfig+0x3dc>
        {
          return HAL_TIMEOUT;
34184910:	2303      	movs	r3, #3
34184912:	e1ec      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() != 0U)
34184914:	f7ff fcb8 	bl	34184288 <LL_RCC_LSI_IsReady>
34184918:	4603      	mov	r3, r0
3418491a:	2b00      	cmp	r3, #0
3418491c:	d1f1      	bne.n	34184902 <HAL_RCC_OscConfig+0x3ca>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
3418491e:	687b      	ldr	r3, [r7, #4]
34184920:	681b      	ldr	r3, [r3, #0]
34184922:	f003 0304 	and.w	r3, r3, #4
34184926:	2b00      	cmp	r3, #0
34184928:	f000 808c 	beq.w	34184a44 <HAL_RCC_OscConfig+0x50c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
3418492c:	687b      	ldr	r3, [r7, #4]
3418492e:	689b      	ldr	r3, [r3, #8]
34184930:	2b02      	cmp	r3, #2
34184932:	d104      	bne.n	3418493e <HAL_RCC_OscConfig+0x406>
34184934:	4b96      	ldr	r3, [pc, #600]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
34184936:	2202      	movs	r2, #2
34184938:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418493c:	e055      	b.n	341849ea <HAL_RCC_OscConfig+0x4b2>
3418493e:	687b      	ldr	r3, [r7, #4]
34184940:	689b      	ldr	r3, [r3, #8]
34184942:	2b00      	cmp	r3, #0
34184944:	d112      	bne.n	3418496c <HAL_RCC_OscConfig+0x434>
34184946:	4b92      	ldr	r3, [pc, #584]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
34184948:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418494c:	461a      	mov	r2, r3
3418494e:	2302      	movs	r3, #2
34184950:	6013      	str	r3, [r2, #0]
34184952:	4b8f      	ldr	r3, [pc, #572]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
34184954:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34184956:	4a8e      	ldr	r2, [pc, #568]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
34184958:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418495c:	6413      	str	r3, [r2, #64]	@ 0x40
3418495e:	4b8c      	ldr	r3, [pc, #560]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
34184960:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34184962:	4a8b      	ldr	r2, [pc, #556]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
34184964:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
34184968:	6413      	str	r3, [r2, #64]	@ 0x40
3418496a:	e03e      	b.n	341849ea <HAL_RCC_OscConfig+0x4b2>
3418496c:	687b      	ldr	r3, [r7, #4]
3418496e:	689b      	ldr	r3, [r3, #8]
34184970:	f248 0202 	movw	r2, #32770	@ 0x8002
34184974:	4293      	cmp	r3, r2
34184976:	d110      	bne.n	3418499a <HAL_RCC_OscConfig+0x462>
34184978:	4b85      	ldr	r3, [pc, #532]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
3418497a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418497c:	4a84      	ldr	r2, [pc, #528]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
3418497e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34184982:	6413      	str	r3, [r2, #64]	@ 0x40
34184984:	4b82      	ldr	r3, [pc, #520]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
34184986:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34184988:	4a81      	ldr	r2, [pc, #516]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
3418498a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418498e:	6413      	str	r3, [r2, #64]	@ 0x40
34184990:	4b7f      	ldr	r3, [pc, #508]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
34184992:	2202      	movs	r2, #2
34184994:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34184998:	e027      	b.n	341849ea <HAL_RCC_OscConfig+0x4b2>
3418499a:	687b      	ldr	r3, [r7, #4]
3418499c:	689b      	ldr	r3, [r3, #8]
3418499e:	4a7d      	ldr	r2, [pc, #500]	@ (34184b94 <HAL_RCC_OscConfig+0x65c>)
341849a0:	4293      	cmp	r3, r2
341849a2:	d110      	bne.n	341849c6 <HAL_RCC_OscConfig+0x48e>
341849a4:	4b7a      	ldr	r3, [pc, #488]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
341849a6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
341849a8:	4a79      	ldr	r2, [pc, #484]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
341849aa:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
341849ae:	6413      	str	r3, [r2, #64]	@ 0x40
341849b0:	4b77      	ldr	r3, [pc, #476]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
341849b2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
341849b4:	4a76      	ldr	r2, [pc, #472]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
341849b6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
341849ba:	6413      	str	r3, [r2, #64]	@ 0x40
341849bc:	4b74      	ldr	r3, [pc, #464]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
341849be:	2202      	movs	r2, #2
341849c0:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
341849c4:	e011      	b.n	341849ea <HAL_RCC_OscConfig+0x4b2>
341849c6:	4b72      	ldr	r3, [pc, #456]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
341849c8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341849cc:	461a      	mov	r2, r3
341849ce:	2302      	movs	r3, #2
341849d0:	6013      	str	r3, [r2, #0]
341849d2:	4b6f      	ldr	r3, [pc, #444]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
341849d4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
341849d6:	4a6e      	ldr	r2, [pc, #440]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
341849d8:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
341849dc:	6413      	str	r3, [r2, #64]	@ 0x40
341849de:	4b6c      	ldr	r3, [pc, #432]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
341849e0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
341849e2:	4a6b      	ldr	r2, [pc, #428]	@ (34184b90 <HAL_RCC_OscConfig+0x658>)
341849e4:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
341849e8:	6413      	str	r3, [r2, #64]	@ 0x40
    /* Check the LSE State */
    if ((pRCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
341849ea:	687b      	ldr	r3, [r7, #4]
341849ec:	689b      	ldr	r3, [r3, #8]
341849ee:	2b00      	cmp	r3, #0
341849f0:	d014      	beq.n	34184a1c <HAL_RCC_OscConfig+0x4e4>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
341849f2:	f7fd fc1b 	bl	3418222c <HAL_GetTick>
341849f6:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
341849f8:	e00a      	b.n	34184a10 <HAL_RCC_OscConfig+0x4d8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
341849fa:	f7fd fc17 	bl	3418222c <HAL_GetTick>
341849fe:	4602      	mov	r2, r0
34184a00:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34184a02:	1ad3      	subs	r3, r2, r3
34184a04:	f241 3288 	movw	r2, #5000	@ 0x1388
34184a08:	4293      	cmp	r3, r2
34184a0a:	d901      	bls.n	34184a10 <HAL_RCC_OscConfig+0x4d8>
        {
          return HAL_TIMEOUT;
34184a0c:	2303      	movs	r3, #3
34184a0e:	e16e      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() == 0U)
34184a10:	f7ff fc0a 	bl	34184228 <LL_RCC_LSE_IsReady>
34184a14:	4603      	mov	r3, r0
34184a16:	2b00      	cmp	r3, #0
34184a18:	d0ef      	beq.n	341849fa <HAL_RCC_OscConfig+0x4c2>
34184a1a:	e013      	b.n	34184a44 <HAL_RCC_OscConfig+0x50c>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34184a1c:	f7fd fc06 	bl	3418222c <HAL_GetTick>
34184a20:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
34184a22:	e00a      	b.n	34184a3a <HAL_RCC_OscConfig+0x502>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
34184a24:	f7fd fc02 	bl	3418222c <HAL_GetTick>
34184a28:	4602      	mov	r2, r0
34184a2a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34184a2c:	1ad3      	subs	r3, r2, r3
34184a2e:	f241 3288 	movw	r2, #5000	@ 0x1388
34184a32:	4293      	cmp	r3, r2
34184a34:	d901      	bls.n	34184a3a <HAL_RCC_OscConfig+0x502>
        {
          return HAL_TIMEOUT;
34184a36:	2303      	movs	r3, #3
34184a38:	e159      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() != 0U)
34184a3a:	f7ff fbf5 	bl	34184228 <LL_RCC_LSE_IsReady>
34184a3e:	4603      	mov	r3, r0
34184a40:	2b00      	cmp	r3, #0
34184a42:	d1ef      	bne.n	34184a24 <HAL_RCC_OscConfig+0x4ec>

  /*-------------------------------- PLL1 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL1.PLLState));

  if (pRCC_OscInitStruct->PLL1.PLLState != RCC_PLL_NONE)
34184a44:	687b      	ldr	r3, [r7, #4]
34184a46:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34184a48:	2b00      	cmp	r3, #0
34184a4a:	d04c      	beq.n	34184ae6 <HAL_RCC_OscConfig+0x5ae>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1));
34184a4c:	687b      	ldr	r3, [r7, #4]
34184a4e:	3328      	adds	r3, #40	@ 0x28
34184a50:	4619      	mov	r1, r3
34184a52:	2000      	movs	r0, #0
34184a54:	f000 fda4 	bl	341855a0 <RCC_PLL_IsNewConfig>
34184a58:	6678      	str	r0, [r7, #100]	@ 0x64
    uint32_t pll1_ready = LL_RCC_PLL1_IsReady();
34184a5a:	f7ff fc4d 	bl	341842f8 <LL_RCC_PLL1_IsReady>
34184a5e:	6638      	str	r0, [r7, #96]	@ 0x60
    if (new_pll_config == 1U)
34184a60:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34184a62:	2b01      	cmp	r3, #1
34184a64:	d130      	bne.n	34184ac8 <HAL_RCC_OscConfig+0x590>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
34184a66:	f7ff fd1f 	bl	341844a8 <LL_RCC_IC1_GetSource>
34184a6a:	65f8      	str	r0, [r7, #92]	@ 0x5c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34184a6c:	f7ff fd3a 	bl	341844e4 <LL_RCC_IC2_GetSource>
34184a70:	65b8      	str	r0, [r7, #88]	@ 0x58
      uint32_t ic6src = LL_RCC_IC6_GetSource();
34184a72:	f7ff fd45 	bl	34184500 <LL_RCC_IC6_GetSource>
34184a76:	6578      	str	r0, [r7, #84]	@ 0x54
      uint32_t ic11src = LL_RCC_IC11_GetSource();
34184a78:	f7ff fd50 	bl	3418451c <LL_RCC_IC11_GetSource>
34184a7c:	6538      	str	r0, [r7, #80]	@ 0x50
      /* PLL1 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL1))
34184a7e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34184a82:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34184a86:	d104      	bne.n	34184a92 <HAL_RCC_OscConfig+0x55a>
34184a88:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34184a8a:	2b00      	cmp	r3, #0
34184a8c:	d101      	bne.n	34184a92 <HAL_RCC_OscConfig+0x55a>
      {
        return HAL_ERROR;
34184a8e:	2301      	movs	r3, #1
34184a90:	e12d      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL1 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL1) ||
34184a92:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34184a96:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34184a9a:	d10a      	bne.n	34184ab2 <HAL_RCC_OscConfig+0x57a>
34184a9c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34184a9e:	2b00      	cmp	r3, #0
34184aa0:	d005      	beq.n	34184aae <HAL_RCC_OscConfig+0x576>
34184aa2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34184aa4:	2b00      	cmp	r3, #0
34184aa6:	d002      	beq.n	34184aae <HAL_RCC_OscConfig+0x576>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL1) ||
34184aa8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34184aaa:	2b00      	cmp	r3, #0
34184aac:	d101      	bne.n	34184ab2 <HAL_RCC_OscConfig+0x57a>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL1)))
      {
        return HAL_ERROR;
34184aae:	2301      	movs	r3, #1
34184ab0:	e11d      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL1 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1)) != HAL_OK)
34184ab2:	687b      	ldr	r3, [r7, #4]
34184ab4:	3328      	adds	r3, #40	@ 0x28
34184ab6:	4619      	mov	r1, r3
34184ab8:	2000      	movs	r0, #0
34184aba:	f000 fc15 	bl	341852e8 <RCC_PLL_Config>
34184abe:	4603      	mov	r3, r0
34184ac0:	2b00      	cmp	r3, #0
34184ac2:	d010      	beq.n	34184ae6 <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
34184ac4:	2301      	movs	r3, #1
34184ac6:	e112      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL1.PLLState == RCC_PLL_ON) && (pll1_ready == 0U))
34184ac8:	687b      	ldr	r3, [r7, #4]
34184aca:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34184acc:	2b02      	cmp	r3, #2
34184ace:	d10a      	bne.n	34184ae6 <HAL_RCC_OscConfig+0x5ae>
34184ad0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34184ad2:	2b00      	cmp	r3, #0
34184ad4:	d107      	bne.n	34184ae6 <HAL_RCC_OscConfig+0x5ae>
    {
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
34184ad6:	2000      	movs	r0, #0
34184ad8:	f000 fd36 	bl	34185548 <RCC_PLL_Enable>
34184adc:	4603      	mov	r3, r0
34184ade:	2b00      	cmp	r3, #0
34184ae0:	d001      	beq.n	34184ae6 <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
34184ae2:	2301      	movs	r3, #1
34184ae4:	e103      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL2 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL2.PLLState));

  if (pRCC_OscInitStruct->PLL2.PLLState != RCC_PLL_NONE)
34184ae6:	687b      	ldr	r3, [r7, #4]
34184ae8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34184aea:	2b00      	cmp	r3, #0
34184aec:	d054      	beq.n	34184b98 <HAL_RCC_OscConfig+0x660>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2));
34184aee:	687b      	ldr	r3, [r7, #4]
34184af0:	3344      	adds	r3, #68	@ 0x44
34184af2:	4619      	mov	r1, r3
34184af4:	2001      	movs	r0, #1
34184af6:	f000 fd53 	bl	341855a0 <RCC_PLL_IsNewConfig>
34184afa:	64f8      	str	r0, [r7, #76]	@ 0x4c
    uint32_t pll2_ready = LL_RCC_PLL2_IsReady();
34184afc:	f7ff fc32 	bl	34184364 <LL_RCC_PLL2_IsReady>
34184b00:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (new_pll_config == 1U)
34184b02:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34184b04:	2b01      	cmp	r3, #1
34184b06:	d134      	bne.n	34184b72 <HAL_RCC_OscConfig+0x63a>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
34184b08:	f7ff fcce 	bl	341844a8 <LL_RCC_IC1_GetSource>
34184b0c:	6478      	str	r0, [r7, #68]	@ 0x44
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34184b0e:	f7ff fce9 	bl	341844e4 <LL_RCC_IC2_GetSource>
34184b12:	6438      	str	r0, [r7, #64]	@ 0x40
      uint32_t ic6src = LL_RCC_IC6_GetSource();
34184b14:	f7ff fcf4 	bl	34184500 <LL_RCC_IC6_GetSource>
34184b18:	63f8      	str	r0, [r7, #60]	@ 0x3c
      uint32_t ic11src = LL_RCC_IC11_GetSource();
34184b1a:	f7ff fcff 	bl	3418451c <LL_RCC_IC11_GetSource>
34184b1e:	63b8      	str	r0, [r7, #56]	@ 0x38
      /* PLL2 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL2))
34184b20:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34184b24:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34184b28:	d105      	bne.n	34184b36 <HAL_RCC_OscConfig+0x5fe>
34184b2a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34184b2c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34184b30:	d101      	bne.n	34184b36 <HAL_RCC_OscConfig+0x5fe>
      {
        return HAL_ERROR;
34184b32:	2301      	movs	r3, #1
34184b34:	e0db      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL2 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL2) ||
34184b36:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34184b3a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34184b3e:	d10d      	bne.n	34184b5c <HAL_RCC_OscConfig+0x624>
34184b40:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34184b42:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34184b46:	d007      	beq.n	34184b58 <HAL_RCC_OscConfig+0x620>
34184b48:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34184b4a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34184b4e:	d003      	beq.n	34184b58 <HAL_RCC_OscConfig+0x620>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL2) ||
34184b50:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34184b52:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34184b56:	d101      	bne.n	34184b5c <HAL_RCC_OscConfig+0x624>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL2)))
      {
        return HAL_ERROR;
34184b58:	2301      	movs	r3, #1
34184b5a:	e0c8      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL2 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2)) != HAL_OK)
34184b5c:	687b      	ldr	r3, [r7, #4]
34184b5e:	3344      	adds	r3, #68	@ 0x44
34184b60:	4619      	mov	r1, r3
34184b62:	2001      	movs	r0, #1
34184b64:	f000 fbc0 	bl	341852e8 <RCC_PLL_Config>
34184b68:	4603      	mov	r3, r0
34184b6a:	2b00      	cmp	r3, #0
34184b6c:	d014      	beq.n	34184b98 <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
34184b6e:	2301      	movs	r3, #1
34184b70:	e0bd      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL2.PLLState == RCC_PLL_ON) && (pll2_ready == 0U))
34184b72:	687b      	ldr	r3, [r7, #4]
34184b74:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34184b76:	2b02      	cmp	r3, #2
34184b78:	d10e      	bne.n	34184b98 <HAL_RCC_OscConfig+0x660>
34184b7a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34184b7c:	2b00      	cmp	r3, #0
34184b7e:	d10b      	bne.n	34184b98 <HAL_RCC_OscConfig+0x660>
    {
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
34184b80:	2001      	movs	r0, #1
34184b82:	f000 fce1 	bl	34185548 <RCC_PLL_Enable>
34184b86:	4603      	mov	r3, r0
34184b88:	2b00      	cmp	r3, #0
34184b8a:	d005      	beq.n	34184b98 <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
34184b8c:	2301      	movs	r3, #1
34184b8e:	e0ae      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
34184b90:	56028000 	.word	0x56028000
34184b94:	00018002 	.word	0x00018002

  /*-------------------------------- PLL3 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL3.PLLState));

  if (pRCC_OscInitStruct->PLL3.PLLState != RCC_PLL_NONE)
34184b98:	687b      	ldr	r3, [r7, #4]
34184b9a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34184b9c:	2b00      	cmp	r3, #0
34184b9e:	d050      	beq.n	34184c42 <HAL_RCC_OscConfig+0x70a>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3));
34184ba0:	687b      	ldr	r3, [r7, #4]
34184ba2:	3360      	adds	r3, #96	@ 0x60
34184ba4:	4619      	mov	r1, r3
34184ba6:	2002      	movs	r0, #2
34184ba8:	f000 fcfa 	bl	341855a0 <RCC_PLL_IsNewConfig>
34184bac:	6378      	str	r0, [r7, #52]	@ 0x34
    uint32_t pll3_ready = LL_RCC_PLL1_IsReady();
34184bae:	f7ff fba3 	bl	341842f8 <LL_RCC_PLL1_IsReady>
34184bb2:	6338      	str	r0, [r7, #48]	@ 0x30
    if (new_pll_config == 1U)
34184bb4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34184bb6:	2b01      	cmp	r3, #1
34184bb8:	d134      	bne.n	34184c24 <HAL_RCC_OscConfig+0x6ec>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
34184bba:	f7ff fc75 	bl	341844a8 <LL_RCC_IC1_GetSource>
34184bbe:	62f8      	str	r0, [r7, #44]	@ 0x2c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34184bc0:	f7ff fc90 	bl	341844e4 <LL_RCC_IC2_GetSource>
34184bc4:	62b8      	str	r0, [r7, #40]	@ 0x28
      uint32_t ic6src = LL_RCC_IC6_GetSource();
34184bc6:	f7ff fc9b 	bl	34184500 <LL_RCC_IC6_GetSource>
34184bca:	6278      	str	r0, [r7, #36]	@ 0x24
      uint32_t ic11src = LL_RCC_IC11_GetSource();
34184bcc:	f7ff fca6 	bl	3418451c <LL_RCC_IC11_GetSource>
34184bd0:	6238      	str	r0, [r7, #32]
      /* PLL3 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL3))
34184bd2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34184bd6:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34184bda:	d105      	bne.n	34184be8 <HAL_RCC_OscConfig+0x6b0>
34184bdc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34184bde:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34184be2:	d101      	bne.n	34184be8 <HAL_RCC_OscConfig+0x6b0>
      {
        return HAL_ERROR;
34184be4:	2301      	movs	r3, #1
34184be6:	e082      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL3) ||
34184be8:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34184bec:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34184bf0:	d10d      	bne.n	34184c0e <HAL_RCC_OscConfig+0x6d6>
34184bf2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34184bf4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34184bf8:	d007      	beq.n	34184c0a <HAL_RCC_OscConfig+0x6d2>
34184bfa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34184bfc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34184c00:	d003      	beq.n	34184c0a <HAL_RCC_OscConfig+0x6d2>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL3) ||
34184c02:	6a3b      	ldr	r3, [r7, #32]
34184c04:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34184c08:	d101      	bne.n	34184c0e <HAL_RCC_OscConfig+0x6d6>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL3)))
      {
        return HAL_ERROR;
34184c0a:	2301      	movs	r3, #1
34184c0c:	e06f      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3)) != HAL_OK)
34184c0e:	687b      	ldr	r3, [r7, #4]
34184c10:	3360      	adds	r3, #96	@ 0x60
34184c12:	4619      	mov	r1, r3
34184c14:	2002      	movs	r0, #2
34184c16:	f000 fb67 	bl	341852e8 <RCC_PLL_Config>
34184c1a:	4603      	mov	r3, r0
34184c1c:	2b00      	cmp	r3, #0
34184c1e:	d010      	beq.n	34184c42 <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
34184c20:	2301      	movs	r3, #1
34184c22:	e064      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL3.PLLState == RCC_PLL_ON) && (pll3_ready == 0U))
34184c24:	687b      	ldr	r3, [r7, #4]
34184c26:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34184c28:	2b02      	cmp	r3, #2
34184c2a:	d10a      	bne.n	34184c42 <HAL_RCC_OscConfig+0x70a>
34184c2c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34184c2e:	2b00      	cmp	r3, #0
34184c30:	d107      	bne.n	34184c42 <HAL_RCC_OscConfig+0x70a>
    {
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
34184c32:	2002      	movs	r0, #2
34184c34:	f000 fc88 	bl	34185548 <RCC_PLL_Enable>
34184c38:	4603      	mov	r3, r0
34184c3a:	2b00      	cmp	r3, #0
34184c3c:	d001      	beq.n	34184c42 <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
34184c3e:	2301      	movs	r3, #1
34184c40:	e055      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL4 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL4.PLLState));

  if (pRCC_OscInitStruct->PLL4.PLLState != RCC_PLL_NONE)
34184c42:	687b      	ldr	r3, [r7, #4]
34184c44:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34184c46:	2b00      	cmp	r3, #0
34184c48:	d050      	beq.n	34184cec <HAL_RCC_OscConfig+0x7b4>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4));
34184c4a:	687b      	ldr	r3, [r7, #4]
34184c4c:	337c      	adds	r3, #124	@ 0x7c
34184c4e:	4619      	mov	r1, r3
34184c50:	2003      	movs	r0, #3
34184c52:	f000 fca5 	bl	341855a0 <RCC_PLL_IsNewConfig>
34184c56:	61f8      	str	r0, [r7, #28]
    uint32_t pll4_ready = LL_RCC_PLL4_IsReady();
34184c58:	f7ff fbf0 	bl	3418443c <LL_RCC_PLL4_IsReady>
34184c5c:	61b8      	str	r0, [r7, #24]

    if (new_pll_config == 1U)
34184c5e:	69fb      	ldr	r3, [r7, #28]
34184c60:	2b01      	cmp	r3, #1
34184c62:	d134      	bne.n	34184cce <HAL_RCC_OscConfig+0x796>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
34184c64:	f7ff fc20 	bl	341844a8 <LL_RCC_IC1_GetSource>
34184c68:	6178      	str	r0, [r7, #20]
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34184c6a:	f7ff fc3b 	bl	341844e4 <LL_RCC_IC2_GetSource>
34184c6e:	6138      	str	r0, [r7, #16]
      uint32_t ic6src = LL_RCC_IC6_GetSource();
34184c70:	f7ff fc46 	bl	34184500 <LL_RCC_IC6_GetSource>
34184c74:	60f8      	str	r0, [r7, #12]
      uint32_t ic11src = LL_RCC_IC11_GetSource();
34184c76:	f7ff fc51 	bl	3418451c <LL_RCC_IC11_GetSource>
34184c7a:	60b8      	str	r0, [r7, #8]
      /* PLL4 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL4))
34184c7c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34184c80:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34184c84:	d105      	bne.n	34184c92 <HAL_RCC_OscConfig+0x75a>
34184c86:	697b      	ldr	r3, [r7, #20]
34184c88:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34184c8c:	d101      	bne.n	34184c92 <HAL_RCC_OscConfig+0x75a>
      {
        return HAL_ERROR;
34184c8e:	2301      	movs	r3, #1
34184c90:	e02d      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL4) ||
34184c92:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34184c96:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34184c9a:	d10d      	bne.n	34184cb8 <HAL_RCC_OscConfig+0x780>
34184c9c:	693b      	ldr	r3, [r7, #16]
34184c9e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34184ca2:	d007      	beq.n	34184cb4 <HAL_RCC_OscConfig+0x77c>
34184ca4:	68fb      	ldr	r3, [r7, #12]
34184ca6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34184caa:	d003      	beq.n	34184cb4 <HAL_RCC_OscConfig+0x77c>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL4) ||
34184cac:	68bb      	ldr	r3, [r7, #8]
34184cae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34184cb2:	d101      	bne.n	34184cb8 <HAL_RCC_OscConfig+0x780>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL4)))
      {
        return HAL_ERROR;
34184cb4:	2301      	movs	r3, #1
34184cb6:	e01a      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4)) != HAL_OK)
34184cb8:	687b      	ldr	r3, [r7, #4]
34184cba:	337c      	adds	r3, #124	@ 0x7c
34184cbc:	4619      	mov	r1, r3
34184cbe:	2003      	movs	r0, #3
34184cc0:	f000 fb12 	bl	341852e8 <RCC_PLL_Config>
34184cc4:	4603      	mov	r3, r0
34184cc6:	2b00      	cmp	r3, #0
34184cc8:	d010      	beq.n	34184cec <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
34184cca:	2301      	movs	r3, #1
34184ccc:	e00f      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL4.PLLState == RCC_PLL_ON) && (pll4_ready == 0U))
34184cce:	687b      	ldr	r3, [r7, #4]
34184cd0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34184cd2:	2b02      	cmp	r3, #2
34184cd4:	d10a      	bne.n	34184cec <HAL_RCC_OscConfig+0x7b4>
34184cd6:	69bb      	ldr	r3, [r7, #24]
34184cd8:	2b00      	cmp	r3, #0
34184cda:	d107      	bne.n	34184cec <HAL_RCC_OscConfig+0x7b4>
    {
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
34184cdc:	2003      	movs	r0, #3
34184cde:	f000 fc33 	bl	34185548 <RCC_PLL_Enable>
34184ce2:	4603      	mov	r3, r0
34184ce4:	2b00      	cmp	r3, #0
34184ce6:	d001      	beq.n	34184cec <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
34184ce8:	2301      	movs	r3, #1
34184cea:	e000      	b.n	34184cee <HAL_RCC_OscConfig+0x7b6>
    {
      /* Nothing to do */
    }
  }

  return HAL_OK;
34184cec:	2300      	movs	r3, #0
}
34184cee:	4618      	mov	r0, r3
34184cf0:	3788      	adds	r7, #136	@ 0x88
34184cf2:	46bd      	mov	sp, r7
34184cf4:	bd80      	pop	{r7, pc}
34184cf6:	bf00      	nop

34184cf8 <HAL_RCC_ClockConfig>:
  *         You can use HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
34184cf8:	b580      	push	{r7, lr}
34184cfa:	b084      	sub	sp, #16
34184cfc:	af00      	add	r7, sp, #0
34184cfe:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
34184d00:	687b      	ldr	r3, [r7, #4]
34184d02:	2b00      	cmp	r3, #0
34184d04:	d101      	bne.n	34184d0a <HAL_RCC_ClockConfig+0x12>
  {
    return HAL_ERROR;
34184d06:	2301      	movs	r3, #1
34184d08:	e1f2      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
  assert_param(IS_RCC_CLOCKTYPE(pRCC_ClkInitStruct->ClockType));

  /* Increasing the BUS frequency divider ? */

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
34184d0a:	687b      	ldr	r3, [r7, #4]
34184d0c:	681b      	ldr	r3, [r3, #0]
34184d0e:	f003 0308 	and.w	r3, r3, #8
34184d12:	2b00      	cmp	r3, #0
34184d14:	d010      	beq.n	34184d38 <HAL_RCC_ClockConfig+0x40>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
34184d16:	687b      	ldr	r3, [r7, #4]
34184d18:	691a      	ldr	r2, [r3, #16]
34184d1a:	4ba3      	ldr	r3, [pc, #652]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184d1c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184d1e:	f003 0307 	and.w	r3, r3, #7
34184d22:	429a      	cmp	r2, r3
34184d24:	d908      	bls.n	34184d38 <HAL_RCC_ClockConfig+0x40>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
34184d26:	4ba0      	ldr	r3, [pc, #640]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184d28:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184d2a:	f023 0207 	bic.w	r2, r3, #7
34184d2e:	687b      	ldr	r3, [r7, #4]
34184d30:	691b      	ldr	r3, [r3, #16]
34184d32:	499d      	ldr	r1, [pc, #628]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184d34:	4313      	orrs	r3, r2
34184d36:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
34184d38:	687b      	ldr	r3, [r7, #4]
34184d3a:	681b      	ldr	r3, [r3, #0]
34184d3c:	f003 0310 	and.w	r3, r3, #16
34184d40:	2b00      	cmp	r3, #0
34184d42:	d010      	beq.n	34184d66 <HAL_RCC_ClockConfig+0x6e>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE2))
34184d44:	687b      	ldr	r3, [r7, #4]
34184d46:	695a      	ldr	r2, [r3, #20]
34184d48:	4b97      	ldr	r3, [pc, #604]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184d4a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184d4c:	f003 0370 	and.w	r3, r3, #112	@ 0x70
34184d50:	429a      	cmp	r2, r3
34184d52:	d908      	bls.n	34184d66 <HAL_RCC_ClockConfig+0x6e>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
34184d54:	4b94      	ldr	r3, [pc, #592]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184d56:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184d58:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
34184d5c:	687b      	ldr	r3, [r7, #4]
34184d5e:	695b      	ldr	r3, [r3, #20]
34184d60:	4991      	ldr	r1, [pc, #580]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184d62:	4313      	orrs	r3, r2
34184d64:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
34184d66:	687b      	ldr	r3, [r7, #4]
34184d68:	681b      	ldr	r3, [r3, #0]
34184d6a:	f003 0320 	and.w	r3, r3, #32
34184d6e:	2b00      	cmp	r3, #0
34184d70:	d010      	beq.n	34184d94 <HAL_RCC_ClockConfig+0x9c>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE4))
34184d72:	687b      	ldr	r3, [r7, #4]
34184d74:	699a      	ldr	r2, [r3, #24]
34184d76:	4b8c      	ldr	r3, [pc, #560]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184d78:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184d7a:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
34184d7e:	429a      	cmp	r2, r3
34184d80:	d908      	bls.n	34184d94 <HAL_RCC_ClockConfig+0x9c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
34184d82:	4b89      	ldr	r3, [pc, #548]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184d84:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184d86:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
34184d8a:	687b      	ldr	r3, [r7, #4]
34184d8c:	699b      	ldr	r3, [r3, #24]
34184d8e:	4986      	ldr	r1, [pc, #536]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184d90:	4313      	orrs	r3, r2
34184d92:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
34184d94:	687b      	ldr	r3, [r7, #4]
34184d96:	681b      	ldr	r3, [r3, #0]
34184d98:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34184d9c:	2b00      	cmp	r3, #0
34184d9e:	d010      	beq.n	34184dc2 <HAL_RCC_ClockConfig+0xca>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE5))
34184da0:	687b      	ldr	r3, [r7, #4]
34184da2:	69da      	ldr	r2, [r3, #28]
34184da4:	4b80      	ldr	r3, [pc, #512]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184da6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184da8:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
34184dac:	429a      	cmp	r2, r3
34184dae:	d908      	bls.n	34184dc2 <HAL_RCC_ClockConfig+0xca>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
34184db0:	4b7d      	ldr	r3, [pc, #500]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184db2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184db4:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34184db8:	687b      	ldr	r3, [r7, #4]
34184dba:	69db      	ldr	r3, [r3, #28]
34184dbc:	497a      	ldr	r1, [pc, #488]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184dbe:	4313      	orrs	r3, r2
34184dc0:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
34184dc2:	687b      	ldr	r3, [r7, #4]
34184dc4:	681b      	ldr	r3, [r3, #0]
34184dc6:	f003 0304 	and.w	r3, r3, #4
34184dca:	2b00      	cmp	r3, #0
34184dcc:	d010      	beq.n	34184df0 <HAL_RCC_ClockConfig+0xf8>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
34184dce:	687b      	ldr	r3, [r7, #4]
34184dd0:	68da      	ldr	r2, [r3, #12]
34184dd2:	4b75      	ldr	r3, [pc, #468]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184dd4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184dd6:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
34184dda:	429a      	cmp	r2, r3
34184ddc:	d908      	bls.n	34184df0 <HAL_RCC_ClockConfig+0xf8>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
34184dde:	4b72      	ldr	r3, [pc, #456]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184de0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184de2:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
34184de6:	687b      	ldr	r3, [r7, #4]
34184de8:	68db      	ldr	r3, [r3, #12]
34184dea:	496f      	ldr	r1, [pc, #444]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184dec:	4313      	orrs	r3, r2
34184dee:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*------------------------- CPUCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_CPUCLK) == RCC_CLOCKTYPE_CPUCLK)
34184df0:	687b      	ldr	r3, [r7, #4]
34184df2:	681b      	ldr	r3, [r3, #0]
34184df4:	f003 0301 	and.w	r3, r3, #1
34184df8:	2b00      	cmp	r3, #0
34184dfa:	d063      	beq.n	34184ec4 <HAL_RCC_ClockConfig+0x1cc>
  {
    assert_param(IS_RCC_CPUCLKSOURCE(pRCC_ClkInitStruct->CPUCLKSource));

    /* HSE is selected as CPU Clock Source */
    if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_HSE)
34184dfc:	687b      	ldr	r3, [r7, #4]
34184dfe:	685b      	ldr	r3, [r3, #4]
34184e00:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34184e04:	d106      	bne.n	34184e14 <HAL_RCC_ClockConfig+0x11c>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
34184e06:	f7ff f92d 	bl	34184064 <LL_RCC_HSE_IsReady>
34184e0a:	4603      	mov	r3, r0
34184e0c:	2b00      	cmp	r3, #0
34184e0e:	d134      	bne.n	34184e7a <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
34184e10:	2301      	movs	r3, #1
34184e12:	e16d      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_IC1)
34184e14:	687b      	ldr	r3, [r7, #4]
34184e16:	685b      	ldr	r3, [r3, #4]
34184e18:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34184e1c:	d11a      	bne.n	34184e54 <HAL_RCC_ClockConfig+0x15c>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC1Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC1Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC1 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC1_GetSource(), pRCC_ClkInitStruct->IC1Selection.ClockSelection) != 1U)
34184e1e:	f7ff fb43 	bl	341844a8 <LL_RCC_IC1_GetSource>
34184e22:	4602      	mov	r2, r0
34184e24:	687b      	ldr	r3, [r7, #4]
34184e26:	6a1b      	ldr	r3, [r3, #32]
34184e28:	4619      	mov	r1, r3
34184e2a:	4610      	mov	r0, r2
34184e2c:	f000 fc6c 	bl	34185708 <RCC_IC_CheckPLLSources>
34184e30:	4603      	mov	r3, r0
34184e32:	2b01      	cmp	r3, #1
34184e34:	d001      	beq.n	34184e3a <HAL_RCC_ClockConfig+0x142>
      {
        return HAL_ERROR;
34184e36:	2301      	movs	r3, #1
34184e38:	e15a      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC1 source and divider */
      WRITE_REG(RCC->IC1CFGR, pRCC_ClkInitStruct->IC1Selection.ClockSelection | \
34184e3a:	687b      	ldr	r3, [r7, #4]
34184e3c:	6a1a      	ldr	r2, [r3, #32]
34184e3e:	687b      	ldr	r3, [r7, #4]
34184e40:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184e42:	3b01      	subs	r3, #1
34184e44:	041b      	lsls	r3, r3, #16
34184e46:	4958      	ldr	r1, [pc, #352]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184e48:	4313      	orrs	r3, r2
34184e4a:	f8c1 30c4 	str.w	r3, [r1, #196]	@ 0xc4
                ((pRCC_ClkInitStruct->IC1Selection.ClockDivider - 1U) << RCC_IC1CFGR_IC1INT_Pos));

      /* Enable IC1 */
      LL_RCC_IC1_Enable();
34184e4e:	f7ff fb1d 	bl	3418448c <LL_RCC_IC1_Enable>
34184e52:	e012      	b.n	34184e7a <HAL_RCC_ClockConfig+0x182>
    }
    /* MSI is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_MSI)
34184e54:	687b      	ldr	r3, [r7, #4]
34184e56:	685b      	ldr	r3, [r3, #4]
34184e58:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34184e5c:	d106      	bne.n	34184e6c <HAL_RCC_ClockConfig+0x174>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
34184e5e:	f7ff f999 	bl	34184194 <LL_RCC_MSI_IsReady>
34184e62:	4603      	mov	r3, r0
34184e64:	2b00      	cmp	r3, #0
34184e66:	d108      	bne.n	34184e7a <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
34184e68:	2301      	movs	r3, #1
34184e6a:	e141      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
    }
    /* HSI is selected as CPU Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
34184e6c:	f7ff f92a 	bl	341840c4 <LL_RCC_HSI_IsReady>
34184e70:	4603      	mov	r3, r0
34184e72:	2b00      	cmp	r3, #0
34184e74:	d101      	bne.n	34184e7a <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
34184e76:	2301      	movs	r3, #1
34184e78:	e13a      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the CPU clock */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
34184e7a:	4b4b      	ldr	r3, [pc, #300]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184e7c:	6a1b      	ldr	r3, [r3, #32]
34184e7e:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
34184e82:	687b      	ldr	r3, [r7, #4]
34184e84:	685b      	ldr	r3, [r3, #4]
34184e86:	4948      	ldr	r1, [pc, #288]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184e88:	4313      	orrs	r3, r2
34184e8a:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34184e8c:	f7fd f9ce 	bl	3418222c <HAL_GetTick>
34184e90:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
34184e92:	e00a      	b.n	34184eaa <HAL_RCC_ClockConfig+0x1b2>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34184e94:	f7fd f9ca 	bl	3418222c <HAL_GetTick>
34184e98:	4602      	mov	r2, r0
34184e9a:	68fb      	ldr	r3, [r7, #12]
34184e9c:	1ad3      	subs	r3, r2, r3
34184e9e:	f241 3288 	movw	r2, #5000	@ 0x1388
34184ea2:	4293      	cmp	r3, r2
34184ea4:	d901      	bls.n	34184eaa <HAL_RCC_ClockConfig+0x1b2>
      {
        return HAL_TIMEOUT;
34184ea6:	2303      	movs	r3, #3
34184ea8:	e122      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
34184eaa:	f7ff f9fb 	bl	341842a4 <LL_RCC_GetCpuClkSource>
34184eae:	4602      	mov	r2, r0
34184eb0:	687b      	ldr	r3, [r7, #4]
34184eb2:	685b      	ldr	r3, [r3, #4]
34184eb4:	011b      	lsls	r3, r3, #4
34184eb6:	429a      	cmp	r2, r3
34184eb8:	d1ec      	bne.n	34184e94 <HAL_RCC_ClockConfig+0x19c>
      }
    }

    /* Update the SystemCoreClock global variable with CPU clock */
    SystemCoreClock = HAL_RCC_GetCpuClockFreq();
34184eba:	f000 f921 	bl	34185100 <HAL_RCC_GetCpuClockFreq>
34184ebe:	4603      	mov	r3, r0
34184ec0:	4a3a      	ldr	r2, [pc, #232]	@ (34184fac <HAL_RCC_ClockConfig+0x2b4>)
34184ec2:	6013      	str	r3, [r2, #0]

  }

  /*------------------------- SYSCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
34184ec4:	687b      	ldr	r3, [r7, #4]
34184ec6:	681b      	ldr	r3, [r3, #0]
34184ec8:	f003 0302 	and.w	r3, r3, #2
34184ecc:	2b00      	cmp	r3, #0
34184ece:	f000 8096 	beq.w	34184ffe <HAL_RCC_ClockConfig+0x306>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System bus clock source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
34184ed2:	687b      	ldr	r3, [r7, #4]
34184ed4:	689b      	ldr	r3, [r3, #8]
34184ed6:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34184eda:	d106      	bne.n	34184eea <HAL_RCC_ClockConfig+0x1f2>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
34184edc:	f7ff f8c2 	bl	34184064 <LL_RCC_HSE_IsReady>
34184ee0:	4603      	mov	r3, r0
34184ee2:	2b00      	cmp	r3, #0
34184ee4:	d16b      	bne.n	34184fbe <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
34184ee6:	2301      	movs	r3, #1
34184ee8:	e102      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL output is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11)
34184eea:	687b      	ldr	r3, [r7, #4]
34184eec:	689b      	ldr	r3, [r3, #8]
34184eee:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34184ef2:	d14d      	bne.n	34184f90 <HAL_RCC_ClockConfig+0x298>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC11Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC11Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC2/IC6/IC11 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC2_GetSource(), pRCC_ClkInitStruct->IC2Selection.ClockSelection) != 1U)
34184ef4:	f7ff faf6 	bl	341844e4 <LL_RCC_IC2_GetSource>
34184ef8:	4602      	mov	r2, r0
34184efa:	687b      	ldr	r3, [r7, #4]
34184efc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34184efe:	4619      	mov	r1, r3
34184f00:	4610      	mov	r0, r2
34184f02:	f000 fc01 	bl	34185708 <RCC_IC_CheckPLLSources>
34184f06:	4603      	mov	r3, r0
34184f08:	2b01      	cmp	r3, #1
34184f0a:	d001      	beq.n	34184f10 <HAL_RCC_ClockConfig+0x218>
      {
        return HAL_ERROR;
34184f0c:	2301      	movs	r3, #1
34184f0e:	e0ef      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC6_GetSource(), pRCC_ClkInitStruct->IC6Selection.ClockSelection) != 1U)
34184f10:	f7ff faf6 	bl	34184500 <LL_RCC_IC6_GetSource>
34184f14:	4602      	mov	r2, r0
34184f16:	687b      	ldr	r3, [r7, #4]
34184f18:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34184f1a:	4619      	mov	r1, r3
34184f1c:	4610      	mov	r0, r2
34184f1e:	f000 fbf3 	bl	34185708 <RCC_IC_CheckPLLSources>
34184f22:	4603      	mov	r3, r0
34184f24:	2b01      	cmp	r3, #1
34184f26:	d001      	beq.n	34184f2c <HAL_RCC_ClockConfig+0x234>
      {
        return HAL_ERROR;
34184f28:	2301      	movs	r3, #1
34184f2a:	e0e1      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC11_GetSource(), pRCC_ClkInitStruct->IC11Selection.ClockSelection) != 1U)
34184f2c:	f7ff faf6 	bl	3418451c <LL_RCC_IC11_GetSource>
34184f30:	4602      	mov	r2, r0
34184f32:	687b      	ldr	r3, [r7, #4]
34184f34:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34184f36:	4619      	mov	r1, r3
34184f38:	4610      	mov	r0, r2
34184f3a:	f000 fbe5 	bl	34185708 <RCC_IC_CheckPLLSources>
34184f3e:	4603      	mov	r3, r0
34184f40:	2b01      	cmp	r3, #1
34184f42:	d001      	beq.n	34184f48 <HAL_RCC_ClockConfig+0x250>
      {
        return HAL_ERROR;
34184f44:	2301      	movs	r3, #1
34184f46:	e0d3      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC2, IC6 and IC11 sources and dividers */
      WRITE_REG(RCC->IC2CFGR, pRCC_ClkInitStruct->IC2Selection.ClockSelection | \
34184f48:	687b      	ldr	r3, [r7, #4]
34184f4a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34184f4c:	687b      	ldr	r3, [r7, #4]
34184f4e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34184f50:	3b01      	subs	r3, #1
34184f52:	041b      	lsls	r3, r3, #16
34184f54:	4914      	ldr	r1, [pc, #80]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184f56:	4313      	orrs	r3, r2
34184f58:	f8c1 30c8 	str.w	r3, [r1, #200]	@ 0xc8
                ((pRCC_ClkInitStruct->IC2Selection.ClockDivider - 1U) << RCC_IC2CFGR_IC2INT_Pos));
      WRITE_REG(RCC->IC6CFGR, pRCC_ClkInitStruct->IC6Selection.ClockSelection | \
34184f5c:	687b      	ldr	r3, [r7, #4]
34184f5e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
34184f60:	687b      	ldr	r3, [r7, #4]
34184f62:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34184f64:	3b01      	subs	r3, #1
34184f66:	041b      	lsls	r3, r3, #16
34184f68:	490f      	ldr	r1, [pc, #60]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184f6a:	4313      	orrs	r3, r2
34184f6c:	f8c1 30d8 	str.w	r3, [r1, #216]	@ 0xd8
                ((pRCC_ClkInitStruct->IC6Selection.ClockDivider - 1U) << RCC_IC6CFGR_IC6INT_Pos));
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
34184f70:	687b      	ldr	r3, [r7, #4]
34184f72:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34184f74:	687b      	ldr	r3, [r7, #4]
34184f76:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34184f78:	3b01      	subs	r3, #1
34184f7a:	041b      	lsls	r3, r3, #16
34184f7c:	490a      	ldr	r1, [pc, #40]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184f7e:	4313      	orrs	r3, r2
34184f80:	f8c1 30ec 	str.w	r3, [r1, #236]	@ 0xec
                ((pRCC_ClkInitStruct->IC11Selection.ClockDivider - 1U) << RCC_IC11CFGR_IC11INT_Pos));

      /* Require to have IC2, IC6 and IC11 outputs enabled */
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
34184f84:	4b08      	ldr	r3, [pc, #32]	@ (34184fa8 <HAL_RCC_ClockConfig+0x2b0>)
34184f86:	f240 4222 	movw	r2, #1058	@ 0x422
34184f8a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
34184f8e:	e016      	b.n	34184fbe <HAL_RCC_ClockConfig+0x2c6>
    }
    /* HSI is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
34184f90:	687b      	ldr	r3, [r7, #4]
34184f92:	689b      	ldr	r3, [r3, #8]
34184f94:	2b00      	cmp	r3, #0
34184f96:	d10b      	bne.n	34184fb0 <HAL_RCC_ClockConfig+0x2b8>
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
34184f98:	f7ff f894 	bl	341840c4 <LL_RCC_HSI_IsReady>
34184f9c:	4603      	mov	r3, r0
34184f9e:	2b00      	cmp	r3, #0
34184fa0:	d10d      	bne.n	34184fbe <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
34184fa2:	2301      	movs	r3, #1
34184fa4:	e0a4      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
34184fa6:	bf00      	nop
34184fa8:	56028000 	.word	0x56028000
34184fac:	341c0008 	.word	0x341c0008
    }
    /* MSI is selected as System bus clock source */
    else
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
34184fb0:	f7ff f8f0 	bl	34184194 <LL_RCC_MSI_IsReady>
34184fb4:	4603      	mov	r3, r0
34184fb6:	2b00      	cmp	r3, #0
34184fb8:	d101      	bne.n	34184fbe <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
34184fba:	2301      	movs	r3, #1
34184fbc:	e098      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the system bus clocks */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
34184fbe:	4b4e      	ldr	r3, [pc, #312]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
34184fc0:	6a1b      	ldr	r3, [r3, #32]
34184fc2:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34184fc6:	687b      	ldr	r3, [r7, #4]
34184fc8:	689b      	ldr	r3, [r3, #8]
34184fca:	494b      	ldr	r1, [pc, #300]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
34184fcc:	4313      	orrs	r3, r2
34184fce:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34184fd0:	f7fd f92c 	bl	3418222c <HAL_GetTick>
34184fd4:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
34184fd6:	e00a      	b.n	34184fee <HAL_RCC_ClockConfig+0x2f6>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34184fd8:	f7fd f928 	bl	3418222c <HAL_GetTick>
34184fdc:	4602      	mov	r2, r0
34184fde:	68fb      	ldr	r3, [r7, #12]
34184fe0:	1ad3      	subs	r3, r2, r3
34184fe2:	f241 3288 	movw	r2, #5000	@ 0x1388
34184fe6:	4293      	cmp	r3, r2
34184fe8:	d901      	bls.n	34184fee <HAL_RCC_ClockConfig+0x2f6>
      {
        return HAL_TIMEOUT;
34184fea:	2303      	movs	r3, #3
34184fec:	e080      	b.n	341850f0 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
34184fee:	f7ff f967 	bl	341842c0 <LL_RCC_GetSysClkSource>
34184ff2:	4602      	mov	r2, r0
34184ff4:	687b      	ldr	r3, [r7, #4]
34184ff6:	689b      	ldr	r3, [r3, #8]
34184ff8:	011b      	lsls	r3, r3, #4
34184ffa:	429a      	cmp	r2, r3
34184ffc:	d1ec      	bne.n	34184fd8 <HAL_RCC_ClockConfig+0x2e0>
  }

  /* Decreasing the BUS frequency divider ? */

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
34184ffe:	687b      	ldr	r3, [r7, #4]
34185000:	681b      	ldr	r3, [r3, #0]
34185002:	f003 0304 	and.w	r3, r3, #4
34185006:	2b00      	cmp	r3, #0
34185008:	d010      	beq.n	3418502c <HAL_RCC_ClockConfig+0x334>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
3418500a:	687b      	ldr	r3, [r7, #4]
3418500c:	68da      	ldr	r2, [r3, #12]
3418500e:	4b3a      	ldr	r3, [pc, #232]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
34185010:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34185012:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
34185016:	429a      	cmp	r2, r3
34185018:	d208      	bcs.n	3418502c <HAL_RCC_ClockConfig+0x334>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3418501a:	4b37      	ldr	r3, [pc, #220]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
3418501c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418501e:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
34185022:	687b      	ldr	r3, [r7, #4]
34185024:	68db      	ldr	r3, [r3, #12]
34185026:	4934      	ldr	r1, [pc, #208]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
34185028:	4313      	orrs	r3, r2
3418502a:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3418502c:	687b      	ldr	r3, [r7, #4]
3418502e:	681b      	ldr	r3, [r3, #0]
34185030:	f003 0308 	and.w	r3, r3, #8
34185034:	2b00      	cmp	r3, #0
34185036:	d010      	beq.n	3418505a <HAL_RCC_ClockConfig+0x362>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
34185038:	687b      	ldr	r3, [r7, #4]
3418503a:	691a      	ldr	r2, [r3, #16]
3418503c:	4b2e      	ldr	r3, [pc, #184]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
3418503e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34185040:	f003 0307 	and.w	r3, r3, #7
34185044:	429a      	cmp	r2, r3
34185046:	d208      	bcs.n	3418505a <HAL_RCC_ClockConfig+0x362>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
34185048:	4b2b      	ldr	r3, [pc, #172]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
3418504a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418504c:	f023 0207 	bic.w	r2, r3, #7
34185050:	687b      	ldr	r3, [r7, #4]
34185052:	691b      	ldr	r3, [r3, #16]
34185054:	4928      	ldr	r1, [pc, #160]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
34185056:	4313      	orrs	r3, r2
34185058:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3418505a:	687b      	ldr	r3, [r7, #4]
3418505c:	681b      	ldr	r3, [r3, #0]
3418505e:	f003 0310 	and.w	r3, r3, #16
34185062:	2b00      	cmp	r3, #0
34185064:	d010      	beq.n	34185088 <HAL_RCC_ClockConfig+0x390>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE2))
34185066:	687b      	ldr	r3, [r7, #4]
34185068:	695a      	ldr	r2, [r3, #20]
3418506a:	4b23      	ldr	r3, [pc, #140]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
3418506c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418506e:	f003 0370 	and.w	r3, r3, #112	@ 0x70
34185072:	429a      	cmp	r2, r3
34185074:	d208      	bcs.n	34185088 <HAL_RCC_ClockConfig+0x390>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
34185076:	4b20      	ldr	r3, [pc, #128]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
34185078:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418507a:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
3418507e:	687b      	ldr	r3, [r7, #4]
34185080:	695b      	ldr	r3, [r3, #20]
34185082:	491d      	ldr	r1, [pc, #116]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
34185084:	4313      	orrs	r3, r2
34185086:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
34185088:	687b      	ldr	r3, [r7, #4]
3418508a:	681b      	ldr	r3, [r3, #0]
3418508c:	f003 0320 	and.w	r3, r3, #32
34185090:	2b00      	cmp	r3, #0
34185092:	d010      	beq.n	341850b6 <HAL_RCC_ClockConfig+0x3be>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE4))
34185094:	687b      	ldr	r3, [r7, #4]
34185096:	699a      	ldr	r2, [r3, #24]
34185098:	4b17      	ldr	r3, [pc, #92]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
3418509a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418509c:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
341850a0:	429a      	cmp	r2, r3
341850a2:	d208      	bcs.n	341850b6 <HAL_RCC_ClockConfig+0x3be>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
341850a4:	4b14      	ldr	r3, [pc, #80]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
341850a6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341850a8:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
341850ac:	687b      	ldr	r3, [r7, #4]
341850ae:	699b      	ldr	r3, [r3, #24]
341850b0:	4911      	ldr	r1, [pc, #68]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
341850b2:	4313      	orrs	r3, r2
341850b4:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
341850b6:	687b      	ldr	r3, [r7, #4]
341850b8:	681b      	ldr	r3, [r3, #0]
341850ba:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341850be:	2b00      	cmp	r3, #0
341850c0:	d010      	beq.n	341850e4 <HAL_RCC_ClockConfig+0x3ec>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE5))
341850c2:	687b      	ldr	r3, [r7, #4]
341850c4:	69da      	ldr	r2, [r3, #28]
341850c6:	4b0c      	ldr	r3, [pc, #48]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
341850c8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341850ca:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
341850ce:	429a      	cmp	r2, r3
341850d0:	d208      	bcs.n	341850e4 <HAL_RCC_ClockConfig+0x3ec>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
341850d2:	4b09      	ldr	r3, [pc, #36]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
341850d4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341850d6:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
341850da:	687b      	ldr	r3, [r7, #4]
341850dc:	69db      	ldr	r3, [r3, #28]
341850de:	4906      	ldr	r1, [pc, #24]	@ (341850f8 <HAL_RCC_ClockConfig+0x400>)
341850e0:	4313      	orrs	r3, r2
341850e2:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(uwTickPrio);
341850e4:	4b05      	ldr	r3, [pc, #20]	@ (341850fc <HAL_RCC_ClockConfig+0x404>)
341850e6:	681b      	ldr	r3, [r3, #0]
341850e8:	4618      	mov	r0, r3
341850ea:	f7fd f855 	bl	34182198 <HAL_InitTick>
341850ee:	4603      	mov	r3, r0
}
341850f0:	4618      	mov	r0, r3
341850f2:	3710      	adds	r7, #16
341850f4:	46bd      	mov	sp, r7
341850f6:	bd80      	pop	{r7, pc}
341850f8:	56028000 	.word	0x56028000
341850fc:	341c000c 	.word	0x341c000c

34185100 <HAL_RCC_GetCpuClockFreq>:
  *         will be incorrect.
  *
  * @retval CPUCLK frequency
  */
uint32_t HAL_RCC_GetCpuClockFreq(void)
{
34185100:	b580      	push	{r7, lr}
34185102:	b082      	sub	sp, #8
34185104:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
34185106:	2300      	movs	r3, #0
34185108:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetCpuClkSource())
3418510a:	f7ff f8cb 	bl	341842a4 <LL_RCC_GetCpuClkSource>
3418510e:	4603      	mov	r3, r0
34185110:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34185114:	d025      	beq.n	34185162 <HAL_RCC_GetCpuClockFreq+0x62>
34185116:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418511a:	d860      	bhi.n	341851de <HAL_RCC_GetCpuClockFreq+0xde>
3418511c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34185120:	d01c      	beq.n	3418515c <HAL_RCC_GetCpuClockFreq+0x5c>
34185122:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34185126:	d85a      	bhi.n	341851de <HAL_RCC_GetCpuClockFreq+0xde>
34185128:	2b00      	cmp	r3, #0
3418512a:	d003      	beq.n	34185134 <HAL_RCC_GetCpuClockFreq+0x34>
3418512c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34185130:	d009      	beq.n	34185146 <HAL_RCC_GetCpuClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
34185132:	e054      	b.n	341851de <HAL_RCC_GetCpuClockFreq+0xde>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34185134:	f7fe ffec 	bl	34184110 <LL_RCC_HSI_GetDivider>
34185138:	4603      	mov	r3, r0
3418513a:	09db      	lsrs	r3, r3, #7
3418513c:	4a2b      	ldr	r2, [pc, #172]	@ (341851ec <HAL_RCC_GetCpuClockFreq+0xec>)
3418513e:	fa22 f303 	lsr.w	r3, r2, r3
34185142:	607b      	str	r3, [r7, #4]
      break;
34185144:	e04c      	b.n	341851e0 <HAL_RCC_GetCpuClockFreq+0xe0>
      if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
34185146:	f7ff f84b 	bl	341841e0 <LL_RCC_MSI_GetFrequency>
3418514a:	4603      	mov	r3, r0
3418514c:	2b00      	cmp	r3, #0
3418514e:	d102      	bne.n	34185156 <HAL_RCC_GetCpuClockFreq+0x56>
        frequency = MSI_VALUE;
34185150:	4b27      	ldr	r3, [pc, #156]	@ (341851f0 <HAL_RCC_GetCpuClockFreq+0xf0>)
34185152:	607b      	str	r3, [r7, #4]
      break;
34185154:	e044      	b.n	341851e0 <HAL_RCC_GetCpuClockFreq+0xe0>
        frequency = 16000000UL;
34185156:	4b27      	ldr	r3, [pc, #156]	@ (341851f4 <HAL_RCC_GetCpuClockFreq+0xf4>)
34185158:	607b      	str	r3, [r7, #4]
      break;
3418515a:	e041      	b.n	341851e0 <HAL_RCC_GetCpuClockFreq+0xe0>
      frequency = HSE_VALUE;
3418515c:	4b26      	ldr	r3, [pc, #152]	@ (341851f8 <HAL_RCC_GetCpuClockFreq+0xf8>)
3418515e:	607b      	str	r3, [r7, #4]
      break;
34185160:	e03e      	b.n	341851e0 <HAL_RCC_GetCpuClockFreq+0xe0>
      ic_divider = LL_RCC_IC1_GetDivider();
34185162:	f7ff f9af 	bl	341844c4 <LL_RCC_IC1_GetDivider>
34185166:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC1_GetSource())
34185168:	f7ff f99e 	bl	341844a8 <LL_RCC_IC1_GetSource>
3418516c:	4603      	mov	r3, r0
3418516e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34185172:	d029      	beq.n	341851c8 <HAL_RCC_GetCpuClockFreq+0xc8>
34185174:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34185178:	d82f      	bhi.n	341851da <HAL_RCC_GetCpuClockFreq+0xda>
3418517a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418517e:	d01a      	beq.n	341851b6 <HAL_RCC_GetCpuClockFreq+0xb6>
34185180:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34185184:	d829      	bhi.n	341851da <HAL_RCC_GetCpuClockFreq+0xda>
34185186:	2b00      	cmp	r3, #0
34185188:	d003      	beq.n	34185192 <HAL_RCC_GetCpuClockFreq+0x92>
3418518a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418518e:	d009      	beq.n	341851a4 <HAL_RCC_GetCpuClockFreq+0xa4>
          break;
34185190:	e023      	b.n	341851da <HAL_RCC_GetCpuClockFreq+0xda>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
34185192:	f003 fc45 	bl	34188a20 <HAL_RCCEx_GetPLL1CLKFreq>
34185196:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34185198:	687a      	ldr	r2, [r7, #4]
3418519a:	683b      	ldr	r3, [r7, #0]
3418519c:	fbb2 f3f3 	udiv	r3, r2, r3
341851a0:	607b      	str	r3, [r7, #4]
          break;
341851a2:	e01b      	b.n	341851dc <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
341851a4:	f003 fc82 	bl	34188aac <HAL_RCCEx_GetPLL2CLKFreq>
341851a8:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
341851aa:	687a      	ldr	r2, [r7, #4]
341851ac:	683b      	ldr	r3, [r7, #0]
341851ae:	fbb2 f3f3 	udiv	r3, r2, r3
341851b2:	607b      	str	r3, [r7, #4]
          break;
341851b4:	e012      	b.n	341851dc <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
341851b6:	f003 fcbf 	bl	34188b38 <HAL_RCCEx_GetPLL3CLKFreq>
341851ba:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
341851bc:	687a      	ldr	r2, [r7, #4]
341851be:	683b      	ldr	r3, [r7, #0]
341851c0:	fbb2 f3f3 	udiv	r3, r2, r3
341851c4:	607b      	str	r3, [r7, #4]
          break;
341851c6:	e009      	b.n	341851dc <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
341851c8:	f003 fcfc 	bl	34188bc4 <HAL_RCCEx_GetPLL4CLKFreq>
341851cc:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
341851ce:	687a      	ldr	r2, [r7, #4]
341851d0:	683b      	ldr	r3, [r7, #0]
341851d2:	fbb2 f3f3 	udiv	r3, r2, r3
341851d6:	607b      	str	r3, [r7, #4]
          break;
341851d8:	e000      	b.n	341851dc <HAL_RCC_GetCpuClockFreq+0xdc>
          break;
341851da:	bf00      	nop
      break;
341851dc:	e000      	b.n	341851e0 <HAL_RCC_GetCpuClockFreq+0xe0>
      break;
341851de:	bf00      	nop
  }

  return frequency;
341851e0:	687b      	ldr	r3, [r7, #4]
}
341851e2:	4618      	mov	r0, r3
341851e4:	3708      	adds	r7, #8
341851e6:	46bd      	mov	sp, r7
341851e8:	bd80      	pop	{r7, pc}
341851ea:	bf00      	nop
341851ec:	03d09000 	.word	0x03d09000
341851f0:	003d0900 	.word	0x003d0900
341851f4:	00f42400 	.word	0x00f42400
341851f8:	02dc6c00 	.word	0x02dc6c00

341851fc <HAL_RCC_GetClockConfig>:
  * @param  pRCC_ClkInitStruct  Pointer to an RCC_ClkInitTypeDef structure that
  *         will return the configuration.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
341851fc:	b480      	push	{r7}
341851fe:	b085      	sub	sp, #20
34185200:	af00      	add	r7, sp, #0
34185202:	6078      	str	r0, [r7, #4]
  uint32_t cfgr_value;

  /* Set all possible values for the Clock type parameter --------------------*/
  pRCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK | \
34185204:	687b      	ldr	r3, [r7, #4]
34185206:	227f      	movs	r2, #127	@ 0x7f
34185208:	601a      	str	r2, [r3, #0]
                                  RCC_CLOCKTYPE_HCLK   | \
                                  RCC_CLOCKTYPE_PCLK1  | RCC_CLOCKTYPE_PCLK2 | \
                                  RCC_CLOCKTYPE_PCLK4  | RCC_CLOCKTYPE_PCLK5;

  /* Get the configuration register 1 value */
  cfgr_value = RCC->CFGR1;
3418520a:	4b36      	ldr	r3, [pc, #216]	@ (341852e4 <HAL_RCC_GetClockConfig+0xe8>)
3418520c:	6a1b      	ldr	r3, [r3, #32]
3418520e:	60fb      	str	r3, [r7, #12]

  /* Get the active CPU source -----------------------------------------------*/
  pRCC_ClkInitStruct->CPUCLKSource = (cfgr_value & RCC_CFGR1_CPUSWS) >> 4U;
34185210:	68fb      	ldr	r3, [r7, #12]
34185212:	091b      	lsrs	r3, r3, #4
34185214:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
34185218:	687b      	ldr	r3, [r7, #4]
3418521a:	605a      	str	r2, [r3, #4]

  /* Get the active SYSCLK bus source ----------------------------------------*/
  pRCC_ClkInitStruct->SYSCLKSource = (cfgr_value & RCC_CFGR1_SYSSWS) >> 4U;
3418521c:	68fb      	ldr	r3, [r7, #12]
3418521e:	091b      	lsrs	r3, r3, #4
34185220:	f003 7240 	and.w	r2, r3, #50331648	@ 0x3000000
34185224:	687b      	ldr	r3, [r7, #4]
34185226:	609a      	str	r2, [r3, #8]

  /* Get the configuration register 2 value */
  cfgr_value = RCC->CFGR2;
34185228:	4b2e      	ldr	r3, [pc, #184]	@ (341852e4 <HAL_RCC_GetClockConfig+0xe8>)
3418522a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418522c:	60fb      	str	r3, [r7, #12]

  /* Get the HCLK configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->AHBCLKDivider = (cfgr_value & RCC_CFGR2_HPRE);
3418522e:	68fb      	ldr	r3, [r7, #12]
34185230:	f403 02e0 	and.w	r2, r3, #7340032	@ 0x700000
34185234:	687b      	ldr	r3, [r7, #4]
34185236:	60da      	str	r2, [r3, #12]

  /* Get the APB1 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB1CLKDivider = (cfgr_value & RCC_CFGR2_PPRE1);
34185238:	68fb      	ldr	r3, [r7, #12]
3418523a:	f003 0207 	and.w	r2, r3, #7
3418523e:	687b      	ldr	r3, [r7, #4]
34185240:	611a      	str	r2, [r3, #16]

  /* Get the APB2 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB2CLKDivider = (cfgr_value & RCC_CFGR2_PPRE2);
34185242:	68fb      	ldr	r3, [r7, #12]
34185244:	f003 0270 	and.w	r2, r3, #112	@ 0x70
34185248:	687b      	ldr	r3, [r7, #4]
3418524a:	615a      	str	r2, [r3, #20]

  /* Get the APB4 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB4CLKDivider = (cfgr_value & RCC_CFGR2_PPRE4);
3418524c:	68fb      	ldr	r3, [r7, #12]
3418524e:	f403 42e0 	and.w	r2, r3, #28672	@ 0x7000
34185252:	687b      	ldr	r3, [r7, #4]
34185254:	619a      	str	r2, [r3, #24]

  /* Get the APB5 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB5CLKDivider = (cfgr_value & RCC_CFGR2_PPRE5);
34185256:	68fb      	ldr	r3, [r7, #12]
34185258:	f403 22e0 	and.w	r2, r3, #458752	@ 0x70000
3418525c:	687b      	ldr	r3, [r7, #4]
3418525e:	61da      	str	r2, [r3, #28]

  /* Get the IC1 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC1CFGR;
34185260:	4b20      	ldr	r3, [pc, #128]	@ (341852e4 <HAL_RCC_GetClockConfig+0xe8>)
34185262:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34185266:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC1Selection.ClockSelection = cfgr_value & RCC_IC1CFGR_IC1SEL;
34185268:	68fb      	ldr	r3, [r7, #12]
3418526a:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418526e:	687b      	ldr	r3, [r7, #4]
34185270:	621a      	str	r2, [r3, #32]
  pRCC_ClkInitStruct->IC1Selection.ClockDivider = ((cfgr_value & RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1U;
34185272:	68fb      	ldr	r3, [r7, #12]
34185274:	0c1b      	lsrs	r3, r3, #16
34185276:	b2db      	uxtb	r3, r3
34185278:	1c5a      	adds	r2, r3, #1
3418527a:	687b      	ldr	r3, [r7, #4]
3418527c:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Get the IC2 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC2CFGR;
3418527e:	4b19      	ldr	r3, [pc, #100]	@ (341852e4 <HAL_RCC_GetClockConfig+0xe8>)
34185280:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34185284:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC2Selection.ClockSelection = cfgr_value & RCC_IC2CFGR_IC2SEL;
34185286:	68fb      	ldr	r3, [r7, #12]
34185288:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418528c:	687b      	ldr	r3, [r7, #4]
3418528e:	629a      	str	r2, [r3, #40]	@ 0x28
  pRCC_ClkInitStruct->IC2Selection.ClockDivider = ((cfgr_value & RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1U;
34185290:	68fb      	ldr	r3, [r7, #12]
34185292:	0c1b      	lsrs	r3, r3, #16
34185294:	b2db      	uxtb	r3, r3
34185296:	1c5a      	adds	r2, r3, #1
34185298:	687b      	ldr	r3, [r7, #4]
3418529a:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Get the IC6 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC6CFGR;
3418529c:	4b11      	ldr	r3, [pc, #68]	@ (341852e4 <HAL_RCC_GetClockConfig+0xe8>)
3418529e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
341852a2:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC6Selection.ClockSelection = cfgr_value & RCC_IC6CFGR_IC6SEL;
341852a4:	68fb      	ldr	r3, [r7, #12]
341852a6:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
341852aa:	687b      	ldr	r3, [r7, #4]
341852ac:	631a      	str	r2, [r3, #48]	@ 0x30
  pRCC_ClkInitStruct->IC6Selection.ClockDivider = ((cfgr_value & RCC_IC6CFGR_IC6INT) >> RCC_IC6CFGR_IC6INT_Pos) + 1U;
341852ae:	68fb      	ldr	r3, [r7, #12]
341852b0:	0c1b      	lsrs	r3, r3, #16
341852b2:	b2db      	uxtb	r3, r3
341852b4:	1c5a      	adds	r2, r3, #1
341852b6:	687b      	ldr	r3, [r7, #4]
341852b8:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Get the IC11 configuration ----------------------------------------------*/
  cfgr_value = RCC->IC11CFGR;
341852ba:	4b0a      	ldr	r3, [pc, #40]	@ (341852e4 <HAL_RCC_GetClockConfig+0xe8>)
341852bc:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
341852c0:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC11Selection.ClockSelection = cfgr_value & RCC_IC11CFGR_IC11SEL;
341852c2:	68fb      	ldr	r3, [r7, #12]
341852c4:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
341852c8:	687b      	ldr	r3, [r7, #4]
341852ca:	639a      	str	r2, [r3, #56]	@ 0x38
  pRCC_ClkInitStruct->IC11Selection.ClockDivider = ((cfgr_value & RCC_IC11CFGR_IC11INT) >> RCC_IC11CFGR_IC11INT_Pos) + 1U;
341852cc:	68fb      	ldr	r3, [r7, #12]
341852ce:	0c1b      	lsrs	r3, r3, #16
341852d0:	b2db      	uxtb	r3, r3
341852d2:	1c5a      	adds	r2, r3, #1
341852d4:	687b      	ldr	r3, [r7, #4]
341852d6:	63da      	str	r2, [r3, #60]	@ 0x3c
}
341852d8:	bf00      	nop
341852da:	3714      	adds	r7, #20
341852dc:	46bd      	mov	sp, r7
341852de:	f85d 7b04 	ldr.w	r7, [sp], #4
341852e2:	4770      	bx	lr
341852e4:	56028000 	.word	0x56028000

341852e8 <RCC_PLL_Config>:
  * @note   PLL is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Config(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
341852e8:	b580      	push	{r7, lr}
341852ea:	b088      	sub	sp, #32
341852ec:	af00      	add	r7, sp, #0
341852ee:	6078      	str	r0, [r7, #4]
341852f0:	6039      	str	r1, [r7, #0]
  __IO uint32_t *p_rcc_pll_cfgr1_reg;
  __IO uint32_t *p_rcc_pll_cfgr2_reg;
  __IO uint32_t *p_rcc_pll_cfgr3_reg;
  HAL_StatusTypeDef ret = HAL_OK;
341852f2:	2300      	movs	r3, #0
341852f4:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart;

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
341852f6:	687b      	ldr	r3, [r7, #4]
341852f8:	011a      	lsls	r2, r3, #4
341852fa:	4b8e      	ldr	r3, [pc, #568]	@ (34185534 <RCC_PLL_Config+0x24c>)
341852fc:	4413      	add	r3, r2
341852fe:	61bb      	str	r3, [r7, #24]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
34185300:	687b      	ldr	r3, [r7, #4]
34185302:	011a      	lsls	r2, r3, #4
34185304:	4b8c      	ldr	r3, [pc, #560]	@ (34185538 <RCC_PLL_Config+0x250>)
34185306:	4413      	add	r3, r2
34185308:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3418530a:	687b      	ldr	r3, [r7, #4]
3418530c:	011a      	lsls	r2, r3, #4
3418530e:	4b8b      	ldr	r3, [pc, #556]	@ (3418553c <RCC_PLL_Config+0x254>)
34185310:	4413      	add	r3, r2
34185312:	613b      	str	r3, [r7, #16]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */
  if (pPLLInit->PLLState == RCC_PLL_ON)
34185314:	683b      	ldr	r3, [r7, #0]
34185316:	681b      	ldr	r3, [r3, #0]
34185318:	2b02      	cmp	r3, #2
3418531a:	f040 8091 	bne.w	34185440 <RCC_PLL_Config+0x158>
    assert_param(IS_RCC_PLLN_VALUE(pPLLInit->PLLN));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP1));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP2));

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3418531e:	4a88      	ldr	r2, [pc, #544]	@ (34185540 <RCC_PLL_Config+0x258>)
34185320:	f44f 7180 	mov.w	r1, #256	@ 0x100
34185324:	687b      	ldr	r3, [r7, #4]
34185326:	fa01 f303 	lsl.w	r3, r1, r3
3418532a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418532e:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34185330:	f7fc ff7c 	bl	3418222c <HAL_GetTick>
34185334:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34185336:	e008      	b.n	3418534a <RCC_PLL_Config+0x62>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34185338:	f7fc ff78 	bl	3418222c <HAL_GetTick>
3418533c:	4602      	mov	r2, r0
3418533e:	68fb      	ldr	r3, [r7, #12]
34185340:	1ad3      	subs	r3, r2, r3
34185342:	2b01      	cmp	r3, #1
34185344:	d901      	bls.n	3418534a <RCC_PLL_Config+0x62>
      {
        return HAL_TIMEOUT;
34185346:	2303      	movs	r3, #3
34185348:	e0f0      	b.n	3418552c <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418534a:	4b7d      	ldr	r3, [pc, #500]	@ (34185540 <RCC_PLL_Config+0x258>)
3418534c:	685a      	ldr	r2, [r3, #4]
3418534e:	f44f 7180 	mov.w	r1, #256	@ 0x100
34185352:	687b      	ldr	r3, [r7, #4]
34185354:	fa01 f303 	lsl.w	r3, r1, r3
34185358:	401a      	ands	r2, r3
3418535a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418535e:	687b      	ldr	r3, [r7, #4]
34185360:	fa01 f303 	lsl.w	r3, r1, r3
34185364:	429a      	cmp	r2, r3
34185366:	d0e7      	beq.n	34185338 <RCC_PLL_Config+0x50>
      }
    }

    /* Ensure PLLxMODSSDIS='1' */
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
34185368:	693b      	ldr	r3, [r7, #16]
3418536a:	681b      	ldr	r3, [r3, #0]
3418536c:	f043 0204 	orr.w	r2, r3, #4
34185370:	693b      	ldr	r3, [r7, #16]
34185372:	601a      	str	r2, [r3, #0]

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
34185374:	69bb      	ldr	r3, [r7, #24]
34185376:	681b      	ldr	r3, [r3, #0]
34185378:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
3418537c:	69bb      	ldr	r3, [r7, #24]
3418537e:	601a      	str	r2, [r3, #0]

    /* Configure the PLLx clock source, multiplication and division factors. */
    MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN), \
34185380:	69bb      	ldr	r3, [r7, #24]
34185382:	681a      	ldr	r2, [r3, #0]
34185384:	4b6f      	ldr	r3, [pc, #444]	@ (34185544 <RCC_PLL_Config+0x25c>)
34185386:	4013      	ands	r3, r2
34185388:	683a      	ldr	r2, [r7, #0]
3418538a:	6851      	ldr	r1, [r2, #4]
3418538c:	683a      	ldr	r2, [r7, #0]
3418538e:	6892      	ldr	r2, [r2, #8]
34185390:	0512      	lsls	r2, r2, #20
34185392:	4311      	orrs	r1, r2
34185394:	683a      	ldr	r2, [r7, #0]
34185396:	6912      	ldr	r2, [r2, #16]
34185398:	0212      	lsls	r2, r2, #8
3418539a:	430a      	orrs	r2, r1
3418539c:	431a      	orrs	r2, r3
3418539e:	69bb      	ldr	r3, [r7, #24]
341853a0:	601a      	str	r2, [r3, #0]
               (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
                | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)));
    MODIFY_REG(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2), \
341853a2:	693b      	ldr	r3, [r7, #16]
341853a4:	681b      	ldr	r3, [r3, #0]
341853a6:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
341853aa:	683b      	ldr	r3, [r7, #0]
341853ac:	695b      	ldr	r3, [r3, #20]
341853ae:	06d9      	lsls	r1, r3, #27
341853b0:	683b      	ldr	r3, [r7, #0]
341853b2:	699b      	ldr	r3, [r3, #24]
341853b4:	061b      	lsls	r3, r3, #24
341853b6:	430b      	orrs	r3, r1
341853b8:	431a      	orrs	r2, r3
341853ba:	693b      	ldr	r3, [r7, #16]
341853bc:	601a      	str	r2, [r3, #0]
               ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)));

    /* Configure PLLx DIVNFRAC */
    MODIFY_REG(*p_rcc_pll_cfgr2_reg, RCC_PLL1CFGR2_PLL1DIVNFRAC, \
341853be:	697b      	ldr	r3, [r7, #20]
341853c0:	681b      	ldr	r3, [r3, #0]
341853c2:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
341853c6:	683b      	ldr	r3, [r7, #0]
341853c8:	68db      	ldr	r3, [r3, #12]
341853ca:	431a      	orrs	r2, r3
341853cc:	697b      	ldr	r3, [r7, #20]
341853ce:	601a      	str	r2, [r3, #0]
               pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);

    /* Clear PLLxMODDSEN (Also clear in Fractional Mode to ensure the latch of updated FRAC value when set again) */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODDSEN);
341853d0:	693b      	ldr	r3, [r7, #16]
341853d2:	681b      	ldr	r3, [r3, #0]
341853d4:	f023 0208 	bic.w	r2, r3, #8
341853d8:	693b      	ldr	r3, [r7, #16]
341853da:	601a      	str	r2, [r3, #0]

    /* Fractional Mode specificities Management */
    if (pPLLInit->PLLFractional != 0U)
341853dc:	683b      	ldr	r3, [r7, #0]
341853de:	68db      	ldr	r3, [r3, #12]
341853e0:	2b00      	cmp	r3, #0
341853e2:	d005      	beq.n	341853f0 <RCC_PLL_Config+0x108>
    {
      /* Set PLLxMODDSEN and DACEN */
      SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODDSEN | RCC_PLL1CFGR3_PLL1DACEN));
341853e4:	693b      	ldr	r3, [r7, #16]
341853e6:	681b      	ldr	r3, [r3, #0]
341853e8:	f043 020a 	orr.w	r2, r3, #10
341853ec:	693b      	ldr	r3, [r7, #16]
341853ee:	601a      	str	r2, [r3, #0]
    }

    /* Ensure PLLxMODSSRST='1' and Enable PLLx post divider output */
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
341853f0:	693b      	ldr	r3, [r7, #16]
341853f2:	681b      	ldr	r3, [r3, #0]
341853f4:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
341853f8:	f043 0301 	orr.w	r3, r3, #1
341853fc:	693a      	ldr	r2, [r7, #16]
341853fe:	6013      	str	r3, [r2, #0]

    /* Enable the PLLx */
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
34185400:	4a4f      	ldr	r2, [pc, #316]	@ (34185540 <RCC_PLL_Config+0x258>)
34185402:	f44f 7180 	mov.w	r1, #256	@ 0x100
34185406:	687b      	ldr	r3, [r7, #4]
34185408:	fa01 f303 	lsl.w	r3, r1, r3
3418540c:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34185410:	f7fc ff0c 	bl	3418222c <HAL_GetTick>
34185414:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is ready */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
34185416:	e008      	b.n	3418542a <RCC_PLL_Config+0x142>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34185418:	f7fc ff08 	bl	3418222c <HAL_GetTick>
3418541c:	4602      	mov	r2, r0
3418541e:	68fb      	ldr	r3, [r7, #12]
34185420:	1ad3      	subs	r3, r2, r3
34185422:	2b01      	cmp	r3, #1
34185424:	d901      	bls.n	3418542a <RCC_PLL_Config+0x142>
      {
        return HAL_TIMEOUT;
34185426:	2303      	movs	r3, #3
34185428:	e080      	b.n	3418552c <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418542a:	4b45      	ldr	r3, [pc, #276]	@ (34185540 <RCC_PLL_Config+0x258>)
3418542c:	685a      	ldr	r2, [r3, #4]
3418542e:	f44f 7180 	mov.w	r1, #256	@ 0x100
34185432:	687b      	ldr	r3, [r7, #4]
34185434:	fa01 f303 	lsl.w	r3, r1, r3
34185438:	4013      	ands	r3, r2
3418543a:	2b00      	cmp	r3, #0
3418543c:	d0ec      	beq.n	34185418 <RCC_PLL_Config+0x130>
3418543e:	e074      	b.n	3418552a <RCC_PLL_Config+0x242>
      }
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_BYPASS)
34185440:	683b      	ldr	r3, [r7, #0]
34185442:	681b      	ldr	r3, [r3, #0]
34185444:	2b03      	cmp	r3, #3
34185446:	d13b      	bne.n	341854c0 <RCC_PLL_Config+0x1d8>
  {
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));

    /* Check selected source is ready */
    if (RCC_PLL_Source_IsReady(pPLLInit->PLLSource) == 1U)
34185448:	683b      	ldr	r3, [r7, #0]
3418544a:	685b      	ldr	r3, [r3, #4]
3418544c:	4618      	mov	r0, r3
3418544e:	f000 f921 	bl	34185694 <RCC_PLL_Source_IsReady>
34185452:	4603      	mov	r3, r0
34185454:	2b01      	cmp	r3, #1
34185456:	d130      	bne.n	341854ba <RCC_PLL_Config+0x1d2>
    {
      /* Ensure PLLx is disabled */
      WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34185458:	4a39      	ldr	r2, [pc, #228]	@ (34185540 <RCC_PLL_Config+0x258>)
3418545a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418545e:	687b      	ldr	r3, [r7, #4]
34185460:	fa01 f303 	lsl.w	r3, r1, r3
34185464:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34185468:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418546a:	f7fc fedf 	bl	3418222c <HAL_GetTick>
3418546e:	60f8      	str	r0, [r7, #12]

      /* Wait till PLLx is disabled */
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34185470:	e008      	b.n	34185484 <RCC_PLL_Config+0x19c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34185472:	f7fc fedb 	bl	3418222c <HAL_GetTick>
34185476:	4602      	mov	r2, r0
34185478:	68fb      	ldr	r3, [r7, #12]
3418547a:	1ad3      	subs	r3, r2, r3
3418547c:	2b01      	cmp	r3, #1
3418547e:	d901      	bls.n	34185484 <RCC_PLL_Config+0x19c>
        {
          return HAL_TIMEOUT;
34185480:	2303      	movs	r3, #3
34185482:	e053      	b.n	3418552c <RCC_PLL_Config+0x244>
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34185484:	4b2e      	ldr	r3, [pc, #184]	@ (34185540 <RCC_PLL_Config+0x258>)
34185486:	685a      	ldr	r2, [r3, #4]
34185488:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418548c:	687b      	ldr	r3, [r7, #4]
3418548e:	fa01 f303 	lsl.w	r3, r1, r3
34185492:	401a      	ands	r2, r3
34185494:	f44f 7180 	mov.w	r1, #256	@ 0x100
34185498:	687b      	ldr	r3, [r7, #4]
3418549a:	fa01 f303 	lsl.w	r3, r1, r3
3418549e:	429a      	cmp	r2, r3
341854a0:	d0e7      	beq.n	34185472 <RCC_PLL_Config+0x18a>
        }
      }

      /* Set bypass mode with selected source */
      MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1BYP | RCC_PLL1CFGR1_PLL1SEL), \
341854a2:	69bb      	ldr	r3, [r7, #24]
341854a4:	681b      	ldr	r3, [r3, #0]
341854a6:	f023 42f0 	bic.w	r2, r3, #2013265920	@ 0x78000000
341854aa:	683b      	ldr	r3, [r7, #0]
341854ac:	685b      	ldr	r3, [r3, #4]
341854ae:	4313      	orrs	r3, r2
341854b0:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
341854b4:	69bb      	ldr	r3, [r7, #24]
341854b6:	601a      	str	r2, [r3, #0]
341854b8:	e037      	b.n	3418552a <RCC_PLL_Config+0x242>
                 (RCC_PLL1CFGR1_PLL1BYP | pPLLInit->PLLSource));
    }
    else
    {
      ret = HAL_ERROR;
341854ba:	2301      	movs	r3, #1
341854bc:	77fb      	strb	r3, [r7, #31]
341854be:	e034      	b.n	3418552a <RCC_PLL_Config+0x242>
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_OFF)
341854c0:	683b      	ldr	r3, [r7, #0]
341854c2:	681b      	ldr	r3, [r3, #0]
341854c4:	2b01      	cmp	r3, #1
341854c6:	d130      	bne.n	3418552a <RCC_PLL_Config+0x242>
  {
    /* Disable PLLx post divider output */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
341854c8:	693b      	ldr	r3, [r7, #16]
341854ca:	681b      	ldr	r3, [r3, #0]
341854cc:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
341854d0:	693b      	ldr	r3, [r7, #16]
341854d2:	601a      	str	r2, [r3, #0]

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
341854d4:	4a1a      	ldr	r2, [pc, #104]	@ (34185540 <RCC_PLL_Config+0x258>)
341854d6:	f44f 7180 	mov.w	r1, #256	@ 0x100
341854da:	687b      	ldr	r3, [r7, #4]
341854dc:	fa01 f303 	lsl.w	r3, r1, r3
341854e0:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
341854e4:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
341854e6:	f7fc fea1 	bl	3418222c <HAL_GetTick>
341854ea:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
341854ec:	e008      	b.n	34185500 <RCC_PLL_Config+0x218>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
341854ee:	f7fc fe9d 	bl	3418222c <HAL_GetTick>
341854f2:	4602      	mov	r2, r0
341854f4:	68fb      	ldr	r3, [r7, #12]
341854f6:	1ad3      	subs	r3, r2, r3
341854f8:	2b01      	cmp	r3, #1
341854fa:	d901      	bls.n	34185500 <RCC_PLL_Config+0x218>
      {
        return HAL_TIMEOUT;
341854fc:	2303      	movs	r3, #3
341854fe:	e015      	b.n	3418552c <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34185500:	4b0f      	ldr	r3, [pc, #60]	@ (34185540 <RCC_PLL_Config+0x258>)
34185502:	685a      	ldr	r2, [r3, #4]
34185504:	f44f 7180 	mov.w	r1, #256	@ 0x100
34185508:	687b      	ldr	r3, [r7, #4]
3418550a:	fa01 f303 	lsl.w	r3, r1, r3
3418550e:	401a      	ands	r2, r3
34185510:	f44f 7180 	mov.w	r1, #256	@ 0x100
34185514:	687b      	ldr	r3, [r7, #4]
34185516:	fa01 f303 	lsl.w	r3, r1, r3
3418551a:	429a      	cmp	r2, r3
3418551c:	d0e7      	beq.n	341854ee <RCC_PLL_Config+0x206>
      }
    }

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3418551e:	69bb      	ldr	r3, [r7, #24]
34185520:	681b      	ldr	r3, [r3, #0]
34185522:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
34185526:	69bb      	ldr	r3, [r7, #24]
34185528:	601a      	str	r2, [r3, #0]
  else
  {
    /* Nothing to do */
  }

  return ret;
3418552a:	7ffb      	ldrb	r3, [r7, #31]
}
3418552c:	4618      	mov	r0, r3
3418552e:	3720      	adds	r7, #32
34185530:	46bd      	mov	sp, r7
34185532:	bd80      	pop	{r7, pc}
34185534:	56028080 	.word	0x56028080
34185538:	56028084 	.word	0x56028084
3418553c:	56028088 	.word	0x56028088
34185540:	56028000 	.word	0x56028000
34185544:	8c0000ff 	.word	0x8c0000ff

34185548 <RCC_PLL_Enable>:
  * @param  PLLnumber PLL number to enable
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Enable(uint32_t PLLnumber)
{
34185548:	b580      	push	{r7, lr}
3418554a:	b084      	sub	sp, #16
3418554c:	af00      	add	r7, sp, #0
3418554e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
34185550:	2300      	movs	r3, #0
34185552:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Enable the PLLx */
  WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
34185554:	4a11      	ldr	r2, [pc, #68]	@ (3418559c <RCC_PLL_Enable+0x54>)
34185556:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418555a:	687b      	ldr	r3, [r7, #4]
3418555c:	fa01 f303 	lsl.w	r3, r1, r3
34185560:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
34185564:	f7fc fe62 	bl	3418222c <HAL_GetTick>
34185568:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLx is ready */
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418556a:	e008      	b.n	3418557e <RCC_PLL_Enable+0x36>
  {
    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418556c:	f7fc fe5e 	bl	3418222c <HAL_GetTick>
34185570:	4602      	mov	r2, r0
34185572:	68bb      	ldr	r3, [r7, #8]
34185574:	1ad3      	subs	r3, r2, r3
34185576:	2b01      	cmp	r3, #1
34185578:	d901      	bls.n	3418557e <RCC_PLL_Enable+0x36>
    {
      return HAL_TIMEOUT;
3418557a:	2303      	movs	r3, #3
3418557c:	e00a      	b.n	34185594 <RCC_PLL_Enable+0x4c>
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418557e:	4b07      	ldr	r3, [pc, #28]	@ (3418559c <RCC_PLL_Enable+0x54>)
34185580:	685a      	ldr	r2, [r3, #4]
34185582:	f44f 7180 	mov.w	r1, #256	@ 0x100
34185586:	687b      	ldr	r3, [r7, #4]
34185588:	fa01 f303 	lsl.w	r3, r1, r3
3418558c:	4013      	ands	r3, r2
3418558e:	2b00      	cmp	r3, #0
34185590:	d0ec      	beq.n	3418556c <RCC_PLL_Enable+0x24>
    }
  }

  return ret;
34185592:	7bfb      	ldrb	r3, [r7, #15]
}
34185594:	4618      	mov	r0, r3
34185596:	3710      	adds	r7, #16
34185598:	46bd      	mov	sp, r7
3418559a:	bd80      	pop	{r7, pc}
3418559c:	56028000 	.word	0x56028000

341855a0 <RCC_PLL_IsNewConfig>:
  * @param  pPLLInit Pointer to an RCC_PLLInitTypeDef structure that
  *                  contains the configuration parameters.  *
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_IsNewConfig(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
341855a0:	b480      	push	{r7}
341855a2:	b089      	sub	sp, #36	@ 0x24
341855a4:	af00      	add	r7, sp, #0
341855a6:	6078      	str	r0, [r7, #4]
341855a8:	6039      	str	r1, [r7, #0]
  __IO const uint32_t *p_rcc_pll_cfgr1_reg, *p_rcc_pll_cfgr2_reg, *p_rcc_pll_cfgr3_reg;
  uint32_t ret = 0U;
341855aa:	2300      	movs	r3, #0
341855ac:	61fb      	str	r3, [r7, #28]

  /* No assert since done in calling function */

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
341855ae:	687b      	ldr	r3, [r7, #4]
341855b0:	011a      	lsls	r2, r3, #4
341855b2:	4b34      	ldr	r3, [pc, #208]	@ (34185684 <RCC_PLL_IsNewConfig+0xe4>)
341855b4:	4413      	add	r3, r2
341855b6:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
341855b8:	687b      	ldr	r3, [r7, #4]
341855ba:	011a      	lsls	r2, r3, #4
341855bc:	4b32      	ldr	r3, [pc, #200]	@ (34185688 <RCC_PLL_IsNewConfig+0xe8>)
341855be:	4413      	add	r3, r2
341855c0:	613b      	str	r3, [r7, #16]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
341855c2:	687b      	ldr	r3, [r7, #4]
341855c4:	011a      	lsls	r2, r3, #4
341855c6:	4b31      	ldr	r3, [pc, #196]	@ (3418568c <RCC_PLL_IsNewConfig+0xec>)
341855c8:	4413      	add	r3, r2
341855ca:	60fb      	str	r3, [r7, #12]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */

  /* Check for PLLCFGR1, PLLCFGR2 and PLLCFGR3 parameters updates */
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
341855cc:	697b      	ldr	r3, [r7, #20]
341855ce:	681b      	ldr	r3, [r3, #0]
341855d0:	f023 430c 	bic.w	r3, r3, #2348810240	@ 0x8c000000
341855d4:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
341855d8:	683a      	ldr	r2, [r7, #0]
341855da:	6851      	ldr	r1, [r2, #4]
341855dc:	683a      	ldr	r2, [r7, #0]
341855de:	6892      	ldr	r2, [r2, #8]
341855e0:	0512      	lsls	r2, r2, #20
341855e2:	4311      	orrs	r1, r2
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
341855e4:	683a      	ldr	r2, [r7, #0]
341855e6:	6912      	ldr	r2, [r2, #16]
341855e8:	0212      	lsls	r2, r2, #8
341855ea:	430a      	orrs	r2, r1
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
341855ec:	4293      	cmp	r3, r2
341855ee:	d002      	beq.n	341855f6 <RCC_PLL_IsNewConfig+0x56>
  {
    ret = 1U; /* New PLL configuration */
341855f0:	2301      	movs	r3, #1
341855f2:	61fb      	str	r3, [r7, #28]
341855f4:	e03e      	b.n	34185674 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
341855f6:	693b      	ldr	r3, [r7, #16]
341855f8:	681b      	ldr	r3, [r3, #0]
341855fa:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
           (pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos))
341855fe:	683b      	ldr	r3, [r7, #0]
34185600:	68db      	ldr	r3, [r3, #12]
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
34185602:	429a      	cmp	r2, r3
34185604:	d002      	beq.n	3418560c <RCC_PLL_IsNewConfig+0x6c>
  {
    ret = 1U; /* New PLL configuration */
34185606:	2301      	movs	r3, #1
34185608:	61fb      	str	r3, [r7, #28]
3418560a:	e033      	b.n	34185674 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3418560c:	68fb      	ldr	r3, [r7, #12]
3418560e:	681b      	ldr	r3, [r3, #0]
34185610:	f003 527c 	and.w	r2, r3, #1056964608	@ 0x3f000000
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
34185614:	683b      	ldr	r3, [r7, #0]
34185616:	695b      	ldr	r3, [r3, #20]
34185618:	06d9      	lsls	r1, r3, #27
3418561a:	683b      	ldr	r3, [r7, #0]
3418561c:	699b      	ldr	r3, [r3, #24]
3418561e:	061b      	lsls	r3, r3, #24
34185620:	430b      	orrs	r3, r1
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
34185622:	429a      	cmp	r2, r3
34185624:	d002      	beq.n	3418562c <RCC_PLL_IsNewConfig+0x8c>
  {
    ret = 1U; /* New PLL configuration */
34185626:	2301      	movs	r3, #1
34185628:	61fb      	str	r3, [r7, #28]
3418562a:	e023      	b.n	34185674 <RCC_PLL_IsNewConfig+0xd4>
  {
    /* Mode change detection*/
    uint32_t pllState;

    /* Get current Mode*/
    if (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418562c:	4b18      	ldr	r3, [pc, #96]	@ (34185690 <RCC_PLL_IsNewConfig+0xf0>)
3418562e:	685a      	ldr	r2, [r3, #4]
34185630:	f44f 7180 	mov.w	r1, #256	@ 0x100
34185634:	687b      	ldr	r3, [r7, #4]
34185636:	fa01 f303 	lsl.w	r3, r1, r3
3418563a:	401a      	ands	r2, r3
3418563c:	f44f 7180 	mov.w	r1, #256	@ 0x100
34185640:	687b      	ldr	r3, [r7, #4]
34185642:	fa01 f303 	lsl.w	r3, r1, r3
34185646:	429a      	cmp	r2, r3
34185648:	d102      	bne.n	34185650 <RCC_PLL_IsNewConfig+0xb0>
    {
      pllState = RCC_PLL_ON;
3418564a:	2302      	movs	r3, #2
3418564c:	61bb      	str	r3, [r7, #24]
3418564e:	e00a      	b.n	34185666 <RCC_PLL_IsNewConfig+0xc6>
    }
    else
    {
      if ((*p_rcc_pll_cfgr1_reg & RCC_PLL1CFGR1_PLL1BYP) != 0UL)
34185650:	697b      	ldr	r3, [r7, #20]
34185652:	681b      	ldr	r3, [r3, #0]
34185654:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34185658:	2b00      	cmp	r3, #0
3418565a:	d002      	beq.n	34185662 <RCC_PLL_IsNewConfig+0xc2>
      {
        pllState = RCC_PLL_BYPASS;
3418565c:	2303      	movs	r3, #3
3418565e:	61bb      	str	r3, [r7, #24]
34185660:	e001      	b.n	34185666 <RCC_PLL_IsNewConfig+0xc6>
      }
      else
      {
        pllState = RCC_PLL_OFF;
34185662:	2301      	movs	r3, #1
34185664:	61bb      	str	r3, [r7, #24]
      }
    }

    /* Compare with new mode */
    if (pllState != pPLLInit->PLLState)
34185666:	683b      	ldr	r3, [r7, #0]
34185668:	681b      	ldr	r3, [r3, #0]
3418566a:	69ba      	ldr	r2, [r7, #24]
3418566c:	429a      	cmp	r2, r3
3418566e:	d001      	beq.n	34185674 <RCC_PLL_IsNewConfig+0xd4>
    {
      ret = 1U; /* New PLL configuration */
34185670:	2301      	movs	r3, #1
34185672:	61fb      	str	r3, [r7, #28]
    }
  }

  return ret;
34185674:	69fb      	ldr	r3, [r7, #28]
}
34185676:	4618      	mov	r0, r3
34185678:	3724      	adds	r7, #36	@ 0x24
3418567a:	46bd      	mov	sp, r7
3418567c:	f85d 7b04 	ldr.w	r7, [sp], #4
34185680:	4770      	bx	lr
34185682:	bf00      	nop
34185684:	56028080 	.word	0x56028080
34185688:	56028084 	.word	0x56028084
3418568c:	56028088 	.word	0x56028088
34185690:	56028000 	.word	0x56028000

34185694 <RCC_PLL_Source_IsReady>:
  * @brief  Check whether the PLL source is ready
  * @param  PLLSource PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_Source_IsReady(uint32_t PLLSource)
{
34185694:	b580      	push	{r7, lr}
34185696:	b084      	sub	sp, #16
34185698:	af00      	add	r7, sp, #0
3418569a:	6078      	str	r0, [r7, #4]
  uint32_t ret = 1U;
3418569c:	2301      	movs	r3, #1
3418569e:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  switch (PLLSource)
341856a0:	687b      	ldr	r3, [r7, #4]
341856a2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341856a6:	d01b      	beq.n	341856e0 <RCC_PLL_Source_IsReady+0x4c>
341856a8:	687b      	ldr	r3, [r7, #4]
341856aa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341856ae:	d81f      	bhi.n	341856f0 <RCC_PLL_Source_IsReady+0x5c>
341856b0:	687b      	ldr	r3, [r7, #4]
341856b2:	2b00      	cmp	r3, #0
341856b4:	d004      	beq.n	341856c0 <RCC_PLL_Source_IsReady+0x2c>
341856b6:	687b      	ldr	r3, [r7, #4]
341856b8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341856bc:	d008      	beq.n	341856d0 <RCC_PLL_Source_IsReady+0x3c>
        ret = 0U;
      }
      break;
    case RCC_PLLSOURCE_PIN:
    default:
      break;
341856be:	e017      	b.n	341856f0 <RCC_PLL_Source_IsReady+0x5c>
      if (LL_RCC_HSI_IsReady() == 0U)
341856c0:	f7fe fd00 	bl	341840c4 <LL_RCC_HSI_IsReady>
341856c4:	4603      	mov	r3, r0
341856c6:	2b00      	cmp	r3, #0
341856c8:	d114      	bne.n	341856f4 <RCC_PLL_Source_IsReady+0x60>
        ret = 0U;
341856ca:	2300      	movs	r3, #0
341856cc:	60fb      	str	r3, [r7, #12]
      break;
341856ce:	e011      	b.n	341856f4 <RCC_PLL_Source_IsReady+0x60>
      if (LL_RCC_MSI_IsReady() == 0U)
341856d0:	f7fe fd60 	bl	34184194 <LL_RCC_MSI_IsReady>
341856d4:	4603      	mov	r3, r0
341856d6:	2b00      	cmp	r3, #0
341856d8:	d10e      	bne.n	341856f8 <RCC_PLL_Source_IsReady+0x64>
        ret = 0U;
341856da:	2300      	movs	r3, #0
341856dc:	60fb      	str	r3, [r7, #12]
      break;
341856de:	e00b      	b.n	341856f8 <RCC_PLL_Source_IsReady+0x64>
      if (LL_RCC_HSE_IsReady() == 0U)
341856e0:	f7fe fcc0 	bl	34184064 <LL_RCC_HSE_IsReady>
341856e4:	4603      	mov	r3, r0
341856e6:	2b00      	cmp	r3, #0
341856e8:	d108      	bne.n	341856fc <RCC_PLL_Source_IsReady+0x68>
        ret = 0U;
341856ea:	2300      	movs	r3, #0
341856ec:	60fb      	str	r3, [r7, #12]
      break;
341856ee:	e005      	b.n	341856fc <RCC_PLL_Source_IsReady+0x68>
      break;
341856f0:	bf00      	nop
341856f2:	e004      	b.n	341856fe <RCC_PLL_Source_IsReady+0x6a>
      break;
341856f4:	bf00      	nop
341856f6:	e002      	b.n	341856fe <RCC_PLL_Source_IsReady+0x6a>
      break;
341856f8:	bf00      	nop
341856fa:	e000      	b.n	341856fe <RCC_PLL_Source_IsReady+0x6a>
      break;
341856fc:	bf00      	nop
  }

  return ret;
341856fe:	68fb      	ldr	r3, [r7, #12]
}
34185700:	4618      	mov	r0, r3
34185702:	3710      	adds	r7, #16
34185704:	46bd      	mov	sp, r7
34185706:	bd80      	pop	{r7, pc}

34185708 <RCC_IC_CheckPLLSources>:
  * @param  PLLSource1 First PLL source
  * @param  PLLSource2 Second PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_IC_CheckPLLSources(uint32_t PLLSource1, uint32_t PLLSource2)
{
34185708:	b580      	push	{r7, lr}
3418570a:	b084      	sub	sp, #16
3418570c:	af00      	add	r7, sp, #0
3418570e:	6078      	str	r0, [r7, #4]
34185710:	6039      	str	r1, [r7, #0]
  uint32_t ret = 1U;
34185712:	2301      	movs	r3, #1
34185714:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  /* Check PLLSource1 clock source */
  switch (PLLSource1)
34185716:	687b      	ldr	r3, [r7, #4]
34185718:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418571c:	d03a      	beq.n	34185794 <RCC_IC_CheckPLLSources+0x8c>
3418571e:	687b      	ldr	r3, [r7, #4]
34185720:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34185724:	d843      	bhi.n	341857ae <RCC_IC_CheckPLLSources+0xa6>
34185726:	687b      	ldr	r3, [r7, #4]
34185728:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418572c:	d025      	beq.n	3418577a <RCC_IC_CheckPLLSources+0x72>
3418572e:	687b      	ldr	r3, [r7, #4]
34185730:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34185734:	d83b      	bhi.n	341857ae <RCC_IC_CheckPLLSources+0xa6>
34185736:	687b      	ldr	r3, [r7, #4]
34185738:	2b00      	cmp	r3, #0
3418573a:	d004      	beq.n	34185746 <RCC_IC_CheckPLLSources+0x3e>
3418573c:	687b      	ldr	r3, [r7, #4]
3418573e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34185742:	d00d      	beq.n	34185760 <RCC_IC_CheckPLLSources+0x58>
34185744:	e033      	b.n	341857ae <RCC_IC_CheckPLLSources+0xa6>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
34185746:	f7fe fdd7 	bl	341842f8 <LL_RCC_PLL1_IsReady>
3418574a:	4603      	mov	r3, r0
3418574c:	2b00      	cmp	r3, #0
3418574e:	d131      	bne.n	341857b4 <RCC_IC_CheckPLLSources+0xac>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
34185750:	f7fe fde6 	bl	34184320 <LL_RCC_PLL1_IsEnabledBypass>
34185754:	4603      	mov	r3, r0
34185756:	2b00      	cmp	r3, #0
34185758:	d12c      	bne.n	341857b4 <RCC_IC_CheckPLLSources+0xac>
        {
          ret = 0U;
3418575a:	2300      	movs	r3, #0
3418575c:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418575e:	e029      	b.n	341857b4 <RCC_IC_CheckPLLSources+0xac>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
34185760:	f7fe fe00 	bl	34184364 <LL_RCC_PLL2_IsReady>
34185764:	4603      	mov	r3, r0
34185766:	2b00      	cmp	r3, #0
34185768:	d126      	bne.n	341857b8 <RCC_IC_CheckPLLSources+0xb0>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
3418576a:	f7fe fe0f 	bl	3418438c <LL_RCC_PLL2_IsEnabledBypass>
3418576e:	4603      	mov	r3, r0
34185770:	2b00      	cmp	r3, #0
34185772:	d121      	bne.n	341857b8 <RCC_IC_CheckPLLSources+0xb0>
        {
          ret = 0U;
34185774:	2300      	movs	r3, #0
34185776:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
34185778:	e01e      	b.n	341857b8 <RCC_IC_CheckPLLSources+0xb0>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
3418577a:	f7fe fe29 	bl	341843d0 <LL_RCC_PLL3_IsReady>
3418577e:	4603      	mov	r3, r0
34185780:	2b00      	cmp	r3, #0
34185782:	d11b      	bne.n	341857bc <RCC_IC_CheckPLLSources+0xb4>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
34185784:	f7fe fe38 	bl	341843f8 <LL_RCC_PLL3_IsEnabledBypass>
34185788:	4603      	mov	r3, r0
3418578a:	2b00      	cmp	r3, #0
3418578c:	d116      	bne.n	341857bc <RCC_IC_CheckPLLSources+0xb4>
        {
          ret = 0U;
3418578e:	2300      	movs	r3, #0
34185790:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
34185792:	e013      	b.n	341857bc <RCC_IC_CheckPLLSources+0xb4>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
34185794:	f7fe fe52 	bl	3418443c <LL_RCC_PLL4_IsReady>
34185798:	4603      	mov	r3, r0
3418579a:	2b00      	cmp	r3, #0
3418579c:	d110      	bne.n	341857c0 <RCC_IC_CheckPLLSources+0xb8>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3418579e:	f7fe fe61 	bl	34184464 <LL_RCC_PLL4_IsEnabledBypass>
341857a2:	4603      	mov	r3, r0
341857a4:	2b00      	cmp	r3, #0
341857a6:	d10b      	bne.n	341857c0 <RCC_IC_CheckPLLSources+0xb8>
        {
          ret = 0U;
341857a8:	2300      	movs	r3, #0
341857aa:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
341857ac:	e008      	b.n	341857c0 <RCC_IC_CheckPLLSources+0xb8>
    default:
      /* Unexpected */
      ret = 0U;
341857ae:	2300      	movs	r3, #0
341857b0:	60fb      	str	r3, [r7, #12]
      break;
341857b2:	e006      	b.n	341857c2 <RCC_IC_CheckPLLSources+0xba>
      break;
341857b4:	bf00      	nop
341857b6:	e004      	b.n	341857c2 <RCC_IC_CheckPLLSources+0xba>
      break;
341857b8:	bf00      	nop
341857ba:	e002      	b.n	341857c2 <RCC_IC_CheckPLLSources+0xba>
      break;
341857bc:	bf00      	nop
341857be:	e000      	b.n	341857c2 <RCC_IC_CheckPLLSources+0xba>
      break;
341857c0:	bf00      	nop
  }

  /* Check PLLSource2 clock source */
  switch (PLLSource2)
341857c2:	683b      	ldr	r3, [r7, #0]
341857c4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341857c8:	d03a      	beq.n	34185840 <RCC_IC_CheckPLLSources+0x138>
341857ca:	683b      	ldr	r3, [r7, #0]
341857cc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341857d0:	d843      	bhi.n	3418585a <RCC_IC_CheckPLLSources+0x152>
341857d2:	683b      	ldr	r3, [r7, #0]
341857d4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341857d8:	d025      	beq.n	34185826 <RCC_IC_CheckPLLSources+0x11e>
341857da:	683b      	ldr	r3, [r7, #0]
341857dc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341857e0:	d83b      	bhi.n	3418585a <RCC_IC_CheckPLLSources+0x152>
341857e2:	683b      	ldr	r3, [r7, #0]
341857e4:	2b00      	cmp	r3, #0
341857e6:	d004      	beq.n	341857f2 <RCC_IC_CheckPLLSources+0xea>
341857e8:	683b      	ldr	r3, [r7, #0]
341857ea:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341857ee:	d00d      	beq.n	3418580c <RCC_IC_CheckPLLSources+0x104>
341857f0:	e033      	b.n	3418585a <RCC_IC_CheckPLLSources+0x152>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
341857f2:	f7fe fd81 	bl	341842f8 <LL_RCC_PLL1_IsReady>
341857f6:	4603      	mov	r3, r0
341857f8:	2b00      	cmp	r3, #0
341857fa:	d131      	bne.n	34185860 <RCC_IC_CheckPLLSources+0x158>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
341857fc:	f7fe fd90 	bl	34184320 <LL_RCC_PLL1_IsEnabledBypass>
34185800:	4603      	mov	r3, r0
34185802:	2b00      	cmp	r3, #0
34185804:	d12c      	bne.n	34185860 <RCC_IC_CheckPLLSources+0x158>
        {
          ret = 0U;
34185806:	2300      	movs	r3, #0
34185808:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418580a:	e029      	b.n	34185860 <RCC_IC_CheckPLLSources+0x158>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3418580c:	f7fe fdaa 	bl	34184364 <LL_RCC_PLL2_IsReady>
34185810:	4603      	mov	r3, r0
34185812:	2b00      	cmp	r3, #0
34185814:	d126      	bne.n	34185864 <RCC_IC_CheckPLLSources+0x15c>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
34185816:	f7fe fdb9 	bl	3418438c <LL_RCC_PLL2_IsEnabledBypass>
3418581a:	4603      	mov	r3, r0
3418581c:	2b00      	cmp	r3, #0
3418581e:	d121      	bne.n	34185864 <RCC_IC_CheckPLLSources+0x15c>
        {
          ret = 0U;
34185820:	2300      	movs	r3, #0
34185822:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
34185824:	e01e      	b.n	34185864 <RCC_IC_CheckPLLSources+0x15c>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
34185826:	f7fe fdd3 	bl	341843d0 <LL_RCC_PLL3_IsReady>
3418582a:	4603      	mov	r3, r0
3418582c:	2b00      	cmp	r3, #0
3418582e:	d11b      	bne.n	34185868 <RCC_IC_CheckPLLSources+0x160>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
34185830:	f7fe fde2 	bl	341843f8 <LL_RCC_PLL3_IsEnabledBypass>
34185834:	4603      	mov	r3, r0
34185836:	2b00      	cmp	r3, #0
34185838:	d116      	bne.n	34185868 <RCC_IC_CheckPLLSources+0x160>
        {
          ret = 0U;
3418583a:	2300      	movs	r3, #0
3418583c:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418583e:	e013      	b.n	34185868 <RCC_IC_CheckPLLSources+0x160>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
34185840:	f7fe fdfc 	bl	3418443c <LL_RCC_PLL4_IsReady>
34185844:	4603      	mov	r3, r0
34185846:	2b00      	cmp	r3, #0
34185848:	d110      	bne.n	3418586c <RCC_IC_CheckPLLSources+0x164>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3418584a:	f7fe fe0b 	bl	34184464 <LL_RCC_PLL4_IsEnabledBypass>
3418584e:	4603      	mov	r3, r0
34185850:	2b00      	cmp	r3, #0
34185852:	d10b      	bne.n	3418586c <RCC_IC_CheckPLLSources+0x164>
        {
          ret = 0U;
34185854:	2300      	movs	r3, #0
34185856:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
34185858:	e008      	b.n	3418586c <RCC_IC_CheckPLLSources+0x164>
    default:
      /* Unexpected */
      ret = 0U;
3418585a:	2300      	movs	r3, #0
3418585c:	60fb      	str	r3, [r7, #12]
      break;
3418585e:	e006      	b.n	3418586e <RCC_IC_CheckPLLSources+0x166>
      break;
34185860:	bf00      	nop
34185862:	e004      	b.n	3418586e <RCC_IC_CheckPLLSources+0x166>
      break;
34185864:	bf00      	nop
34185866:	e002      	b.n	3418586e <RCC_IC_CheckPLLSources+0x166>
      break;
34185868:	bf00      	nop
3418586a:	e000      	b.n	3418586e <RCC_IC_CheckPLLSources+0x166>
      break;
3418586c:	bf00      	nop
  }

  return ret;
3418586e:	68fb      	ldr	r3, [r7, #12]
}
34185870:	4618      	mov	r0, r3
34185872:	3710      	adds	r7, #16
34185874:	46bd      	mov	sp, r7
34185876:	bd80      	pop	{r7, pc}

34185878 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
{
34185878:	b480      	push	{r7}
3418587a:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3418587c:	4b05      	ldr	r3, [pc, #20]	@ (34185894 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
3418587e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34185880:	4a04      	ldr	r2, [pc, #16]	@ (34185894 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
34185882:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
34185886:	6553      	str	r3, [r2, #84]	@ 0x54
}
34185888:	bf00      	nop
3418588a:	46bd      	mov	sp, r7
3418588c:	f85d 7b04 	ldr.w	r7, [sp], #4
34185890:	4770      	bx	lr
34185892:	bf00      	nop
34185894:	56028000 	.word	0x56028000

34185898 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
{
34185898:	b480      	push	{r7}
3418589a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3418589c:	4b05      	ldr	r3, [pc, #20]	@ (341858b4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3418589e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341858a0:	4a04      	ldr	r2, [pc, #16]	@ (341858b4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
341858a2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
341858a6:	6553      	str	r3, [r2, #84]	@ 0x54
}
341858a8:	bf00      	nop
341858aa:	46bd      	mov	sp, r7
341858ac:	f85d 7b04 	ldr.w	r7, [sp], #4
341858b0:	4770      	bx	lr
341858b2:	bf00      	nop
341858b4:	56028000 	.word	0x56028000

341858b8 <LL_RCC_HSE_IsReady>:
{
341858b8:	b480      	push	{r7}
341858ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
341858bc:	4b06      	ldr	r3, [pc, #24]	@ (341858d8 <LL_RCC_HSE_IsReady+0x20>)
341858be:	685b      	ldr	r3, [r3, #4]
341858c0:	f003 0310 	and.w	r3, r3, #16
341858c4:	2b00      	cmp	r3, #0
341858c6:	d001      	beq.n	341858cc <LL_RCC_HSE_IsReady+0x14>
341858c8:	2301      	movs	r3, #1
341858ca:	e000      	b.n	341858ce <LL_RCC_HSE_IsReady+0x16>
341858cc:	2300      	movs	r3, #0
}
341858ce:	4618      	mov	r0, r3
341858d0:	46bd      	mov	sp, r7
341858d2:	f85d 7b04 	ldr.w	r7, [sp], #4
341858d6:	4770      	bx	lr
341858d8:	56028000 	.word	0x56028000

341858dc <LL_RCC_HSI_IsReady>:
{
341858dc:	b480      	push	{r7}
341858de:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
341858e0:	4b06      	ldr	r3, [pc, #24]	@ (341858fc <LL_RCC_HSI_IsReady+0x20>)
341858e2:	685b      	ldr	r3, [r3, #4]
341858e4:	f003 0308 	and.w	r3, r3, #8
341858e8:	2b00      	cmp	r3, #0
341858ea:	d001      	beq.n	341858f0 <LL_RCC_HSI_IsReady+0x14>
341858ec:	2301      	movs	r3, #1
341858ee:	e000      	b.n	341858f2 <LL_RCC_HSI_IsReady+0x16>
341858f0:	2300      	movs	r3, #0
}
341858f2:	4618      	mov	r0, r3
341858f4:	46bd      	mov	sp, r7
341858f6:	f85d 7b04 	ldr.w	r7, [sp], #4
341858fa:	4770      	bx	lr
341858fc:	56028000 	.word	0x56028000

34185900 <LL_RCC_HSI_GetDivider>:
{
34185900:	b480      	push	{r7}
34185902:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34185904:	4b04      	ldr	r3, [pc, #16]	@ (34185918 <LL_RCC_HSI_GetDivider+0x18>)
34185906:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34185908:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
3418590c:	4618      	mov	r0, r3
3418590e:	46bd      	mov	sp, r7
34185910:	f85d 7b04 	ldr.w	r7, [sp], #4
34185914:	4770      	bx	lr
34185916:	bf00      	nop
34185918:	56028000 	.word	0x56028000

3418591c <LL_RCC_MSI_IsReady>:
{
3418591c:	b480      	push	{r7}
3418591e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
34185920:	4b06      	ldr	r3, [pc, #24]	@ (3418593c <LL_RCC_MSI_IsReady+0x20>)
34185922:	685b      	ldr	r3, [r3, #4]
34185924:	f003 0304 	and.w	r3, r3, #4
34185928:	2b00      	cmp	r3, #0
3418592a:	d001      	beq.n	34185930 <LL_RCC_MSI_IsReady+0x14>
3418592c:	2301      	movs	r3, #1
3418592e:	e000      	b.n	34185932 <LL_RCC_MSI_IsReady+0x16>
34185930:	2300      	movs	r3, #0
}
34185932:	4618      	mov	r0, r3
34185934:	46bd      	mov	sp, r7
34185936:	f85d 7b04 	ldr.w	r7, [sp], #4
3418593a:	4770      	bx	lr
3418593c:	56028000 	.word	0x56028000

34185940 <LL_RCC_MSI_GetFrequency>:
{
34185940:	b480      	push	{r7}
34185942:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
34185944:	4b04      	ldr	r3, [pc, #16]	@ (34185958 <LL_RCC_MSI_GetFrequency+0x18>)
34185946:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34185948:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
3418594c:	4618      	mov	r0, r3
3418594e:	46bd      	mov	sp, r7
34185950:	f85d 7b04 	ldr.w	r7, [sp], #4
34185954:	4770      	bx	lr
34185956:	bf00      	nop
34185958:	56028000 	.word	0x56028000

3418595c <LL_RCC_LSE_IsReady>:
{
3418595c:	b480      	push	{r7}
3418595e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
34185960:	4b06      	ldr	r3, [pc, #24]	@ (3418597c <LL_RCC_LSE_IsReady+0x20>)
34185962:	685b      	ldr	r3, [r3, #4]
34185964:	f003 0302 	and.w	r3, r3, #2
34185968:	2b00      	cmp	r3, #0
3418596a:	d001      	beq.n	34185970 <LL_RCC_LSE_IsReady+0x14>
3418596c:	2301      	movs	r3, #1
3418596e:	e000      	b.n	34185972 <LL_RCC_LSE_IsReady+0x16>
34185970:	2300      	movs	r3, #0
}
34185972:	4618      	mov	r0, r3
34185974:	46bd      	mov	sp, r7
34185976:	f85d 7b04 	ldr.w	r7, [sp], #4
3418597a:	4770      	bx	lr
3418597c:	56028000 	.word	0x56028000

34185980 <LL_RCC_SetClockSource>:
{
34185980:	b480      	push	{r7}
34185982:	b085      	sub	sp, #20
34185984:	af00      	add	r7, sp, #0
34185986:	6078      	str	r0, [r7, #4]
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
34185988:	687b      	ldr	r3, [r7, #4]
3418598a:	b2da      	uxtb	r2, r3
3418598c:	4b10      	ldr	r3, [pc, #64]	@ (341859d0 <LL_RCC_SetClockSource+0x50>)
3418598e:	4413      	add	r3, r2
34185990:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
34185992:	68fb      	ldr	r3, [r7, #12]
34185994:	681a      	ldr	r2, [r3, #0]
34185996:	687b      	ldr	r3, [r7, #4]
34185998:	0e19      	lsrs	r1, r3, #24
3418599a:	687b      	ldr	r3, [r7, #4]
3418599c:	0a1b      	lsrs	r3, r3, #8
3418599e:	f003 031f 	and.w	r3, r3, #31
341859a2:	fa01 f303 	lsl.w	r3, r1, r3
341859a6:	43db      	mvns	r3, r3
341859a8:	401a      	ands	r2, r3
341859aa:	687b      	ldr	r3, [r7, #4]
341859ac:	0c1b      	lsrs	r3, r3, #16
341859ae:	b2d9      	uxtb	r1, r3
341859b0:	687b      	ldr	r3, [r7, #4]
341859b2:	0a1b      	lsrs	r3, r3, #8
341859b4:	f003 031f 	and.w	r3, r3, #31
341859b8:	fa01 f303 	lsl.w	r3, r1, r3
341859bc:	431a      	orrs	r2, r3
341859be:	68fb      	ldr	r3, [r7, #12]
341859c0:	601a      	str	r2, [r3, #0]
}
341859c2:	bf00      	nop
341859c4:	3714      	adds	r7, #20
341859c6:	46bd      	mov	sp, r7
341859c8:	f85d 7b04 	ldr.w	r7, [sp], #4
341859cc:	4770      	bx	lr
341859ce:	bf00      	nop
341859d0:	56028144 	.word	0x56028144

341859d4 <LL_RCC_SetADFClockSource>:
{
341859d4:	b480      	push	{r7}
341859d6:	b083      	sub	sp, #12
341859d8:	af00      	add	r7, sp, #0
341859da:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
341859dc:	4b07      	ldr	r3, [pc, #28]	@ (341859fc <LL_RCC_SetADFClockSource+0x28>)
341859de:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
341859e2:	f023 0207 	bic.w	r2, r3, #7
341859e6:	4905      	ldr	r1, [pc, #20]	@ (341859fc <LL_RCC_SetADFClockSource+0x28>)
341859e8:	687b      	ldr	r3, [r7, #4]
341859ea:	4313      	orrs	r3, r2
341859ec:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
341859f0:	bf00      	nop
341859f2:	370c      	adds	r7, #12
341859f4:	46bd      	mov	sp, r7
341859f6:	f85d 7b04 	ldr.w	r7, [sp], #4
341859fa:	4770      	bx	lr
341859fc:	56028000 	.word	0x56028000

34185a00 <LL_RCC_SetCLKPClockSource>:
{
34185a00:	b480      	push	{r7}
34185a02:	b083      	sub	sp, #12
34185a04:	af00      	add	r7, sp, #0
34185a06:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
34185a08:	4b07      	ldr	r3, [pc, #28]	@ (34185a28 <LL_RCC_SetCLKPClockSource+0x28>)
34185a0a:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34185a0e:	f023 0207 	bic.w	r2, r3, #7
34185a12:	4905      	ldr	r1, [pc, #20]	@ (34185a28 <LL_RCC_SetCLKPClockSource+0x28>)
34185a14:	687b      	ldr	r3, [r7, #4]
34185a16:	4313      	orrs	r3, r2
34185a18:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34185a1c:	bf00      	nop
34185a1e:	370c      	adds	r7, #12
34185a20:	46bd      	mov	sp, r7
34185a22:	f85d 7b04 	ldr.w	r7, [sp], #4
34185a26:	4770      	bx	lr
34185a28:	56028000 	.word	0x56028000

34185a2c <LL_RCC_SetDCMIPPClockSource>:
{
34185a2c:	b480      	push	{r7}
34185a2e:	b083      	sub	sp, #12
34185a30:	af00      	add	r7, sp, #0
34185a32:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
34185a34:	4b07      	ldr	r3, [pc, #28]	@ (34185a54 <LL_RCC_SetDCMIPPClockSource+0x28>)
34185a36:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34185a3a:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
34185a3e:	4905      	ldr	r1, [pc, #20]	@ (34185a54 <LL_RCC_SetDCMIPPClockSource+0x28>)
34185a40:	687b      	ldr	r3, [r7, #4]
34185a42:	4313      	orrs	r3, r2
34185a44:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
34185a48:	bf00      	nop
34185a4a:	370c      	adds	r7, #12
34185a4c:	46bd      	mov	sp, r7
34185a4e:	f85d 7b04 	ldr.w	r7, [sp], #4
34185a52:	4770      	bx	lr
34185a54:	56028000 	.word	0x56028000

34185a58 <LL_RCC_SetETHClockSource>:
{
34185a58:	b480      	push	{r7}
34185a5a:	b083      	sub	sp, #12
34185a5c:	af00      	add	r7, sp, #0
34185a5e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
34185a60:	4b07      	ldr	r3, [pc, #28]	@ (34185a80 <LL_RCC_SetETHClockSource+0x28>)
34185a62:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34185a66:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
34185a6a:	4905      	ldr	r1, [pc, #20]	@ (34185a80 <LL_RCC_SetETHClockSource+0x28>)
34185a6c:	687b      	ldr	r3, [r7, #4]
34185a6e:	4313      	orrs	r3, r2
34185a70:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34185a74:	bf00      	nop
34185a76:	370c      	adds	r7, #12
34185a78:	46bd      	mov	sp, r7
34185a7a:	f85d 7b04 	ldr.w	r7, [sp], #4
34185a7e:	4770      	bx	lr
34185a80:	56028000 	.word	0x56028000

34185a84 <LL_RCC_SetETHPHYInterface>:
{
34185a84:	b480      	push	{r7}
34185a86:	b083      	sub	sp, #12
34185a88:	af00      	add	r7, sp, #0
34185a8a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
34185a8c:	4b07      	ldr	r3, [pc, #28]	@ (34185aac <LL_RCC_SetETHPHYInterface+0x28>)
34185a8e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34185a92:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34185a96:	4905      	ldr	r1, [pc, #20]	@ (34185aac <LL_RCC_SetETHPHYInterface+0x28>)
34185a98:	687b      	ldr	r3, [r7, #4]
34185a9a:	4313      	orrs	r3, r2
34185a9c:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34185aa0:	bf00      	nop
34185aa2:	370c      	adds	r7, #12
34185aa4:	46bd      	mov	sp, r7
34185aa6:	f85d 7b04 	ldr.w	r7, [sp], #4
34185aaa:	4770      	bx	lr
34185aac:	56028000 	.word	0x56028000

34185ab0 <LL_RCC_SetETHREFRXClockSource>:
{
34185ab0:	b480      	push	{r7}
34185ab2:	b083      	sub	sp, #12
34185ab4:	af00      	add	r7, sp, #0
34185ab6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
34185ab8:	4b07      	ldr	r3, [pc, #28]	@ (34185ad8 <LL_RCC_SetETHREFRXClockSource+0x28>)
34185aba:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34185abe:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
34185ac2:	4905      	ldr	r1, [pc, #20]	@ (34185ad8 <LL_RCC_SetETHREFRXClockSource+0x28>)
34185ac4:	687b      	ldr	r3, [r7, #4]
34185ac6:	4313      	orrs	r3, r2
34185ac8:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34185acc:	bf00      	nop
34185ace:	370c      	adds	r7, #12
34185ad0:	46bd      	mov	sp, r7
34185ad2:	f85d 7b04 	ldr.w	r7, [sp], #4
34185ad6:	4770      	bx	lr
34185ad8:	56028000 	.word	0x56028000

34185adc <LL_RCC_SetETHREFTXClockSource>:
{
34185adc:	b480      	push	{r7}
34185ade:	b083      	sub	sp, #12
34185ae0:	af00      	add	r7, sp, #0
34185ae2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
34185ae4:	4b07      	ldr	r3, [pc, #28]	@ (34185b04 <LL_RCC_SetETHREFTXClockSource+0x28>)
34185ae6:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34185aea:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34185aee:	4905      	ldr	r1, [pc, #20]	@ (34185b04 <LL_RCC_SetETHREFTXClockSource+0x28>)
34185af0:	687b      	ldr	r3, [r7, #4]
34185af2:	4313      	orrs	r3, r2
34185af4:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34185af8:	bf00      	nop
34185afa:	370c      	adds	r7, #12
34185afc:	46bd      	mov	sp, r7
34185afe:	f85d 7b04 	ldr.w	r7, [sp], #4
34185b02:	4770      	bx	lr
34185b04:	56028000 	.word	0x56028000

34185b08 <LL_RCC_SetFDCANClockSource>:
{
34185b08:	b480      	push	{r7}
34185b0a:	b083      	sub	sp, #12
34185b0c:	af00      	add	r7, sp, #0
34185b0e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
34185b10:	4b07      	ldr	r3, [pc, #28]	@ (34185b30 <LL_RCC_SetFDCANClockSource+0x28>)
34185b12:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34185b16:	f023 0203 	bic.w	r2, r3, #3
34185b1a:	4905      	ldr	r1, [pc, #20]	@ (34185b30 <LL_RCC_SetFDCANClockSource+0x28>)
34185b1c:	687b      	ldr	r3, [r7, #4]
34185b1e:	4313      	orrs	r3, r2
34185b20:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
34185b24:	bf00      	nop
34185b26:	370c      	adds	r7, #12
34185b28:	46bd      	mov	sp, r7
34185b2a:	f85d 7b04 	ldr.w	r7, [sp], #4
34185b2e:	4770      	bx	lr
34185b30:	56028000 	.word	0x56028000

34185b34 <LL_RCC_SetFMCClockSource>:
{
34185b34:	b480      	push	{r7}
34185b36:	b083      	sub	sp, #12
34185b38:	af00      	add	r7, sp, #0
34185b3a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
34185b3c:	4b07      	ldr	r3, [pc, #28]	@ (34185b5c <LL_RCC_SetFMCClockSource+0x28>)
34185b3e:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34185b42:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
34185b46:	4905      	ldr	r1, [pc, #20]	@ (34185b5c <LL_RCC_SetFMCClockSource+0x28>)
34185b48:	687b      	ldr	r3, [r7, #4]
34185b4a:	4313      	orrs	r3, r2
34185b4c:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
34185b50:	bf00      	nop
34185b52:	370c      	adds	r7, #12
34185b54:	46bd      	mov	sp, r7
34185b56:	f85d 7b04 	ldr.w	r7, [sp], #4
34185b5a:	4770      	bx	lr
34185b5c:	56028000 	.word	0x56028000

34185b60 <LL_RCC_SetI2CClockSource>:
{
34185b60:	b580      	push	{r7, lr}
34185b62:	b082      	sub	sp, #8
34185b64:	af00      	add	r7, sp, #0
34185b66:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34185b68:	6878      	ldr	r0, [r7, #4]
34185b6a:	f7ff ff09 	bl	34185980 <LL_RCC_SetClockSource>
}
34185b6e:	bf00      	nop
34185b70:	3708      	adds	r7, #8
34185b72:	46bd      	mov	sp, r7
34185b74:	bd80      	pop	{r7, pc}

34185b76 <LL_RCC_SetI3CClockSource>:
{
34185b76:	b580      	push	{r7, lr}
34185b78:	b082      	sub	sp, #8
34185b7a:	af00      	add	r7, sp, #0
34185b7c:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34185b7e:	6878      	ldr	r0, [r7, #4]
34185b80:	f7ff fefe 	bl	34185980 <LL_RCC_SetClockSource>
}
34185b84:	bf00      	nop
34185b86:	3708      	adds	r7, #8
34185b88:	46bd      	mov	sp, r7
34185b8a:	bd80      	pop	{r7, pc}

34185b8c <LL_RCC_SetLPTIMClockSource>:
{
34185b8c:	b580      	push	{r7, lr}
34185b8e:	b082      	sub	sp, #8
34185b90:	af00      	add	r7, sp, #0
34185b92:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34185b94:	6878      	ldr	r0, [r7, #4]
34185b96:	f7ff fef3 	bl	34185980 <LL_RCC_SetClockSource>
}
34185b9a:	bf00      	nop
34185b9c:	3708      	adds	r7, #8
34185b9e:	46bd      	mov	sp, r7
34185ba0:	bd80      	pop	{r7, pc}
	...

34185ba4 <LL_RCC_SetLPUARTClockSource>:
{
34185ba4:	b480      	push	{r7}
34185ba6:	b083      	sub	sp, #12
34185ba8:	af00      	add	r7, sp, #0
34185baa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
34185bac:	4b07      	ldr	r3, [pc, #28]	@ (34185bcc <LL_RCC_SetLPUARTClockSource+0x28>)
34185bae:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34185bb2:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
34185bb6:	4905      	ldr	r1, [pc, #20]	@ (34185bcc <LL_RCC_SetLPUARTClockSource+0x28>)
34185bb8:	687b      	ldr	r3, [r7, #4]
34185bba:	4313      	orrs	r3, r2
34185bbc:	f8c1 3178 	str.w	r3, [r1, #376]	@ 0x178
}
34185bc0:	bf00      	nop
34185bc2:	370c      	adds	r7, #12
34185bc4:	46bd      	mov	sp, r7
34185bc6:	f85d 7b04 	ldr.w	r7, [sp], #4
34185bca:	4770      	bx	lr
34185bcc:	56028000 	.word	0x56028000

34185bd0 <LL_RCC_SetLTDCClockSource>:
{
34185bd0:	b480      	push	{r7}
34185bd2:	b083      	sub	sp, #12
34185bd4:	af00      	add	r7, sp, #0
34185bd6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
34185bd8:	4b07      	ldr	r3, [pc, #28]	@ (34185bf8 <LL_RCC_SetLTDCClockSource+0x28>)
34185bda:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
34185bde:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34185be2:	4905      	ldr	r1, [pc, #20]	@ (34185bf8 <LL_RCC_SetLTDCClockSource+0x28>)
34185be4:	687b      	ldr	r3, [r7, #4]
34185be6:	4313      	orrs	r3, r2
34185be8:	f8c1 3150 	str.w	r3, [r1, #336]	@ 0x150
}
34185bec:	bf00      	nop
34185bee:	370c      	adds	r7, #12
34185bf0:	46bd      	mov	sp, r7
34185bf2:	f85d 7b04 	ldr.w	r7, [sp], #4
34185bf6:	4770      	bx	lr
34185bf8:	56028000 	.word	0x56028000

34185bfc <LL_RCC_SetMDFClockSource>:
{
34185bfc:	b480      	push	{r7}
34185bfe:	b083      	sub	sp, #12
34185c00:	af00      	add	r7, sp, #0
34185c02:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
34185c04:	4b07      	ldr	r3, [pc, #28]	@ (34185c24 <LL_RCC_SetMDFClockSource+0x28>)
34185c06:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
34185c0a:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34185c0e:	4905      	ldr	r1, [pc, #20]	@ (34185c24 <LL_RCC_SetMDFClockSource+0x28>)
34185c10:	687b      	ldr	r3, [r7, #4]
34185c12:	4313      	orrs	r3, r2
34185c14:	f8c1 3154 	str.w	r3, [r1, #340]	@ 0x154
}
34185c18:	bf00      	nop
34185c1a:	370c      	adds	r7, #12
34185c1c:	46bd      	mov	sp, r7
34185c1e:	f85d 7b04 	ldr.w	r7, [sp], #4
34185c22:	4770      	bx	lr
34185c24:	56028000 	.word	0x56028000

34185c28 <LL_RCC_SetOTGPHYClockSource>:
{
34185c28:	b580      	push	{r7, lr}
34185c2a:	b082      	sub	sp, #8
34185c2c:	af00      	add	r7, sp, #0
34185c2e:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34185c30:	6878      	ldr	r0, [r7, #4]
34185c32:	f7ff fea5 	bl	34185980 <LL_RCC_SetClockSource>
}
34185c36:	bf00      	nop
34185c38:	3708      	adds	r7, #8
34185c3a:	46bd      	mov	sp, r7
34185c3c:	bd80      	pop	{r7, pc}

34185c3e <LL_RCC_SetOTGPHYCKREFClockSource>:
{
34185c3e:	b580      	push	{r7, lr}
34185c40:	b082      	sub	sp, #8
34185c42:	af00      	add	r7, sp, #0
34185c44:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34185c46:	6878      	ldr	r0, [r7, #4]
34185c48:	f7ff fe9a 	bl	34185980 <LL_RCC_SetClockSource>
}
34185c4c:	bf00      	nop
34185c4e:	3708      	adds	r7, #8
34185c50:	46bd      	mov	sp, r7
34185c52:	bd80      	pop	{r7, pc}

34185c54 <LL_RCC_SetPSSIClockSource>:
{
34185c54:	b480      	push	{r7}
34185c56:	b083      	sub	sp, #12
34185c58:	af00      	add	r7, sp, #0
34185c5a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
34185c5c:	4b07      	ldr	r3, [pc, #28]	@ (34185c7c <LL_RCC_SetPSSIClockSource+0x28>)
34185c5e:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34185c62:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
34185c66:	4905      	ldr	r1, [pc, #20]	@ (34185c7c <LL_RCC_SetPSSIClockSource+0x28>)
34185c68:	687b      	ldr	r3, [r7, #4]
34185c6a:	4313      	orrs	r3, r2
34185c6c:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34185c70:	bf00      	nop
34185c72:	370c      	adds	r7, #12
34185c74:	46bd      	mov	sp, r7
34185c76:	f85d 7b04 	ldr.w	r7, [sp], #4
34185c7a:	4770      	bx	lr
34185c7c:	56028000 	.word	0x56028000

34185c80 <LL_RCC_SetSAIClockSource>:
{
34185c80:	b580      	push	{r7, lr}
34185c82:	b082      	sub	sp, #8
34185c84:	af00      	add	r7, sp, #0
34185c86:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34185c88:	6878      	ldr	r0, [r7, #4]
34185c8a:	f7ff fe79 	bl	34185980 <LL_RCC_SetClockSource>
}
34185c8e:	bf00      	nop
34185c90:	3708      	adds	r7, #8
34185c92:	46bd      	mov	sp, r7
34185c94:	bd80      	pop	{r7, pc}

34185c96 <LL_RCC_SetSDMMCClockSource>:
{
34185c96:	b580      	push	{r7, lr}
34185c98:	b082      	sub	sp, #8
34185c9a:	af00      	add	r7, sp, #0
34185c9c:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34185c9e:	6878      	ldr	r0, [r7, #4]
34185ca0:	f7ff fe6e 	bl	34185980 <LL_RCC_SetClockSource>
}
34185ca4:	bf00      	nop
34185ca6:	3708      	adds	r7, #8
34185ca8:	46bd      	mov	sp, r7
34185caa:	bd80      	pop	{r7, pc}

34185cac <LL_RCC_SetSPDIFRXClockSource>:
{
34185cac:	b480      	push	{r7}
34185cae:	b083      	sub	sp, #12
34185cb0:	af00      	add	r7, sp, #0
34185cb2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
34185cb4:	4b07      	ldr	r3, [pc, #28]	@ (34185cd4 <LL_RCC_SetSPDIFRXClockSource+0x28>)
34185cb6:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
34185cba:	f023 0207 	bic.w	r2, r3, #7
34185cbe:	4905      	ldr	r1, [pc, #20]	@ (34185cd4 <LL_RCC_SetSPDIFRXClockSource+0x28>)
34185cc0:	687b      	ldr	r3, [r7, #4]
34185cc2:	4313      	orrs	r3, r2
34185cc4:	f8c1 3164 	str.w	r3, [r1, #356]	@ 0x164
}
34185cc8:	bf00      	nop
34185cca:	370c      	adds	r7, #12
34185ccc:	46bd      	mov	sp, r7
34185cce:	f85d 7b04 	ldr.w	r7, [sp], #4
34185cd2:	4770      	bx	lr
34185cd4:	56028000 	.word	0x56028000

34185cd8 <LL_RCC_SetSPIClockSource>:
{
34185cd8:	b580      	push	{r7, lr}
34185cda:	b082      	sub	sp, #8
34185cdc:	af00      	add	r7, sp, #0
34185cde:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34185ce0:	6878      	ldr	r0, [r7, #4]
34185ce2:	f7ff fe4d 	bl	34185980 <LL_RCC_SetClockSource>
}
34185ce6:	bf00      	nop
34185ce8:	3708      	adds	r7, #8
34185cea:	46bd      	mov	sp, r7
34185cec:	bd80      	pop	{r7, pc}

34185cee <LL_RCC_SetUSARTClockSource>:
{
34185cee:	b580      	push	{r7, lr}
34185cf0:	b082      	sub	sp, #8
34185cf2:	af00      	add	r7, sp, #0
34185cf4:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34185cf6:	6878      	ldr	r0, [r7, #4]
34185cf8:	f7ff fe42 	bl	34185980 <LL_RCC_SetClockSource>
}
34185cfc:	bf00      	nop
34185cfe:	3708      	adds	r7, #8
34185d00:	46bd      	mov	sp, r7
34185d02:	bd80      	pop	{r7, pc}

34185d04 <LL_RCC_SetXSPIClockSource>:
{
34185d04:	b580      	push	{r7, lr}
34185d06:	b082      	sub	sp, #8
34185d08:	af00      	add	r7, sp, #0
34185d0a:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34185d0c:	6878      	ldr	r0, [r7, #4]
34185d0e:	f7ff fe37 	bl	34185980 <LL_RCC_SetClockSource>
}
34185d12:	bf00      	nop
34185d14:	3708      	adds	r7, #8
34185d16:	46bd      	mov	sp, r7
34185d18:	bd80      	pop	{r7, pc}
	...

34185d1c <LL_RCC_SetRTCClockSource>:
{
34185d1c:	b480      	push	{r7}
34185d1e:	b083      	sub	sp, #12
34185d20:	af00      	add	r7, sp, #0
34185d22:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
34185d24:	4b07      	ldr	r3, [pc, #28]	@ (34185d44 <LL_RCC_SetRTCClockSource+0x28>)
34185d26:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34185d2a:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
34185d2e:	4905      	ldr	r1, [pc, #20]	@ (34185d44 <LL_RCC_SetRTCClockSource+0x28>)
34185d30:	687b      	ldr	r3, [r7, #4]
34185d32:	4313      	orrs	r3, r2
34185d34:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34185d38:	bf00      	nop
34185d3a:	370c      	adds	r7, #12
34185d3c:	46bd      	mov	sp, r7
34185d3e:	f85d 7b04 	ldr.w	r7, [sp], #4
34185d42:	4770      	bx	lr
34185d44:	56028000 	.word	0x56028000

34185d48 <LL_RCC_GetRTCClockSource>:
{
34185d48:	b480      	push	{r7}
34185d4a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
34185d4c:	4b04      	ldr	r3, [pc, #16]	@ (34185d60 <LL_RCC_GetRTCClockSource+0x18>)
34185d4e:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34185d52:	f403 7340 	and.w	r3, r3, #768	@ 0x300
}
34185d56:	4618      	mov	r0, r3
34185d58:	46bd      	mov	sp, r7
34185d5a:	f85d 7b04 	ldr.w	r7, [sp], #4
34185d5e:	4770      	bx	lr
34185d60:	56028000 	.word	0x56028000

34185d64 <LL_RCC_SetRTC_HSEPrescaler>:
{
34185d64:	b480      	push	{r7}
34185d66:	b083      	sub	sp, #12
34185d68:	af00      	add	r7, sp, #0
34185d6a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
34185d6c:	4b07      	ldr	r3, [pc, #28]	@ (34185d8c <LL_RCC_SetRTC_HSEPrescaler+0x28>)
34185d6e:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34185d72:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
34185d76:	4905      	ldr	r1, [pc, #20]	@ (34185d8c <LL_RCC_SetRTC_HSEPrescaler+0x28>)
34185d78:	687b      	ldr	r3, [r7, #4]
34185d7a:	4313      	orrs	r3, r2
34185d7c:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34185d80:	bf00      	nop
34185d82:	370c      	adds	r7, #12
34185d84:	46bd      	mov	sp, r7
34185d86:	f85d 7b04 	ldr.w	r7, [sp], #4
34185d8a:	4770      	bx	lr
34185d8c:	56028000 	.word	0x56028000

34185d90 <LL_RCC_SetTIMPrescaler>:
{
34185d90:	b480      	push	{r7}
34185d92:	b083      	sub	sp, #12
34185d94:	af00      	add	r7, sp, #0
34185d96:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
34185d98:	4b07      	ldr	r3, [pc, #28]	@ (34185db8 <LL_RCC_SetTIMPrescaler+0x28>)
34185d9a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34185d9c:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34185da0:	687b      	ldr	r3, [r7, #4]
34185da2:	061b      	lsls	r3, r3, #24
34185da4:	4904      	ldr	r1, [pc, #16]	@ (34185db8 <LL_RCC_SetTIMPrescaler+0x28>)
34185da6:	4313      	orrs	r3, r2
34185da8:	624b      	str	r3, [r1, #36]	@ 0x24
}
34185daa:	bf00      	nop
34185dac:	370c      	adds	r7, #12
34185dae:	46bd      	mov	sp, r7
34185db0:	f85d 7b04 	ldr.w	r7, [sp], #4
34185db4:	4770      	bx	lr
34185db6:	bf00      	nop
34185db8:	56028000 	.word	0x56028000

34185dbc <LL_RCC_PLL1_GetSource>:
{
34185dbc:	b480      	push	{r7}
34185dbe:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
34185dc0:	4b04      	ldr	r3, [pc, #16]	@ (34185dd4 <LL_RCC_PLL1_GetSource+0x18>)
34185dc2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34185dc6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34185dca:	4618      	mov	r0, r3
34185dcc:	46bd      	mov	sp, r7
34185dce:	f85d 7b04 	ldr.w	r7, [sp], #4
34185dd2:	4770      	bx	lr
34185dd4:	56028000 	.word	0x56028000

34185dd8 <LL_RCC_PLL1_IsReady>:
{
34185dd8:	b480      	push	{r7}
34185dda:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
34185ddc:	4b07      	ldr	r3, [pc, #28]	@ (34185dfc <LL_RCC_PLL1_IsReady+0x24>)
34185dde:	685b      	ldr	r3, [r3, #4]
34185de0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34185de4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34185de8:	d101      	bne.n	34185dee <LL_RCC_PLL1_IsReady+0x16>
34185dea:	2301      	movs	r3, #1
34185dec:	e000      	b.n	34185df0 <LL_RCC_PLL1_IsReady+0x18>
34185dee:	2300      	movs	r3, #0
}
34185df0:	4618      	mov	r0, r3
34185df2:	46bd      	mov	sp, r7
34185df4:	f85d 7b04 	ldr.w	r7, [sp], #4
34185df8:	4770      	bx	lr
34185dfa:	bf00      	nop
34185dfc:	56028000 	.word	0x56028000

34185e00 <LL_RCC_PLL1_IsEnabledBypass>:
{
34185e00:	b480      	push	{r7}
34185e02:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
34185e04:	4b07      	ldr	r3, [pc, #28]	@ (34185e24 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
34185e06:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34185e0a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34185e0e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34185e12:	d101      	bne.n	34185e18 <LL_RCC_PLL1_IsEnabledBypass+0x18>
34185e14:	2301      	movs	r3, #1
34185e16:	e000      	b.n	34185e1a <LL_RCC_PLL1_IsEnabledBypass+0x1a>
34185e18:	2300      	movs	r3, #0
}
34185e1a:	4618      	mov	r0, r3
34185e1c:	46bd      	mov	sp, r7
34185e1e:	f85d 7b04 	ldr.w	r7, [sp], #4
34185e22:	4770      	bx	lr
34185e24:	56028000 	.word	0x56028000

34185e28 <LL_RCC_PLL1_GetN>:
{
34185e28:	b480      	push	{r7}
34185e2a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
34185e2c:	4b05      	ldr	r3, [pc, #20]	@ (34185e44 <LL_RCC_PLL1_GetN+0x1c>)
34185e2e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34185e32:	0a1b      	lsrs	r3, r3, #8
34185e34:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34185e38:	4618      	mov	r0, r3
34185e3a:	46bd      	mov	sp, r7
34185e3c:	f85d 7b04 	ldr.w	r7, [sp], #4
34185e40:	4770      	bx	lr
34185e42:	bf00      	nop
34185e44:	56028000 	.word	0x56028000

34185e48 <LL_RCC_PLL1_GetM>:
{
34185e48:	b480      	push	{r7}
34185e4a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
34185e4c:	4b05      	ldr	r3, [pc, #20]	@ (34185e64 <LL_RCC_PLL1_GetM+0x1c>)
34185e4e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34185e52:	0d1b      	lsrs	r3, r3, #20
34185e54:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34185e58:	4618      	mov	r0, r3
34185e5a:	46bd      	mov	sp, r7
34185e5c:	f85d 7b04 	ldr.w	r7, [sp], #4
34185e60:	4770      	bx	lr
34185e62:	bf00      	nop
34185e64:	56028000 	.word	0x56028000

34185e68 <LL_RCC_PLL1_GetP1>:
{
34185e68:	b480      	push	{r7}
34185e6a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
34185e6c:	4b05      	ldr	r3, [pc, #20]	@ (34185e84 <LL_RCC_PLL1_GetP1+0x1c>)
34185e6e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34185e72:	0edb      	lsrs	r3, r3, #27
34185e74:	f003 0307 	and.w	r3, r3, #7
}
34185e78:	4618      	mov	r0, r3
34185e7a:	46bd      	mov	sp, r7
34185e7c:	f85d 7b04 	ldr.w	r7, [sp], #4
34185e80:	4770      	bx	lr
34185e82:	bf00      	nop
34185e84:	56028000 	.word	0x56028000

34185e88 <LL_RCC_PLL1_GetP2>:
{
34185e88:	b480      	push	{r7}
34185e8a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
34185e8c:	4b05      	ldr	r3, [pc, #20]	@ (34185ea4 <LL_RCC_PLL1_GetP2+0x1c>)
34185e8e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34185e92:	0e1b      	lsrs	r3, r3, #24
34185e94:	f003 0307 	and.w	r3, r3, #7
}
34185e98:	4618      	mov	r0, r3
34185e9a:	46bd      	mov	sp, r7
34185e9c:	f85d 7b04 	ldr.w	r7, [sp], #4
34185ea0:	4770      	bx	lr
34185ea2:	bf00      	nop
34185ea4:	56028000 	.word	0x56028000

34185ea8 <LL_RCC_PLL1P_IsEnabled>:
{
34185ea8:	b480      	push	{r7}
34185eaa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
34185eac:	4b07      	ldr	r3, [pc, #28]	@ (34185ecc <LL_RCC_PLL1P_IsEnabled+0x24>)
34185eae:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34185eb2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34185eb6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34185eba:	d101      	bne.n	34185ec0 <LL_RCC_PLL1P_IsEnabled+0x18>
34185ebc:	2301      	movs	r3, #1
34185ebe:	e000      	b.n	34185ec2 <LL_RCC_PLL1P_IsEnabled+0x1a>
34185ec0:	2300      	movs	r3, #0
}
34185ec2:	4618      	mov	r0, r3
34185ec4:	46bd      	mov	sp, r7
34185ec6:	f85d 7b04 	ldr.w	r7, [sp], #4
34185eca:	4770      	bx	lr
34185ecc:	56028000 	.word	0x56028000

34185ed0 <LL_RCC_PLL1_GetFRACN>:
{
34185ed0:	b480      	push	{r7}
34185ed2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
34185ed4:	4b04      	ldr	r3, [pc, #16]	@ (34185ee8 <LL_RCC_PLL1_GetFRACN+0x18>)
34185ed6:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34185eda:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
34185ede:	4618      	mov	r0, r3
34185ee0:	46bd      	mov	sp, r7
34185ee2:	f85d 7b04 	ldr.w	r7, [sp], #4
34185ee6:	4770      	bx	lr
34185ee8:	56028000 	.word	0x56028000

34185eec <LL_RCC_PLL2_GetSource>:
{
34185eec:	b480      	push	{r7}
34185eee:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
34185ef0:	4b04      	ldr	r3, [pc, #16]	@ (34185f04 <LL_RCC_PLL2_GetSource+0x18>)
34185ef2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34185ef6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34185efa:	4618      	mov	r0, r3
34185efc:	46bd      	mov	sp, r7
34185efe:	f85d 7b04 	ldr.w	r7, [sp], #4
34185f02:	4770      	bx	lr
34185f04:	56028000 	.word	0x56028000

34185f08 <LL_RCC_PLL2_IsReady>:
{
34185f08:	b480      	push	{r7}
34185f0a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34185f0c:	4b07      	ldr	r3, [pc, #28]	@ (34185f2c <LL_RCC_PLL2_IsReady+0x24>)
34185f0e:	685b      	ldr	r3, [r3, #4]
34185f10:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34185f14:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34185f18:	d101      	bne.n	34185f1e <LL_RCC_PLL2_IsReady+0x16>
34185f1a:	2301      	movs	r3, #1
34185f1c:	e000      	b.n	34185f20 <LL_RCC_PLL2_IsReady+0x18>
34185f1e:	2300      	movs	r3, #0
}
34185f20:	4618      	mov	r0, r3
34185f22:	46bd      	mov	sp, r7
34185f24:	f85d 7b04 	ldr.w	r7, [sp], #4
34185f28:	4770      	bx	lr
34185f2a:	bf00      	nop
34185f2c:	56028000 	.word	0x56028000

34185f30 <LL_RCC_PLL2_IsEnabledBypass>:
{
34185f30:	b480      	push	{r7}
34185f32:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34185f34:	4b07      	ldr	r3, [pc, #28]	@ (34185f54 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
34185f36:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34185f3a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34185f3e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34185f42:	d101      	bne.n	34185f48 <LL_RCC_PLL2_IsEnabledBypass+0x18>
34185f44:	2301      	movs	r3, #1
34185f46:	e000      	b.n	34185f4a <LL_RCC_PLL2_IsEnabledBypass+0x1a>
34185f48:	2300      	movs	r3, #0
}
34185f4a:	4618      	mov	r0, r3
34185f4c:	46bd      	mov	sp, r7
34185f4e:	f85d 7b04 	ldr.w	r7, [sp], #4
34185f52:	4770      	bx	lr
34185f54:	56028000 	.word	0x56028000

34185f58 <LL_RCC_PLL2_GetN>:
{
34185f58:	b480      	push	{r7}
34185f5a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
34185f5c:	4b05      	ldr	r3, [pc, #20]	@ (34185f74 <LL_RCC_PLL2_GetN+0x1c>)
34185f5e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34185f62:	0a1b      	lsrs	r3, r3, #8
34185f64:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34185f68:	4618      	mov	r0, r3
34185f6a:	46bd      	mov	sp, r7
34185f6c:	f85d 7b04 	ldr.w	r7, [sp], #4
34185f70:	4770      	bx	lr
34185f72:	bf00      	nop
34185f74:	56028000 	.word	0x56028000

34185f78 <LL_RCC_PLL2_GetM>:
{
34185f78:	b480      	push	{r7}
34185f7a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
34185f7c:	4b05      	ldr	r3, [pc, #20]	@ (34185f94 <LL_RCC_PLL2_GetM+0x1c>)
34185f7e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34185f82:	0d1b      	lsrs	r3, r3, #20
34185f84:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34185f88:	4618      	mov	r0, r3
34185f8a:	46bd      	mov	sp, r7
34185f8c:	f85d 7b04 	ldr.w	r7, [sp], #4
34185f90:	4770      	bx	lr
34185f92:	bf00      	nop
34185f94:	56028000 	.word	0x56028000

34185f98 <LL_RCC_PLL2_GetP1>:
{
34185f98:	b480      	push	{r7}
34185f9a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
34185f9c:	4b05      	ldr	r3, [pc, #20]	@ (34185fb4 <LL_RCC_PLL2_GetP1+0x1c>)
34185f9e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34185fa2:	0edb      	lsrs	r3, r3, #27
34185fa4:	f003 0307 	and.w	r3, r3, #7
}
34185fa8:	4618      	mov	r0, r3
34185faa:	46bd      	mov	sp, r7
34185fac:	f85d 7b04 	ldr.w	r7, [sp], #4
34185fb0:	4770      	bx	lr
34185fb2:	bf00      	nop
34185fb4:	56028000 	.word	0x56028000

34185fb8 <LL_RCC_PLL2_GetP2>:
{
34185fb8:	b480      	push	{r7}
34185fba:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
34185fbc:	4b05      	ldr	r3, [pc, #20]	@ (34185fd4 <LL_RCC_PLL2_GetP2+0x1c>)
34185fbe:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34185fc2:	0e1b      	lsrs	r3, r3, #24
34185fc4:	f003 0307 	and.w	r3, r3, #7
}
34185fc8:	4618      	mov	r0, r3
34185fca:	46bd      	mov	sp, r7
34185fcc:	f85d 7b04 	ldr.w	r7, [sp], #4
34185fd0:	4770      	bx	lr
34185fd2:	bf00      	nop
34185fd4:	56028000 	.word	0x56028000

34185fd8 <LL_RCC_PLL2P_IsEnabled>:
{
34185fd8:	b480      	push	{r7}
34185fda:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
34185fdc:	4b07      	ldr	r3, [pc, #28]	@ (34185ffc <LL_RCC_PLL2P_IsEnabled+0x24>)
34185fde:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34185fe2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34185fe6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34185fea:	d101      	bne.n	34185ff0 <LL_RCC_PLL2P_IsEnabled+0x18>
34185fec:	2301      	movs	r3, #1
34185fee:	e000      	b.n	34185ff2 <LL_RCC_PLL2P_IsEnabled+0x1a>
34185ff0:	2300      	movs	r3, #0
}
34185ff2:	4618      	mov	r0, r3
34185ff4:	46bd      	mov	sp, r7
34185ff6:	f85d 7b04 	ldr.w	r7, [sp], #4
34185ffa:	4770      	bx	lr
34185ffc:	56028000 	.word	0x56028000

34186000 <LL_RCC_PLL2_GetFRACN>:
{
34186000:	b480      	push	{r7}
34186002:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
34186004:	4b04      	ldr	r3, [pc, #16]	@ (34186018 <LL_RCC_PLL2_GetFRACN+0x18>)
34186006:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3418600a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3418600e:	4618      	mov	r0, r3
34186010:	46bd      	mov	sp, r7
34186012:	f85d 7b04 	ldr.w	r7, [sp], #4
34186016:	4770      	bx	lr
34186018:	56028000 	.word	0x56028000

3418601c <LL_RCC_PLL3_GetSource>:
{
3418601c:	b480      	push	{r7}
3418601e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
34186020:	4b04      	ldr	r3, [pc, #16]	@ (34186034 <LL_RCC_PLL3_GetSource+0x18>)
34186022:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34186026:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418602a:	4618      	mov	r0, r3
3418602c:	46bd      	mov	sp, r7
3418602e:	f85d 7b04 	ldr.w	r7, [sp], #4
34186032:	4770      	bx	lr
34186034:	56028000 	.word	0x56028000

34186038 <LL_RCC_PLL3_IsReady>:
{
34186038:	b480      	push	{r7}
3418603a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3418603c:	4b07      	ldr	r3, [pc, #28]	@ (3418605c <LL_RCC_PLL3_IsReady+0x24>)
3418603e:	685b      	ldr	r3, [r3, #4]
34186040:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34186044:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34186048:	d101      	bne.n	3418604e <LL_RCC_PLL3_IsReady+0x16>
3418604a:	2301      	movs	r3, #1
3418604c:	e000      	b.n	34186050 <LL_RCC_PLL3_IsReady+0x18>
3418604e:	2300      	movs	r3, #0
}
34186050:	4618      	mov	r0, r3
34186052:	46bd      	mov	sp, r7
34186054:	f85d 7b04 	ldr.w	r7, [sp], #4
34186058:	4770      	bx	lr
3418605a:	bf00      	nop
3418605c:	56028000 	.word	0x56028000

34186060 <LL_RCC_PLL3_IsEnabledBypass>:
{
34186060:	b480      	push	{r7}
34186062:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
34186064:	4b07      	ldr	r3, [pc, #28]	@ (34186084 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
34186066:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418606a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418606e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34186072:	d101      	bne.n	34186078 <LL_RCC_PLL3_IsEnabledBypass+0x18>
34186074:	2301      	movs	r3, #1
34186076:	e000      	b.n	3418607a <LL_RCC_PLL3_IsEnabledBypass+0x1a>
34186078:	2300      	movs	r3, #0
}
3418607a:	4618      	mov	r0, r3
3418607c:	46bd      	mov	sp, r7
3418607e:	f85d 7b04 	ldr.w	r7, [sp], #4
34186082:	4770      	bx	lr
34186084:	56028000 	.word	0x56028000

34186088 <LL_RCC_PLL3_GetN>:
{
34186088:	b480      	push	{r7}
3418608a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
3418608c:	4b05      	ldr	r3, [pc, #20]	@ (341860a4 <LL_RCC_PLL3_GetN+0x1c>)
3418608e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34186092:	0a1b      	lsrs	r3, r3, #8
34186094:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34186098:	4618      	mov	r0, r3
3418609a:	46bd      	mov	sp, r7
3418609c:	f85d 7b04 	ldr.w	r7, [sp], #4
341860a0:	4770      	bx	lr
341860a2:	bf00      	nop
341860a4:	56028000 	.word	0x56028000

341860a8 <LL_RCC_PLL3_GetM>:
{
341860a8:	b480      	push	{r7}
341860aa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
341860ac:	4b05      	ldr	r3, [pc, #20]	@ (341860c4 <LL_RCC_PLL3_GetM+0x1c>)
341860ae:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
341860b2:	0d1b      	lsrs	r3, r3, #20
341860b4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
341860b8:	4618      	mov	r0, r3
341860ba:	46bd      	mov	sp, r7
341860bc:	f85d 7b04 	ldr.w	r7, [sp], #4
341860c0:	4770      	bx	lr
341860c2:	bf00      	nop
341860c4:	56028000 	.word	0x56028000

341860c8 <LL_RCC_PLL3_GetP1>:
{
341860c8:	b480      	push	{r7}
341860ca:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
341860cc:	4b05      	ldr	r3, [pc, #20]	@ (341860e4 <LL_RCC_PLL3_GetP1+0x1c>)
341860ce:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
341860d2:	0edb      	lsrs	r3, r3, #27
341860d4:	f003 0307 	and.w	r3, r3, #7
}
341860d8:	4618      	mov	r0, r3
341860da:	46bd      	mov	sp, r7
341860dc:	f85d 7b04 	ldr.w	r7, [sp], #4
341860e0:	4770      	bx	lr
341860e2:	bf00      	nop
341860e4:	56028000 	.word	0x56028000

341860e8 <LL_RCC_PLL3_GetP2>:
{
341860e8:	b480      	push	{r7}
341860ea:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
341860ec:	4b05      	ldr	r3, [pc, #20]	@ (34186104 <LL_RCC_PLL3_GetP2+0x1c>)
341860ee:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
341860f2:	0e1b      	lsrs	r3, r3, #24
341860f4:	f003 0307 	and.w	r3, r3, #7
}
341860f8:	4618      	mov	r0, r3
341860fa:	46bd      	mov	sp, r7
341860fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34186100:	4770      	bx	lr
34186102:	bf00      	nop
34186104:	56028000 	.word	0x56028000

34186108 <LL_RCC_PLL3P_IsEnabled>:
{
34186108:	b480      	push	{r7}
3418610a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
3418610c:	4b07      	ldr	r3, [pc, #28]	@ (3418612c <LL_RCC_PLL3P_IsEnabled+0x24>)
3418610e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34186112:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34186116:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3418611a:	d101      	bne.n	34186120 <LL_RCC_PLL3P_IsEnabled+0x18>
3418611c:	2301      	movs	r3, #1
3418611e:	e000      	b.n	34186122 <LL_RCC_PLL3P_IsEnabled+0x1a>
34186120:	2300      	movs	r3, #0
}
34186122:	4618      	mov	r0, r3
34186124:	46bd      	mov	sp, r7
34186126:	f85d 7b04 	ldr.w	r7, [sp], #4
3418612a:	4770      	bx	lr
3418612c:	56028000 	.word	0x56028000

34186130 <LL_RCC_PLL3_GetFRACN>:
{
34186130:	b480      	push	{r7}
34186132:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
34186134:	4b04      	ldr	r3, [pc, #16]	@ (34186148 <LL_RCC_PLL3_GetFRACN+0x18>)
34186136:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3418613a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3418613e:	4618      	mov	r0, r3
34186140:	46bd      	mov	sp, r7
34186142:	f85d 7b04 	ldr.w	r7, [sp], #4
34186146:	4770      	bx	lr
34186148:	56028000 	.word	0x56028000

3418614c <LL_RCC_PLL4_GetSource>:
{
3418614c:	b480      	push	{r7}
3418614e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
34186150:	4b04      	ldr	r3, [pc, #16]	@ (34186164 <LL_RCC_PLL4_GetSource+0x18>)
34186152:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34186156:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418615a:	4618      	mov	r0, r3
3418615c:	46bd      	mov	sp, r7
3418615e:	f85d 7b04 	ldr.w	r7, [sp], #4
34186162:	4770      	bx	lr
34186164:	56028000 	.word	0x56028000

34186168 <LL_RCC_PLL4_IsReady>:
{
34186168:	b480      	push	{r7}
3418616a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3418616c:	4b07      	ldr	r3, [pc, #28]	@ (3418618c <LL_RCC_PLL4_IsReady+0x24>)
3418616e:	685b      	ldr	r3, [r3, #4]
34186170:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34186174:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34186178:	d101      	bne.n	3418617e <LL_RCC_PLL4_IsReady+0x16>
3418617a:	2301      	movs	r3, #1
3418617c:	e000      	b.n	34186180 <LL_RCC_PLL4_IsReady+0x18>
3418617e:	2300      	movs	r3, #0
}
34186180:	4618      	mov	r0, r3
34186182:	46bd      	mov	sp, r7
34186184:	f85d 7b04 	ldr.w	r7, [sp], #4
34186188:	4770      	bx	lr
3418618a:	bf00      	nop
3418618c:	56028000 	.word	0x56028000

34186190 <LL_RCC_PLL4_IsEnabledBypass>:
{
34186190:	b480      	push	{r7}
34186192:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34186194:	4b07      	ldr	r3, [pc, #28]	@ (341861b4 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
34186196:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418619a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418619e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341861a2:	d101      	bne.n	341861a8 <LL_RCC_PLL4_IsEnabledBypass+0x18>
341861a4:	2301      	movs	r3, #1
341861a6:	e000      	b.n	341861aa <LL_RCC_PLL4_IsEnabledBypass+0x1a>
341861a8:	2300      	movs	r3, #0
}
341861aa:	4618      	mov	r0, r3
341861ac:	46bd      	mov	sp, r7
341861ae:	f85d 7b04 	ldr.w	r7, [sp], #4
341861b2:	4770      	bx	lr
341861b4:	56028000 	.word	0x56028000

341861b8 <LL_RCC_PLL4_GetN>:
{
341861b8:	b480      	push	{r7}
341861ba:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
341861bc:	4b05      	ldr	r3, [pc, #20]	@ (341861d4 <LL_RCC_PLL4_GetN+0x1c>)
341861be:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
341861c2:	0a1b      	lsrs	r3, r3, #8
341861c4:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
341861c8:	4618      	mov	r0, r3
341861ca:	46bd      	mov	sp, r7
341861cc:	f85d 7b04 	ldr.w	r7, [sp], #4
341861d0:	4770      	bx	lr
341861d2:	bf00      	nop
341861d4:	56028000 	.word	0x56028000

341861d8 <LL_RCC_PLL4_GetM>:
{
341861d8:	b480      	push	{r7}
341861da:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
341861dc:	4b05      	ldr	r3, [pc, #20]	@ (341861f4 <LL_RCC_PLL4_GetM+0x1c>)
341861de:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
341861e2:	0d1b      	lsrs	r3, r3, #20
341861e4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
341861e8:	4618      	mov	r0, r3
341861ea:	46bd      	mov	sp, r7
341861ec:	f85d 7b04 	ldr.w	r7, [sp], #4
341861f0:	4770      	bx	lr
341861f2:	bf00      	nop
341861f4:	56028000 	.word	0x56028000

341861f8 <LL_RCC_PLL4_GetP1>:
{
341861f8:	b480      	push	{r7}
341861fa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
341861fc:	4b05      	ldr	r3, [pc, #20]	@ (34186214 <LL_RCC_PLL4_GetP1+0x1c>)
341861fe:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34186202:	0edb      	lsrs	r3, r3, #27
34186204:	f003 0307 	and.w	r3, r3, #7
}
34186208:	4618      	mov	r0, r3
3418620a:	46bd      	mov	sp, r7
3418620c:	f85d 7b04 	ldr.w	r7, [sp], #4
34186210:	4770      	bx	lr
34186212:	bf00      	nop
34186214:	56028000 	.word	0x56028000

34186218 <LL_RCC_PLL4_GetP2>:
{
34186218:	b480      	push	{r7}
3418621a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
3418621c:	4b05      	ldr	r3, [pc, #20]	@ (34186234 <LL_RCC_PLL4_GetP2+0x1c>)
3418621e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34186222:	0e1b      	lsrs	r3, r3, #24
34186224:	f003 0307 	and.w	r3, r3, #7
}
34186228:	4618      	mov	r0, r3
3418622a:	46bd      	mov	sp, r7
3418622c:	f85d 7b04 	ldr.w	r7, [sp], #4
34186230:	4770      	bx	lr
34186232:	bf00      	nop
34186234:	56028000 	.word	0x56028000

34186238 <LL_RCC_PLL4P_IsEnabled>:
{
34186238:	b480      	push	{r7}
3418623a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
3418623c:	4b07      	ldr	r3, [pc, #28]	@ (3418625c <LL_RCC_PLL4P_IsEnabled+0x24>)
3418623e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34186242:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34186246:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3418624a:	d101      	bne.n	34186250 <LL_RCC_PLL4P_IsEnabled+0x18>
3418624c:	2301      	movs	r3, #1
3418624e:	e000      	b.n	34186252 <LL_RCC_PLL4P_IsEnabled+0x1a>
34186250:	2300      	movs	r3, #0
}
34186252:	4618      	mov	r0, r3
34186254:	46bd      	mov	sp, r7
34186256:	f85d 7b04 	ldr.w	r7, [sp], #4
3418625a:	4770      	bx	lr
3418625c:	56028000 	.word	0x56028000

34186260 <LL_RCC_PLL4_GetFRACN>:
{
34186260:	b480      	push	{r7}
34186262:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
34186264:	4b04      	ldr	r3, [pc, #16]	@ (34186278 <LL_RCC_PLL4_GetFRACN+0x18>)
34186266:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3418626a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3418626e:	4618      	mov	r0, r3
34186270:	46bd      	mov	sp, r7
34186272:	f85d 7b04 	ldr.w	r7, [sp], #4
34186276:	4770      	bx	lr
34186278:	56028000 	.word	0x56028000

3418627c <LL_RCC_IC3_Enable>:
{
3418627c:	b480      	push	{r7}
3418627e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
34186280:	4b04      	ldr	r3, [pc, #16]	@ (34186294 <LL_RCC_IC3_Enable+0x18>)
34186282:	2204      	movs	r2, #4
34186284:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34186288:	bf00      	nop
3418628a:	46bd      	mov	sp, r7
3418628c:	f85d 7b04 	ldr.w	r7, [sp], #4
34186290:	4770      	bx	lr
34186292:	bf00      	nop
34186294:	56028000 	.word	0x56028000

34186298 <LL_RCC_IC4_Enable>:
{
34186298:	b480      	push	{r7}
3418629a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418629c:	4b04      	ldr	r3, [pc, #16]	@ (341862b0 <LL_RCC_IC4_Enable+0x18>)
3418629e:	2208      	movs	r2, #8
341862a0:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
341862a4:	bf00      	nop
341862a6:	46bd      	mov	sp, r7
341862a8:	f85d 7b04 	ldr.w	r7, [sp], #4
341862ac:	4770      	bx	lr
341862ae:	bf00      	nop
341862b0:	56028000 	.word	0x56028000

341862b4 <LL_RCC_IC5_Enable>:
{
341862b4:	b480      	push	{r7}
341862b6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
341862b8:	4b04      	ldr	r3, [pc, #16]	@ (341862cc <LL_RCC_IC5_Enable+0x18>)
341862ba:	2210      	movs	r2, #16
341862bc:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
341862c0:	bf00      	nop
341862c2:	46bd      	mov	sp, r7
341862c4:	f85d 7b04 	ldr.w	r7, [sp], #4
341862c8:	4770      	bx	lr
341862ca:	bf00      	nop
341862cc:	56028000 	.word	0x56028000

341862d0 <LL_RCC_IC7_Enable>:
{
341862d0:	b480      	push	{r7}
341862d2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
341862d4:	4b04      	ldr	r3, [pc, #16]	@ (341862e8 <LL_RCC_IC7_Enable+0x18>)
341862d6:	2240      	movs	r2, #64	@ 0x40
341862d8:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
341862dc:	bf00      	nop
341862de:	46bd      	mov	sp, r7
341862e0:	f85d 7b04 	ldr.w	r7, [sp], #4
341862e4:	4770      	bx	lr
341862e6:	bf00      	nop
341862e8:	56028000 	.word	0x56028000

341862ec <LL_RCC_IC8_Enable>:
{
341862ec:	b480      	push	{r7}
341862ee:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
341862f0:	4b04      	ldr	r3, [pc, #16]	@ (34186304 <LL_RCC_IC8_Enable+0x18>)
341862f2:	2280      	movs	r2, #128	@ 0x80
341862f4:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
341862f8:	bf00      	nop
341862fa:	46bd      	mov	sp, r7
341862fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34186300:	4770      	bx	lr
34186302:	bf00      	nop
34186304:	56028000 	.word	0x56028000

34186308 <LL_RCC_IC9_Enable>:
{
34186308:	b480      	push	{r7}
3418630a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418630c:	4b04      	ldr	r3, [pc, #16]	@ (34186320 <LL_RCC_IC9_Enable+0x18>)
3418630e:	f44f 7280 	mov.w	r2, #256	@ 0x100
34186312:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34186316:	bf00      	nop
34186318:	46bd      	mov	sp, r7
3418631a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418631e:	4770      	bx	lr
34186320:	56028000 	.word	0x56028000

34186324 <LL_RCC_IC10_Enable>:
{
34186324:	b480      	push	{r7}
34186326:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
34186328:	4b04      	ldr	r3, [pc, #16]	@ (3418633c <LL_RCC_IC10_Enable+0x18>)
3418632a:	f44f 7200 	mov.w	r2, #512	@ 0x200
3418632e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34186332:	bf00      	nop
34186334:	46bd      	mov	sp, r7
34186336:	f85d 7b04 	ldr.w	r7, [sp], #4
3418633a:	4770      	bx	lr
3418633c:	56028000 	.word	0x56028000

34186340 <LL_RCC_IC12_Enable>:
  * @brief  Enable IC12
  * @rmtoll DIVENSR       IC12ENS        LL_RCC_IC12_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC12_Enable(void)
{
34186340:	b480      	push	{r7}
34186342:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
34186344:	4b04      	ldr	r3, [pc, #16]	@ (34186358 <LL_RCC_IC12_Enable+0x18>)
34186346:	f44f 6200 	mov.w	r2, #2048	@ 0x800
3418634a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418634e:	bf00      	nop
34186350:	46bd      	mov	sp, r7
34186352:	f85d 7b04 	ldr.w	r7, [sp], #4
34186356:	4770      	bx	lr
34186358:	56028000 	.word	0x56028000

3418635c <LL_RCC_IC13_Enable>:
  * @brief  Enable IC13
  * @rmtoll DIVENSR       IC13ENS        LL_RCC_IC13_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC13_Enable(void)
{
3418635c:	b480      	push	{r7}
3418635e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
34186360:	4b04      	ldr	r3, [pc, #16]	@ (34186374 <LL_RCC_IC13_Enable+0x18>)
34186362:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34186366:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418636a:	bf00      	nop
3418636c:	46bd      	mov	sp, r7
3418636e:	f85d 7b04 	ldr.w	r7, [sp], #4
34186372:	4770      	bx	lr
34186374:	56028000 	.word	0x56028000

34186378 <LL_RCC_IC14_Enable>:
  * @brief  Enable IC14
  * @rmtoll DIVENSR       IC14ENS        LL_RCC_IC14_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC14_Enable(void)
{
34186378:	b480      	push	{r7}
3418637a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418637c:	4b04      	ldr	r3, [pc, #16]	@ (34186390 <LL_RCC_IC14_Enable+0x18>)
3418637e:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34186382:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34186386:	bf00      	nop
34186388:	46bd      	mov	sp, r7
3418638a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418638e:	4770      	bx	lr
34186390:	56028000 	.word	0x56028000

34186394 <LL_RCC_IC15_Enable>:
  * @brief  Enable IC15
  * @rmtoll DIVENSR       IC15ENS        LL_RCC_IC15_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC15_Enable(void)
{
34186394:	b480      	push	{r7}
34186396:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34186398:	4b04      	ldr	r3, [pc, #16]	@ (341863ac <LL_RCC_IC15_Enable+0x18>)
3418639a:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
3418639e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
341863a2:	bf00      	nop
341863a4:	46bd      	mov	sp, r7
341863a6:	f85d 7b04 	ldr.w	r7, [sp], #4
341863aa:	4770      	bx	lr
341863ac:	56028000 	.word	0x56028000

341863b0 <LL_RCC_IC16_Enable>:
  * @brief  Enable IC16
  * @rmtoll DIVENSR       IC16ENS        LL_RCC_IC16_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC16_Enable(void)
{
341863b0:	b480      	push	{r7}
341863b2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
341863b4:	4b04      	ldr	r3, [pc, #16]	@ (341863c8 <LL_RCC_IC16_Enable+0x18>)
341863b6:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
341863ba:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
341863be:	bf00      	nop
341863c0:	46bd      	mov	sp, r7
341863c2:	f85d 7b04 	ldr.w	r7, [sp], #4
341863c6:	4770      	bx	lr
341863c8:	56028000 	.word	0x56028000

341863cc <LL_RCC_IC17_Enable>:
  * @brief  Enable IC17
  * @rmtoll DIVENSR       IC17ENS        LL_RCC_IC17_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC17_Enable(void)
{
341863cc:	b480      	push	{r7}
341863ce:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
341863d0:	4b04      	ldr	r3, [pc, #16]	@ (341863e4 <LL_RCC_IC17_Enable+0x18>)
341863d2:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
341863d6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
341863da:	bf00      	nop
341863dc:	46bd      	mov	sp, r7
341863de:	f85d 7b04 	ldr.w	r7, [sp], #4
341863e2:	4770      	bx	lr
341863e4:	56028000 	.word	0x56028000

341863e8 <LL_RCC_IC18_Enable>:
  * @brief  Enable IC18
  * @rmtoll DIVENSR       IC18ENS        LL_RCC_IC18_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC18_Enable(void)
{
341863e8:	b480      	push	{r7}
341863ea:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
341863ec:	4b04      	ldr	r3, [pc, #16]	@ (34186400 <LL_RCC_IC18_Enable+0x18>)
341863ee:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
341863f2:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
341863f6:	bf00      	nop
341863f8:	46bd      	mov	sp, r7
341863fa:	f85d 7b04 	ldr.w	r7, [sp], #4
341863fe:	4770      	bx	lr
34186400:	56028000 	.word	0x56028000

34186404 <LL_RCC_IC19_Enable>:
  * @brief  Enable IC19
  * @rmtoll DIVENSR       IC19ENS        LL_RCC_IC19_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC19_Enable(void)
{
34186404:	b480      	push	{r7}
34186406:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
34186408:	4b04      	ldr	r3, [pc, #16]	@ (3418641c <LL_RCC_IC19_Enable+0x18>)
3418640a:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
3418640e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34186412:	bf00      	nop
34186414:	46bd      	mov	sp, r7
34186416:	f85d 7b04 	ldr.w	r7, [sp], #4
3418641a:	4770      	bx	lr
3418641c:	56028000 	.word	0x56028000

34186420 <LL_RCC_IC20_Enable>:
  * @brief  Enable IC20
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
34186420:	b480      	push	{r7}
34186422:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
34186424:	4b04      	ldr	r3, [pc, #16]	@ (34186438 <LL_RCC_IC20_Enable+0x18>)
34186426:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
3418642a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418642e:	bf00      	nop
34186430:	46bd      	mov	sp, r7
34186432:	f85d 7b04 	ldr.w	r7, [sp], #4
34186436:	4770      	bx	lr
34186438:	56028000 	.word	0x56028000

3418643c <LL_RCC_CLKP_Enable>:
  * @brief  Enable CLKP
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
3418643c:	b480      	push	{r7}
3418643e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34186440:	4b04      	ldr	r3, [pc, #16]	@ (34186454 <LL_RCC_CLKP_Enable+0x18>)
34186442:	2240      	movs	r2, #64	@ 0x40
34186444:	f8c3 2a48 	str.w	r2, [r3, #2632]	@ 0xa48
}
34186448:	bf00      	nop
3418644a:	46bd      	mov	sp, r7
3418644c:	f85d 7b04 	ldr.w	r7, [sp], #4
34186450:	4770      	bx	lr
34186452:	bf00      	nop
34186454:	56028000 	.word	0x56028000

34186458 <HAL_RCCEx_PeriphCLKConfig>:
  *         modification indeed impacts all peripherals using this ICx as clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
34186458:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3418645c:	b0f2      	sub	sp, #456	@ 0x1c8
3418645e:	af00      	add	r7, sp, #0
34186460:	f8c7 01b4 	str.w	r0, [r7, #436]	@ 0x1b4
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
34186464:	2300      	movs	r3, #0
34186466:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
3418646a:	2300      	movs	r3, #0
3418646c:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- RTC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
34186470:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186474:	e9d3 2300 	ldrd	r2, r3, [r3]
34186478:	f002 6400 	and.w	r4, r2, #134217728	@ 0x8000000
3418647c:	2500      	movs	r5, #0
3418647e:	ea54 0305 	orrs.w	r3, r4, r5
34186482:	d06c      	beq.n	3418655e <HAL_RCCEx_PeriphCLKConfig+0x106>
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* As the RTC clock source selection can be changed only if the Backup Domain is reset */
    /* reset the Backup domain only if the RTC Clock source selection is modified from default reset value */
    tmpreg = LL_RCC_GetRTCClockSource();
34186484:	f7ff fc60 	bl	34185d48 <LL_RCC_GetRTCClockSource>
34186488:	f8c7 01c0 	str.w	r0, [r7, #448]	@ 0x1c0

    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3418648c:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
34186490:	2b00      	cmp	r3, #0
34186492:	d018      	beq.n	341864c6 <HAL_RCCEx_PeriphCLKConfig+0x6e>
34186494:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186498:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418649c:	f403 7240 	and.w	r2, r3, #768	@ 0x300
341864a0:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
341864a4:	4293      	cmp	r3, r2
341864a6:	d00e      	beq.n	341864c6 <HAL_RCCEx_PeriphCLKConfig+0x6e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
341864a8:	4bc3      	ldr	r3, [pc, #780]	@ (341867b8 <HAL_RCCEx_PeriphCLKConfig+0x360>)
341864aa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
341864ac:	4ac2      	ldr	r2, [pc, #776]	@ (341867b8 <HAL_RCCEx_PeriphCLKConfig+0x360>)
341864ae:	f043 0301 	orr.w	r3, r3, #1
341864b2:	62d3      	str	r3, [r2, #44]	@ 0x2c

      /* Read back to check Backup domain enabled */
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
341864b4:	4bc0      	ldr	r3, [pc, #768]	@ (341867b8 <HAL_RCCEx_PeriphCLKConfig+0x360>)
341864b6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
341864b8:	f003 0301 	and.w	r3, r3, #1
341864bc:	2b00      	cmp	r3, #0
341864be:	d102      	bne.n	341864c6 <HAL_RCCEx_PeriphCLKConfig+0x6e>
      {
        ret = HAL_ERROR;
341864c0:	2301      	movs	r3, #1
341864c2:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
        WRITE_REG(RCC->BDCR, tmpreg);
#endif /* #if 0  TO DO */
      }
    }

    if (ret == HAL_OK)
341864c6:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
341864ca:	2b00      	cmp	r3, #0
341864cc:	d143      	bne.n	34186556 <HAL_RCCEx_PeriphCLKConfig+0xfe>
    {
      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
341864ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341864d2:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
341864d6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
341864da:	d117      	bne.n	3418650c <HAL_RCCEx_PeriphCLKConfig+0xb4>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
341864dc:	f7fb fea6 	bl	3418222c <HAL_GetTick>
341864e0:	f8c7 01bc 	str.w	r0, [r7, #444]	@ 0x1bc

        /* Wait till LSE is ready */
        while (LL_RCC_LSE_IsReady() == 0U)
341864e4:	e00d      	b.n	34186502 <HAL_RCCEx_PeriphCLKConfig+0xaa>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
341864e6:	f7fb fea1 	bl	3418222c <HAL_GetTick>
341864ea:	4602      	mov	r2, r0
341864ec:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
341864f0:	1ad2      	subs	r2, r2, r3
341864f2:	f241 3388 	movw	r3, #5000	@ 0x1388
341864f6:	429a      	cmp	r2, r3
341864f8:	d903      	bls.n	34186502 <HAL_RCCEx_PeriphCLKConfig+0xaa>
          {
            ret = HAL_TIMEOUT;
341864fa:	2303      	movs	r3, #3
341864fc:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
            break;
34186500:	e004      	b.n	3418650c <HAL_RCCEx_PeriphCLKConfig+0xb4>
        while (LL_RCC_LSE_IsReady() == 0U)
34186502:	f7ff fa2b 	bl	3418595c <LL_RCC_LSE_IsReady>
34186506:	4603      	mov	r3, r0
34186508:	2b00      	cmp	r3, #0
3418650a:	d0ec      	beq.n	341864e6 <HAL_RCCEx_PeriphCLKConfig+0x8e>
          }
        }
      }

      if (ret == HAL_OK)
3418650c:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34186510:	2b00      	cmp	r3, #0
34186512:	d11b      	bne.n	3418654c <HAL_RCCEx_PeriphCLKConfig+0xf4>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
34186514:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186518:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418651c:	f403 7340 	and.w	r3, r3, #768	@ 0x300
34186520:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34186524:	d108      	bne.n	34186538 <HAL_RCCEx_PeriphCLKConfig+0xe0>
34186526:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418652a:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418652e:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
34186532:	4618      	mov	r0, r3
34186534:	f7ff fc16 	bl	34185d64 <LL_RCC_SetRTC_HSEPrescaler>
34186538:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418653c:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34186540:	f403 7340 	and.w	r3, r3, #768	@ 0x300
34186544:	4618      	mov	r0, r3
34186546:	f7ff fbe9 	bl	34185d1c <LL_RCC_SetRTCClockSource>
3418654a:	e008      	b.n	3418655e <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
      else
      {
        /* set overall return value */
        status = ret;
3418654c:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34186550:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
34186554:	e003      	b.n	3418655e <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
34186556:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
3418655a:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
    }
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
3418655e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186562:	e9d3 2300 	ldrd	r2, r3, [r3]
34186566:	f002 0804 	and.w	r8, r2, #4
3418656a:	f04f 0900 	mov.w	r9, #0
3418656e:	ea58 0309 	orrs.w	r3, r8, r9
34186572:	f000 809b 	beq.w	341866ac <HAL_RCCEx_PeriphCLKConfig+0x254>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));

    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
34186576:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418657a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418657e:	2b04      	cmp	r3, #4
34186580:	d116      	bne.n	341865b0 <HAL_RCCEx_PeriphCLKConfig+0x158>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34186582:	4b8e      	ldr	r3, [pc, #568]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
34186584:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34186588:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418658c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186590:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186594:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34186596:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418659a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418659c:	3b01      	subs	r3, #1
3418659e:	041b      	lsls	r3, r3, #16
341865a0:	4313      	orrs	r3, r2
341865a2:	4a86      	ldr	r2, [pc, #536]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
341865a4:	430b      	orrs	r3, r1
341865a6:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
341865aa:	f7ff fe83 	bl	341862b4 <LL_RCC_IC5_Enable>
341865ae:	e076      	b.n	3418669e <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC10)
341865b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341865b4:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
341865b8:	2b05      	cmp	r3, #5
341865ba:	d116      	bne.n	341865ea <HAL_RCCEx_PeriphCLKConfig+0x192>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
341865bc:	4b7f      	ldr	r3, [pc, #508]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
341865be:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
341865c2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341865c6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341865ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341865ce:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
341865d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341865d4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341865d6:	3b01      	subs	r3, #1
341865d8:	041b      	lsls	r3, r3, #16
341865da:	4313      	orrs	r3, r2
341865dc:	4a77      	ldr	r2, [pc, #476]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
341865de:	430b      	orrs	r3, r1
341865e0:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
341865e4:	f7ff fe9e 	bl	34186324 <LL_RCC_IC10_Enable>
341865e8:	e059      	b.n	3418669e <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC15)
341865ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341865ee:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
341865f2:	2b06      	cmp	r3, #6
341865f4:	d116      	bne.n	34186624 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
341865f6:	4b71      	ldr	r3, [pc, #452]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
341865f8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341865fc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186600:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186604:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186608:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418660a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418660e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34186610:	3b01      	subs	r3, #1
34186612:	041b      	lsls	r3, r3, #16
34186614:	4313      	orrs	r3, r2
34186616:	4a69      	ldr	r2, [pc, #420]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
34186618:	430b      	orrs	r3, r1
3418661a:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418661e:	f7ff feb9 	bl	34186394 <LL_RCC_IC15_Enable>
34186622:	e03c      	b.n	3418669e <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC19)
34186624:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186628:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418662c:	2b03      	cmp	r3, #3
3418662e:	d118      	bne.n	34186662 <HAL_RCCEx_PeriphCLKConfig+0x20a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
34186630:	4b62      	ldr	r3, [pc, #392]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
34186632:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34186636:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418663a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418663e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186642:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34186646:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418664a:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3418664e:	3b01      	subs	r3, #1
34186650:	041b      	lsls	r3, r3, #16
34186652:	4313      	orrs	r3, r2
34186654:	4a59      	ldr	r2, [pc, #356]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
34186656:	430b      	orrs	r3, r1
34186658:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
3418665c:	f7ff fed2 	bl	34186404 <LL_RCC_IC19_Enable>
34186660:	e01d      	b.n	3418669e <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC20)
34186662:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186666:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418666a:	2b07      	cmp	r3, #7
3418666c:	d117      	bne.n	3418669e <HAL_RCCEx_PeriphCLKConfig+0x246>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3418666e:	4b53      	ldr	r3, [pc, #332]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
34186670:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34186674:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186678:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418667c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186680:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34186684:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186688:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3418668c:	3b01      	subs	r3, #1
3418668e:	041b      	lsls	r3, r3, #16
34186690:	4313      	orrs	r3, r2
34186692:	4a4a      	ldr	r2, [pc, #296]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
34186694:	430b      	orrs	r3, r1
34186696:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
3418669a:	f7ff fec1 	bl	34186420 <LL_RCC_IC20_Enable>
    {
      /* No ICx selected as source */
    }

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
3418669e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341866a2:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
341866a6:	4618      	mov	r0, r3
341866a8:	f7ff f9aa 	bl	34185a00 <LL_RCC_SetCLKPClockSource>
  }

  /*-------------------------- XSPI1 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
341866ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341866b0:	e9d3 2300 	ldrd	r2, r3, [r3]
341866b4:	f04f 0a00 	mov.w	sl, #0
341866b8:	f403 0b80 	and.w	fp, r3, #4194304	@ 0x400000
341866bc:	ea5a 030b 	orrs.w	r3, sl, fp
341866c0:	d04b      	beq.n	3418675a <HAL_RCCEx_PeriphCLKConfig+0x302>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));

    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
341866c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341866c6:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
341866ca:	4b3d      	ldr	r3, [pc, #244]	@ (341867c0 <HAL_RCCEx_PeriphCLKConfig+0x368>)
341866cc:	429a      	cmp	r2, r3
341866ce:	d116      	bne.n	341866fe <HAL_RCCEx_PeriphCLKConfig+0x2a6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
341866d0:	4b3a      	ldr	r3, [pc, #232]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
341866d2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
341866d6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341866da:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341866de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341866e2:	699a      	ldr	r2, [r3, #24]
341866e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341866e8:	69db      	ldr	r3, [r3, #28]
341866ea:	3b01      	subs	r3, #1
341866ec:	041b      	lsls	r3, r3, #16
341866ee:	4313      	orrs	r3, r2
341866f0:	4a32      	ldr	r2, [pc, #200]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
341866f2:	430b      	orrs	r3, r1
341866f4:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
341866f8:	f7ff fdc0 	bl	3418627c <LL_RCC_IC3_Enable>
341866fc:	e026      	b.n	3418674c <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
341866fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186702:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
34186706:	4b2f      	ldr	r3, [pc, #188]	@ (341867c4 <HAL_RCCEx_PeriphCLKConfig+0x36c>)
34186708:	429a      	cmp	r2, r3
3418670a:	d116      	bne.n	3418673a <HAL_RCCEx_PeriphCLKConfig+0x2e2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418670c:	4b2b      	ldr	r3, [pc, #172]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418670e:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34186712:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186716:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418671a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418671e:	6a1a      	ldr	r2, [r3, #32]
34186720:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186724:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34186726:	3b01      	subs	r3, #1
34186728:	041b      	lsls	r3, r3, #16
3418672a:	4313      	orrs	r3, r2
3418672c:	4a23      	ldr	r2, [pc, #140]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418672e:	430b      	orrs	r3, r1
34186730:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34186734:	f7ff fdb0 	bl	34186298 <LL_RCC_IC4_Enable>
34186738:	e008      	b.n	3418674c <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
3418673a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418673e:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
34186742:	4b21      	ldr	r3, [pc, #132]	@ (341867c8 <HAL_RCCEx_PeriphCLKConfig+0x370>)
34186744:	429a      	cmp	r2, r3
34186746:	d101      	bne.n	3418674c <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    {
      LL_RCC_CLKP_Enable();
34186748:	f7ff fe78 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI1 clock source */
    __HAL_RCC_XSPI1_CONFIG(PeriphClkInit->Xspi1ClockSelection);
3418674c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186750:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34186754:	4618      	mov	r0, r3
34186756:	f7ff fad5 	bl	34185d04 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI2 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
3418675a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418675e:	e9d3 2300 	ldrd	r2, r3, [r3]
34186762:	2100      	movs	r1, #0
34186764:	f8c7 11a8 	str.w	r1, [r7, #424]	@ 0x1a8
34186768:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
3418676c:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
34186770:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
34186774:	4603      	mov	r3, r0
34186776:	460a      	mov	r2, r1
34186778:	4313      	orrs	r3, r2
3418677a:	d057      	beq.n	3418682c <HAL_RCCEx_PeriphCLKConfig+0x3d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));

    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
3418677c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186780:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34186784:	4b11      	ldr	r3, [pc, #68]	@ (341867cc <HAL_RCCEx_PeriphCLKConfig+0x374>)
34186786:	429a      	cmp	r2, r3
34186788:	d122      	bne.n	341867d0 <HAL_RCCEx_PeriphCLKConfig+0x378>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418678a:	4b0c      	ldr	r3, [pc, #48]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418678c:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34186790:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186794:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186798:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418679c:	699a      	ldr	r2, [r3, #24]
3418679e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341867a2:	69db      	ldr	r3, [r3, #28]
341867a4:	3b01      	subs	r3, #1
341867a6:	041b      	lsls	r3, r3, #16
341867a8:	4313      	orrs	r3, r2
341867aa:	4a04      	ldr	r2, [pc, #16]	@ (341867bc <HAL_RCCEx_PeriphCLKConfig+0x364>)
341867ac:	430b      	orrs	r3, r1
341867ae:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
341867b2:	f7ff fd63 	bl	3418627c <LL_RCC_IC3_Enable>
341867b6:	e032      	b.n	3418681e <HAL_RCCEx_PeriphCLKConfig+0x3c6>
341867b8:	56024800 	.word	0x56024800
341867bc:	56028000 	.word	0x56028000
341867c0:	03020014 	.word	0x03020014
341867c4:	03030014 	.word	0x03030014
341867c8:	03010014 	.word	0x03010014
341867cc:	03020414 	.word	0x03020414
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
341867d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341867d4:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
341867d8:	4bc5      	ldr	r3, [pc, #788]	@ (34186af0 <HAL_RCCEx_PeriphCLKConfig+0x698>)
341867da:	429a      	cmp	r2, r3
341867dc:	d116      	bne.n	3418680c <HAL_RCCEx_PeriphCLKConfig+0x3b4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
341867de:	4bc5      	ldr	r3, [pc, #788]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
341867e0:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
341867e4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341867e8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341867ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341867f0:	6a1a      	ldr	r2, [r3, #32]
341867f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341867f6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341867f8:	3b01      	subs	r3, #1
341867fa:	041b      	lsls	r3, r3, #16
341867fc:	4313      	orrs	r3, r2
341867fe:	4abd      	ldr	r2, [pc, #756]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34186800:	430b      	orrs	r3, r1
34186802:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34186806:	f7ff fd47 	bl	34186298 <LL_RCC_IC4_Enable>
3418680a:	e008      	b.n	3418681e <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
3418680c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186810:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34186814:	4bb8      	ldr	r3, [pc, #736]	@ (34186af8 <HAL_RCCEx_PeriphCLKConfig+0x6a0>)
34186816:	429a      	cmp	r2, r3
34186818:	d101      	bne.n	3418681e <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    {
      LL_RCC_CLKP_Enable();
3418681a:	f7ff fe0f 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI2 clock source */
    __HAL_RCC_XSPI2_CONFIG(PeriphClkInit->Xspi2ClockSelection);
3418681e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186822:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34186826:	4618      	mov	r0, r3
34186828:	f7ff fa6c 	bl	34185d04 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI3 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
3418682c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186830:	e9d3 2300 	ldrd	r2, r3, [r3]
34186834:	2100      	movs	r1, #0
34186836:	f8c7 11a0 	str.w	r1, [r7, #416]	@ 0x1a0
3418683a:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3418683e:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
34186842:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	@ 0x1a0
34186846:	4603      	mov	r3, r0
34186848:	460a      	mov	r2, r1
3418684a:	4313      	orrs	r3, r2
3418684c:	d04b      	beq.n	341868e6 <HAL_RCCEx_PeriphCLKConfig+0x48e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));

    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
3418684e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186852:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
34186856:	4ba9      	ldr	r3, [pc, #676]	@ (34186afc <HAL_RCCEx_PeriphCLKConfig+0x6a4>)
34186858:	429a      	cmp	r2, r3
3418685a:	d116      	bne.n	3418688a <HAL_RCCEx_PeriphCLKConfig+0x432>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418685c:	4ba5      	ldr	r3, [pc, #660]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418685e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34186862:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186866:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418686a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418686e:	699a      	ldr	r2, [r3, #24]
34186870:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186874:	69db      	ldr	r3, [r3, #28]
34186876:	3b01      	subs	r3, #1
34186878:	041b      	lsls	r3, r3, #16
3418687a:	4313      	orrs	r3, r2
3418687c:	4a9d      	ldr	r2, [pc, #628]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418687e:	430b      	orrs	r3, r1
34186880:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
34186884:	f7ff fcfa 	bl	3418627c <LL_RCC_IC3_Enable>
34186888:	e026      	b.n	341868d8 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
3418688a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418688e:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
34186892:	4b9b      	ldr	r3, [pc, #620]	@ (34186b00 <HAL_RCCEx_PeriphCLKConfig+0x6a8>)
34186894:	429a      	cmp	r2, r3
34186896:	d116      	bne.n	341868c6 <HAL_RCCEx_PeriphCLKConfig+0x46e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34186898:	4b96      	ldr	r3, [pc, #600]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418689a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418689e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341868a2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341868a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341868aa:	6a1a      	ldr	r2, [r3, #32]
341868ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341868b0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341868b2:	3b01      	subs	r3, #1
341868b4:	041b      	lsls	r3, r3, #16
341868b6:	4313      	orrs	r3, r2
341868b8:	4a8e      	ldr	r2, [pc, #568]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
341868ba:	430b      	orrs	r3, r1
341868bc:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
341868c0:	f7ff fcea 	bl	34186298 <LL_RCC_IC4_Enable>
341868c4:	e008      	b.n	341868d8 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
341868c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341868ca:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
341868ce:	4b8d      	ldr	r3, [pc, #564]	@ (34186b04 <HAL_RCCEx_PeriphCLKConfig+0x6ac>)
341868d0:	429a      	cmp	r2, r3
341868d2:	d101      	bne.n	341868d8 <HAL_RCCEx_PeriphCLKConfig+0x480>
    {
      LL_RCC_CLKP_Enable();
341868d4:	f7ff fdb2 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI3 clock source */
    __HAL_RCC_XSPI3_CONFIG(PeriphClkInit->Xspi3ClockSelection);
341868d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341868dc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
341868e0:	4618      	mov	r0, r3
341868e2:	f7ff fa0f 	bl	34185d04 <LL_RCC_SetXSPIClockSource>
  }

  /*---------------------------- FMC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
341868e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341868ea:	e9d3 2300 	ldrd	r2, r3, [r3]
341868ee:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
341868f2:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
341868f6:	2300      	movs	r3, #0
341868f8:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
341868fc:	e9d7 0166 	ldrd	r0, r1, [r7, #408]	@ 0x198
34186900:	4603      	mov	r3, r0
34186902:	460a      	mov	r2, r1
34186904:	4313      	orrs	r3, r2
34186906:	d048      	beq.n	3418699a <HAL_RCCEx_PeriphCLKConfig+0x542>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));

    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
34186908:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418690c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34186910:	2b20      	cmp	r3, #32
34186912:	d116      	bne.n	34186942 <HAL_RCCEx_PeriphCLKConfig+0x4ea>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34186914:	4b77      	ldr	r3, [pc, #476]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34186916:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418691a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418691e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186922:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186926:	699a      	ldr	r2, [r3, #24]
34186928:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418692c:	69db      	ldr	r3, [r3, #28]
3418692e:	3b01      	subs	r3, #1
34186930:	041b      	lsls	r3, r3, #16
34186932:	4313      	orrs	r3, r2
34186934:	4a6f      	ldr	r2, [pc, #444]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34186936:	430b      	orrs	r3, r1
34186938:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3418693c:	f7ff fc9e 	bl	3418627c <LL_RCC_IC3_Enable>
34186940:	e024      	b.n	3418698c <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
34186942:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186946:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418694a:	2b30      	cmp	r3, #48	@ 0x30
3418694c:	d116      	bne.n	3418697c <HAL_RCCEx_PeriphCLKConfig+0x524>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418694e:	4b69      	ldr	r3, [pc, #420]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34186950:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34186954:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186958:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418695c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186960:	6a1a      	ldr	r2, [r3, #32]
34186962:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186966:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34186968:	3b01      	subs	r3, #1
3418696a:	041b      	lsls	r3, r3, #16
3418696c:	4313      	orrs	r3, r2
3418696e:	4a61      	ldr	r2, [pc, #388]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34186970:	430b      	orrs	r3, r1
34186972:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34186976:	f7ff fc8f 	bl	34186298 <LL_RCC_IC4_Enable>
3418697a:	e007      	b.n	3418698c <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
3418697c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186980:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34186984:	2b10      	cmp	r3, #16
34186986:	d101      	bne.n	3418698c <HAL_RCCEx_PeriphCLKConfig+0x534>
    {
      LL_RCC_CLKP_Enable();
34186988:	f7ff fd58 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FMC kernel clock*/
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
3418698c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186990:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34186994:	4618      	mov	r0, r3
34186996:	f7ff f8cd 	bl	34185b34 <LL_RCC_SetFMCClockSource>
  }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
3418699a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418699e:	e9d3 2300 	ldrd	r2, r3, [r3]
341869a2:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
341869a6:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
341869aa:	2300      	movs	r3, #0
341869ac:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
341869b0:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	@ 0x190
341869b4:	4603      	mov	r3, r0
341869b6:	460a      	mov	r2, r1
341869b8:	4313      	orrs	r3, r2
341869ba:	d04b      	beq.n	34186a54 <HAL_RCCEx_PeriphCLKConfig+0x5fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
341869bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341869c0:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
341869c4:	4b50      	ldr	r3, [pc, #320]	@ (34186b08 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
341869c6:	429a      	cmp	r2, r3
341869c8:	d116      	bne.n	341869f8 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
341869ca:	4b4a      	ldr	r3, [pc, #296]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
341869cc:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
341869d0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341869d4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341869d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341869dc:	6a1a      	ldr	r2, [r3, #32]
341869de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341869e2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341869e4:	3b01      	subs	r3, #1
341869e6:	041b      	lsls	r3, r3, #16
341869e8:	4313      	orrs	r3, r2
341869ea:	4a42      	ldr	r2, [pc, #264]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
341869ec:	430b      	orrs	r3, r1
341869ee:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
341869f2:	f7ff fc51 	bl	34186298 <LL_RCC_IC4_Enable>
341869f6:	e026      	b.n	34186a46 <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
341869f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341869fc:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34186a00:	4b42      	ldr	r3, [pc, #264]	@ (34186b0c <HAL_RCCEx_PeriphCLKConfig+0x6b4>)
34186a02:	429a      	cmp	r2, r3
34186a04:	d116      	bne.n	34186a34 <HAL_RCCEx_PeriphCLKConfig+0x5dc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34186a06:	4b3b      	ldr	r3, [pc, #236]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34186a08:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34186a0c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186a10:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186a14:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186a18:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34186a1a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186a1e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34186a20:	3b01      	subs	r3, #1
34186a22:	041b      	lsls	r3, r3, #16
34186a24:	4313      	orrs	r3, r2
34186a26:	4a33      	ldr	r2, [pc, #204]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34186a28:	430b      	orrs	r3, r1
34186a2a:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34186a2e:	f7ff fc41 	bl	341862b4 <LL_RCC_IC5_Enable>
34186a32:	e008      	b.n	34186a46 <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
34186a34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186a38:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34186a3c:	4b34      	ldr	r3, [pc, #208]	@ (34186b10 <HAL_RCCEx_PeriphCLKConfig+0x6b8>)
34186a3e:	429a      	cmp	r2, r3
34186a40:	d101      	bne.n	34186a46 <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    {
      LL_RCC_CLKP_Enable();
34186a42:	f7ff fcfb 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC1 clock*/
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
34186a46:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186a4a:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
34186a4e:	4618      	mov	r0, r3
34186a50:	f7ff f921 	bl	34185c96 <LL_RCC_SetSDMMCClockSource>
  }

  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
34186a54:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186a58:	e9d3 2300 	ldrd	r2, r3, [r3]
34186a5c:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
34186a60:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
34186a64:	2300      	movs	r3, #0
34186a66:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
34186a6a:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	@ 0x188
34186a6e:	4603      	mov	r3, r0
34186a70:	460a      	mov	r2, r1
34186a72:	4313      	orrs	r3, r2
34186a74:	d062      	beq.n	34186b3c <HAL_RCCEx_PeriphCLKConfig+0x6e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
34186a76:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186a7a:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34186a7e:	4b25      	ldr	r3, [pc, #148]	@ (34186b14 <HAL_RCCEx_PeriphCLKConfig+0x6bc>)
34186a80:	429a      	cmp	r2, r3
34186a82:	d116      	bne.n	34186ab2 <HAL_RCCEx_PeriphCLKConfig+0x65a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34186a84:	4b1b      	ldr	r3, [pc, #108]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34186a86:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34186a8a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186a8e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186a92:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186a96:	6a1a      	ldr	r2, [r3, #32]
34186a98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186a9c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34186a9e:	3b01      	subs	r3, #1
34186aa0:	041b      	lsls	r3, r3, #16
34186aa2:	4313      	orrs	r3, r2
34186aa4:	4a13      	ldr	r2, [pc, #76]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34186aa6:	430b      	orrs	r3, r1
34186aa8:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34186aac:	f7ff fbf4 	bl	34186298 <LL_RCC_IC4_Enable>
34186ab0:	e03d      	b.n	34186b2e <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
34186ab2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186ab6:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34186aba:	4b17      	ldr	r3, [pc, #92]	@ (34186b18 <HAL_RCCEx_PeriphCLKConfig+0x6c0>)
34186abc:	429a      	cmp	r2, r3
34186abe:	d12d      	bne.n	34186b1c <HAL_RCCEx_PeriphCLKConfig+0x6c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34186ac0:	4b0c      	ldr	r3, [pc, #48]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34186ac2:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34186ac6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186aca:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186ace:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186ad2:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34186ad4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186ad8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34186ada:	3b01      	subs	r3, #1
34186adc:	041b      	lsls	r3, r3, #16
34186ade:	4313      	orrs	r3, r2
34186ae0:	4a04      	ldr	r2, [pc, #16]	@ (34186af4 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34186ae2:	430b      	orrs	r3, r1
34186ae4:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34186ae8:	f7ff fbe4 	bl	341862b4 <LL_RCC_IC5_Enable>
34186aec:	e01f      	b.n	34186b2e <HAL_RCCEx_PeriphCLKConfig+0x6d6>
34186aee:	bf00      	nop
34186af0:	03030414 	.word	0x03030414
34186af4:	56028000 	.word	0x56028000
34186af8:	03010414 	.word	0x03010414
34186afc:	03020814 	.word	0x03020814
34186b00:	03030814 	.word	0x03030814
34186b04:	03010814 	.word	0x03010814
34186b08:	0302001c 	.word	0x0302001c
34186b0c:	0303001c 	.word	0x0303001c
34186b10:	0301001c 	.word	0x0301001c
34186b14:	0302041c 	.word	0x0302041c
34186b18:	0303041c 	.word	0x0303041c
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
34186b1c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186b20:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34186b24:	4bb3      	ldr	r3, [pc, #716]	@ (34186df4 <HAL_RCCEx_PeriphCLKConfig+0x99c>)
34186b26:	429a      	cmp	r2, r3
34186b28:	d101      	bne.n	34186b2e <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    {
      LL_RCC_CLKP_Enable();
34186b2a:	f7ff fc87 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC2 clock*/
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
34186b2e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186b32:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
34186b36:	4618      	mov	r0, r3
34186b38:	f7ff f8ad 	bl	34185c96 <LL_RCC_SetSDMMCClockSource>
  }

  /*---------------------------- ADC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
34186b3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186b40:	e9d3 2300 	ldrd	r2, r3, [r3]
34186b44:	f002 0301 	and.w	r3, r2, #1
34186b48:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
34186b4c:	2300      	movs	r3, #0
34186b4e:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
34186b52:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
34186b56:	4603      	mov	r3, r0
34186b58:	460a      	mov	r2, r1
34186b5a:	4313      	orrs	r3, r2
34186b5c:	d057      	beq.n	34186c0e <HAL_RCCEx_PeriphCLKConfig+0x7b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
34186b5e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186b62:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34186b66:	2b20      	cmp	r3, #32
34186b68:	d116      	bne.n	34186b98 <HAL_RCCEx_PeriphCLKConfig+0x740>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34186b6a:	4ba3      	ldr	r3, [pc, #652]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186b6c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34186b70:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186b74:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186b78:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186b7c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34186b7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186b82:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34186b84:	3b01      	subs	r3, #1
34186b86:	041b      	lsls	r3, r3, #16
34186b88:	4313      	orrs	r3, r2
34186b8a:	4a9b      	ldr	r2, [pc, #620]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186b8c:	430b      	orrs	r3, r1
34186b8e:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34186b92:	f7ff fb9d 	bl	341862d0 <LL_RCC_IC7_Enable>
34186b96:	e024      	b.n	34186be2 <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
34186b98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186b9c:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34186ba0:	2b30      	cmp	r3, #48	@ 0x30
34186ba2:	d116      	bne.n	34186bd2 <HAL_RCCEx_PeriphCLKConfig+0x77a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34186ba4:	4b94      	ldr	r3, [pc, #592]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186ba6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34186baa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186bae:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186bb2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186bb6:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34186bb8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186bbc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34186bbe:	3b01      	subs	r3, #1
34186bc0:	041b      	lsls	r3, r3, #16
34186bc2:	4313      	orrs	r3, r2
34186bc4:	4a8c      	ldr	r2, [pc, #560]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186bc6:	430b      	orrs	r3, r1
34186bc8:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34186bcc:	f7ff fb8e 	bl	341862ec <LL_RCC_IC8_Enable>
34186bd0:	e007      	b.n	34186be2 <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
34186bd2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186bd6:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34186bda:	2b10      	cmp	r3, #16
34186bdc:	d101      	bne.n	34186be2 <HAL_RCCEx_PeriphCLKConfig+0x78a>
    {
      LL_RCC_CLKP_Enable();
34186bde:	f7ff fc2d 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ADC clock source and divider */
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
34186be2:	4b85      	ldr	r3, [pc, #532]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186be4:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34186be8:	f423 417f 	bic.w	r1, r3, #65280	@ 0xff00
34186bec:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
34186bf0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186bf4:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
34186bf8:	3b01      	subs	r3, #1
34186bfa:	021a      	lsls	r2, r3, #8
34186bfc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186c00:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34186c04:	4313      	orrs	r3, r2
34186c06:	4a7c      	ldr	r2, [pc, #496]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186c08:	430b      	orrs	r3, r1
34186c0a:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
               (((PeriphClkInit->AdcDivider - 1U) << RCC_CCIPR1_ADCPRE_Pos) | (PeriphClkInit->AdcClockSelection)));
  }

  /*---------------------------- ADF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
34186c0e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186c12:	e9d3 2300 	ldrd	r2, r3, [r3]
34186c16:	f002 0302 	and.w	r3, r2, #2
34186c1a:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
34186c1e:	2300      	movs	r3, #0
34186c20:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
34186c24:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
34186c28:	4603      	mov	r3, r0
34186c2a:	460a      	mov	r2, r1
34186c2c:	4313      	orrs	r3, r2
34186c2e:	d048      	beq.n	34186cc2 <HAL_RCCEx_PeriphCLKConfig+0x86a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));

    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
34186c30:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186c34:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34186c38:	2b02      	cmp	r3, #2
34186c3a:	d116      	bne.n	34186c6a <HAL_RCCEx_PeriphCLKConfig+0x812>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34186c3c:	4b6e      	ldr	r3, [pc, #440]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186c3e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34186c42:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186c46:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186c4a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186c4e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34186c50:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186c54:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34186c56:	3b01      	subs	r3, #1
34186c58:	041b      	lsls	r3, r3, #16
34186c5a:	4313      	orrs	r3, r2
34186c5c:	4a66      	ldr	r2, [pc, #408]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186c5e:	430b      	orrs	r3, r1
34186c60:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34186c64:	f7ff fb34 	bl	341862d0 <LL_RCC_IC7_Enable>
34186c68:	e024      	b.n	34186cb4 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
34186c6a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186c6e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34186c72:	2b03      	cmp	r3, #3
34186c74:	d116      	bne.n	34186ca4 <HAL_RCCEx_PeriphCLKConfig+0x84c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34186c76:	4b60      	ldr	r3, [pc, #384]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186c78:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34186c7c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186c80:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186c84:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186c88:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34186c8a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186c8e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34186c90:	3b01      	subs	r3, #1
34186c92:	041b      	lsls	r3, r3, #16
34186c94:	4313      	orrs	r3, r2
34186c96:	4a58      	ldr	r2, [pc, #352]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186c98:	430b      	orrs	r3, r1
34186c9a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34186c9e:	f7ff fb25 	bl	341862ec <LL_RCC_IC8_Enable>
34186ca2:	e007      	b.n	34186cb4 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
34186ca4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186ca8:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34186cac:	2b01      	cmp	r3, #1
34186cae:	d101      	bne.n	34186cb4 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    {
      LL_RCC_CLKP_Enable();
34186cb0:	f7ff fbc4 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of ADF1 clock*/
    __HAL_RCC_ADF1_CONFIG(PeriphClkInit->Adf1ClockSelection);
34186cb4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186cb8:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34186cbc:	4618      	mov	r0, r3
34186cbe:	f7fe fe89 	bl	341859d4 <LL_RCC_SetADFClockSource>
  }

  /*------------------------------------ CSI configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
34186cc2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186cc6:	e9d3 2300 	ldrd	r2, r3, [r3]
34186cca:	f002 0308 	and.w	r3, r2, #8
34186cce:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
34186cd2:	2300      	movs	r3, #0
34186cd4:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
34186cd8:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
34186cdc:	4603      	mov	r3, r0
34186cde:	460a      	mov	r2, r1
34186ce0:	4313      	orrs	r3, r2
34186ce2:	d017      	beq.n	34186d14 <HAL_RCCEx_PeriphCLKConfig+0x8bc>
    /* Check the parameters */
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));

    /* Set IC18 configuration */
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
34186ce4:	4b44      	ldr	r3, [pc, #272]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186ce6:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34186cea:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186cee:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186cf2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186cf6:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
34186cfa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186cfe:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34186d02:	3b01      	subs	r3, #1
34186d04:	041b      	lsls	r3, r3, #16
34186d06:	4313      	orrs	r3, r2
34186d08:	4a3b      	ldr	r2, [pc, #236]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186d0a:	430b      	orrs	r3, r1
34186d0c:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
               PeriphClkInit->ICSelection[RCC_IC18].ClockSelection | \
               ((PeriphClkInit->ICSelection[RCC_IC18].ClockDivider - 1U) << RCC_IC18CFGR_IC18INT_Pos));

    LL_RCC_IC18_Enable();
34186d10:	f7ff fb6a 	bl	341863e8 <LL_RCC_IC18_Enable>
  }

  /*---------------------- DCMIPP configuration ------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
34186d14:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186d18:	e9d3 2300 	ldrd	r2, r3, [r3]
34186d1c:	f002 0310 	and.w	r3, r2, #16
34186d20:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
34186d24:	2300      	movs	r3, #0
34186d26:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
34186d2a:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	@ 0x168
34186d2e:	4603      	mov	r3, r0
34186d30:	460a      	mov	r2, r1
34186d32:	4313      	orrs	r3, r2
34186d34:	d02f      	beq.n	34186d96 <HAL_RCCEx_PeriphCLKConfig+0x93e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));

    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
34186d36:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186d3a:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34186d3e:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34186d42:	d118      	bne.n	34186d76 <HAL_RCCEx_PeriphCLKConfig+0x91e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));

      /* Set IC17 configuration */
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
34186d44:	4b2c      	ldr	r3, [pc, #176]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186d46:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34186d4a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186d4e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186d52:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186d56:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
34186d5a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186d5e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34186d62:	3b01      	subs	r3, #1
34186d64:	041b      	lsls	r3, r3, #16
34186d66:	4313      	orrs	r3, r2
34186d68:	4a23      	ldr	r2, [pc, #140]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186d6a:	430b      	orrs	r3, r1
34186d6c:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
                 PeriphClkInit->ICSelection[RCC_IC17].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC17].ClockDivider - 1U) << RCC_IC17CFGR_IC17INT_Pos));

      LL_RCC_IC17_Enable();
34186d70:	f7ff fb2c 	bl	341863cc <LL_RCC_IC17_Enable>
34186d74:	e008      	b.n	34186d88 <HAL_RCCEx_PeriphCLKConfig+0x930>
    }
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
34186d76:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186d7a:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34186d7e:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34186d82:	d101      	bne.n	34186d88 <HAL_RCCEx_PeriphCLKConfig+0x930>
    {
      LL_RCC_CLKP_Enable();
34186d84:	f7ff fb5a 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the CEC clock source */
    __HAL_RCC_DCMIPP_CONFIG(PeriphClkInit->DcmippClockSelection);
34186d88:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186d8c:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34186d90:	4618      	mov	r0, r3
34186d92:	f7fe fe4b 	bl	34185a2c <LL_RCC_SetDCMIPPClockSource>
  }

  /*---------------------- ETH1 configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
34186d96:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186d9a:	e9d3 2300 	ldrd	r2, r3, [r3]
34186d9e:	f002 0320 	and.w	r3, r2, #32
34186da2:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
34186da6:	2300      	movs	r3, #0
34186da8:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
34186dac:	e9d7 0158 	ldrd	r0, r1, [r7, #352]	@ 0x160
34186db0:	4603      	mov	r3, r0
34186db2:	460a      	mov	r2, r1
34186db4:	4313      	orrs	r3, r2
34186db6:	d031      	beq.n	34186e1c <HAL_RCCEx_PeriphCLKConfig+0x9c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));

    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
34186db8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186dbc:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34186dc0:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34186dc4:	d11a      	bne.n	34186dfc <HAL_RCCEx_PeriphCLKConfig+0x9a4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));

      /* Set IC12 configuration */
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
34186dc6:	4b0c      	ldr	r3, [pc, #48]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186dc8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34186dcc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186dd0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186dd4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186dd8:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
34186dda:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186dde:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34186de0:	3b01      	subs	r3, #1
34186de2:	041b      	lsls	r3, r3, #16
34186de4:	4313      	orrs	r3, r2
34186de6:	4a04      	ldr	r2, [pc, #16]	@ (34186df8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34186de8:	430b      	orrs	r3, r1
34186dea:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
                 PeriphClkInit->ICSelection[RCC_IC12].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC12].ClockDivider - 1U) << RCC_IC12CFGR_IC12INT_Pos));

      LL_RCC_IC12_Enable();
34186dee:	f7ff faa7 	bl	34186340 <LL_RCC_IC12_Enable>
34186df2:	e00c      	b.n	34186e0e <HAL_RCCEx_PeriphCLKConfig+0x9b6>
34186df4:	0301041c 	.word	0x0301041c
34186df8:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
34186dfc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186e00:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34186e04:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34186e08:	d101      	bne.n	34186e0e <HAL_RCCEx_PeriphCLKConfig+0x9b6>
    {
      LL_RCC_CLKP_Enable();
34186e0a:	f7ff fb17 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 clock source */
    __HAL_RCC_ETH1_CONFIG(PeriphClkInit->Eth1ClockSelection);
34186e0e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186e12:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34186e16:	4618      	mov	r0, r3
34186e18:	f7fe fe1e 	bl	34185a58 <LL_RCC_SetETHClockSource>
  }

  /*---------------------- ETH1PHY configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
34186e1c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186e20:	e9d3 2300 	ldrd	r2, r3, [r3]
34186e24:	f002 0340 	and.w	r3, r2, #64	@ 0x40
34186e28:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
34186e2c:	2300      	movs	r3, #0
34186e2e:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
34186e32:	e9d7 0156 	ldrd	r0, r1, [r7, #344]	@ 0x158
34186e36:	4603      	mov	r3, r0
34186e38:	460a      	mov	r2, r1
34186e3a:	4313      	orrs	r3, r2
34186e3c:	d006      	beq.n	34186e4c <HAL_RCCEx_PeriphCLKConfig+0x9f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));

    /* Configure the source of ETH1 PHY interface */
    __HAL_RCC_ETH1PHY_CONFIG(PeriphClkInit->Eth1PhyInterfaceSelection);
34186e3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186e42:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34186e46:	4618      	mov	r0, r3
34186e48:	f7fe fe1c 	bl	34185a84 <LL_RCC_SetETHPHYInterface>
  }

  /*---------------------- ETH1 RX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
34186e4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186e50:	e9d3 2300 	ldrd	r2, r3, [r3]
34186e54:	f002 0380 	and.w	r3, r2, #128	@ 0x80
34186e58:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
34186e5c:	2300      	movs	r3, #0
34186e5e:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
34186e62:	e9d7 0154 	ldrd	r0, r1, [r7, #336]	@ 0x150
34186e66:	4603      	mov	r3, r0
34186e68:	460a      	mov	r2, r1
34186e6a:	4313      	orrs	r3, r2
34186e6c:	d006      	beq.n	34186e7c <HAL_RCCEx_PeriphCLKConfig+0xa24>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));

    /* Configure the ETH1 RX clock source */
    __HAL_RCC_ETH1RX_CONFIG(PeriphClkInit->Eth1RxClockSelection);
34186e6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186e72:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34186e76:	4618      	mov	r0, r3
34186e78:	f7fe fe1a 	bl	34185ab0 <LL_RCC_SetETHREFRXClockSource>
  }

  /*---------------------- ETH1 TX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
34186e7c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186e80:	e9d3 2300 	ldrd	r2, r3, [r3]
34186e84:	f402 7380 	and.w	r3, r2, #256	@ 0x100
34186e88:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
34186e8c:	2300      	movs	r3, #0
34186e8e:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
34186e92:	e9d7 0152 	ldrd	r0, r1, [r7, #328]	@ 0x148
34186e96:	4603      	mov	r3, r0
34186e98:	460a      	mov	r2, r1
34186e9a:	4313      	orrs	r3, r2
34186e9c:	d006      	beq.n	34186eac <HAL_RCCEx_PeriphCLKConfig+0xa54>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));

    /* Configure the ETH1 TX clock source */
    __HAL_RCC_ETH1TX_CONFIG(PeriphClkInit->Eth1TxClockSelection);
34186e9e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186ea2:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
34186ea6:	4618      	mov	r0, r3
34186ea8:	f7fe fe18 	bl	34185adc <LL_RCC_SetETHREFTXClockSource>
  }

  /*---------------------- ETH1 PTP configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
34186eac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186eb0:	e9d3 2300 	ldrd	r2, r3, [r3]
34186eb4:	f402 7300 	and.w	r3, r2, #512	@ 0x200
34186eb8:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
34186ebc:	2300      	movs	r3, #0
34186ebe:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
34186ec2:	e9d7 0150 	ldrd	r0, r1, [r7, #320]	@ 0x140
34186ec6:	4603      	mov	r3, r0
34186ec8:	460a      	mov	r2, r1
34186eca:	4313      	orrs	r3, r2
34186ecc:	d038      	beq.n	34186f40 <HAL_RCCEx_PeriphCLKConfig+0xae8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));

    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
34186ece:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186ed2:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34186ed6:	2b02      	cmp	r3, #2
34186ed8:	d116      	bne.n	34186f08 <HAL_RCCEx_PeriphCLKConfig+0xab0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));

      /* Set IC13 configuration */
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
34186eda:	4bbc      	ldr	r3, [pc, #752]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34186edc:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34186ee0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186ee4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186ee8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186eec:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
34186eee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186ef2:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34186ef4:	3b01      	subs	r3, #1
34186ef6:	041b      	lsls	r3, r3, #16
34186ef8:	4313      	orrs	r3, r2
34186efa:	4ab4      	ldr	r2, [pc, #720]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34186efc:	430b      	orrs	r3, r1
34186efe:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
                 PeriphClkInit->ICSelection[RCC_IC13].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC13].ClockDivider - 1U) << RCC_IC13CFGR_IC13INT_Pos));

      LL_RCC_IC13_Enable();
34186f02:	f7ff fa2b 	bl	3418635c <LL_RCC_IC13_Enable>
34186f06:	e007      	b.n	34186f18 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    }
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
34186f08:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186f0c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34186f10:	2b01      	cmp	r3, #1
34186f12:	d101      	bne.n	34186f18 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    {
      LL_RCC_CLKP_Enable();
34186f14:	f7ff fa92 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 PTP clock source and divider */
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
34186f18:	4bac      	ldr	r3, [pc, #688]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34186f1a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34186f1e:	f023 01f3 	bic.w	r1, r3, #243	@ 0xf3
34186f22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186f26:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34186f2a:	3b01      	subs	r3, #1
34186f2c:	011a      	lsls	r2, r3, #4
34186f2e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186f32:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34186f36:	4313      	orrs	r3, r2
34186f38:	4aa4      	ldr	r2, [pc, #656]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34186f3a:	430b      	orrs	r3, r1
34186f3c:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
               (((PeriphClkInit->Eth1PtpDivider - 1U) << RCC_CCIPR2_ETH1PTPDIV_Pos) | PeriphClkInit->Eth1PtpClockSelection));
  }

  /*---------------------- FDCAN configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
34186f40:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186f44:	e9d3 2300 	ldrd	r2, r3, [r3]
34186f48:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
34186f4c:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
34186f50:	2300      	movs	r3, #0
34186f52:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
34186f56:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
34186f5a:	4603      	mov	r3, r0
34186f5c:	460a      	mov	r2, r1
34186f5e:	4313      	orrs	r3, r2
34186f60:	d02d      	beq.n	34186fbe <HAL_RCCEx_PeriphCLKConfig+0xb66>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
34186f62:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186f66:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34186f6a:	2b02      	cmp	r3, #2
34186f6c:	d118      	bne.n	34186fa0 <HAL_RCCEx_PeriphCLKConfig+0xb48>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
34186f6e:	4b97      	ldr	r3, [pc, #604]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34186f70:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34186f74:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186f78:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186f7c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186f80:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34186f84:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186f88:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34186f8c:	3b01      	subs	r3, #1
34186f8e:	041b      	lsls	r3, r3, #16
34186f90:	4313      	orrs	r3, r2
34186f92:	4a8e      	ldr	r2, [pc, #568]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34186f94:	430b      	orrs	r3, r1
34186f96:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
34186f9a:	f7ff fa33 	bl	34186404 <LL_RCC_IC19_Enable>
34186f9e:	e007      	b.n	34186fb0 <HAL_RCCEx_PeriphCLKConfig+0xb58>
    }
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
34186fa0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186fa4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34186fa8:	2b01      	cmp	r3, #1
34186faa:	d101      	bne.n	34186fb0 <HAL_RCCEx_PeriphCLKConfig+0xb58>
    {
      LL_RCC_CLKP_Enable();
34186fac:	f7ff fa46 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FDCAN clock*/
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
34186fb0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186fb4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34186fb8:	4618      	mov	r0, r3
34186fba:	f7fe fda5 	bl	34185b08 <LL_RCC_SetFDCANClockSource>
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
34186fbe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186fc2:	e9d3 2300 	ldrd	r2, r3, [r3]
34186fc6:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
34186fca:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
34186fce:	2300      	movs	r3, #0
34186fd0:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
34186fd4:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
34186fd8:	4603      	mov	r3, r0
34186fda:	460a      	mov	r2, r1
34186fdc:	4313      	orrs	r3, r2
34186fde:	d04b      	beq.n	34187078 <HAL_RCCEx_PeriphCLKConfig+0xc20>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
34186fe0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34186fe4:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34186fe8:	4b79      	ldr	r3, [pc, #484]	@ (341871d0 <HAL_RCCEx_PeriphCLKConfig+0xd78>)
34186fea:	429a      	cmp	r2, r3
34186fec:	d116      	bne.n	3418701c <HAL_RCCEx_PeriphCLKConfig+0xbc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34186fee:	4b77      	ldr	r3, [pc, #476]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34186ff0:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34186ff4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34186ff8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34186ffc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187000:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34187002:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187006:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34187008:	3b01      	subs	r3, #1
3418700a:	041b      	lsls	r3, r3, #16
3418700c:	4313      	orrs	r3, r2
3418700e:	4a6f      	ldr	r2, [pc, #444]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34187010:	430b      	orrs	r3, r1
34187012:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34187016:	f7ff f985 	bl	34186324 <LL_RCC_IC10_Enable>
3418701a:	e026      	b.n	3418706a <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
3418701c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187020:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34187024:	4b6b      	ldr	r3, [pc, #428]	@ (341871d4 <HAL_RCCEx_PeriphCLKConfig+0xd7c>)
34187026:	429a      	cmp	r2, r3
34187028:	d116      	bne.n	34187058 <HAL_RCCEx_PeriphCLKConfig+0xc00>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418702a:	4b68      	ldr	r3, [pc, #416]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418702c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34187030:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187034:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187038:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418703c:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418703e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187042:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34187044:	3b01      	subs	r3, #1
34187046:	041b      	lsls	r3, r3, #16
34187048:	4313      	orrs	r3, r2
3418704a:	4a60      	ldr	r2, [pc, #384]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418704c:	430b      	orrs	r3, r1
3418704e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34187052:	f7ff f99f 	bl	34186394 <LL_RCC_IC15_Enable>
34187056:	e008      	b.n	3418706a <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
34187058:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418705c:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34187060:	4b5d      	ldr	r3, [pc, #372]	@ (341871d8 <HAL_RCCEx_PeriphCLKConfig+0xd80>)
34187062:	429a      	cmp	r2, r3
34187064:	d101      	bne.n	3418706a <HAL_RCCEx_PeriphCLKConfig+0xc12>
    {
      LL_RCC_CLKP_Enable();
34187066:	f7ff f9e9 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C1 clock*/
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
3418706a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418706e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34187072:	4618      	mov	r0, r3
34187074:	f7fe fd74 	bl	34185b60 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
34187078:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418707c:	e9d3 2300 	ldrd	r2, r3, [r3]
34187080:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
34187084:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
34187088:	2300      	movs	r3, #0
3418708a:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
3418708e:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
34187092:	4603      	mov	r3, r0
34187094:	460a      	mov	r2, r1
34187096:	4313      	orrs	r3, r2
34187098:	d04b      	beq.n	34187132 <HAL_RCCEx_PeriphCLKConfig+0xcda>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
3418709a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418709e:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
341870a2:	4b4e      	ldr	r3, [pc, #312]	@ (341871dc <HAL_RCCEx_PeriphCLKConfig+0xd84>)
341870a4:	429a      	cmp	r2, r3
341870a6:	d116      	bne.n	341870d6 <HAL_RCCEx_PeriphCLKConfig+0xc7e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
341870a8:	4b48      	ldr	r3, [pc, #288]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
341870aa:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
341870ae:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341870b2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341870b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341870ba:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
341870bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341870c0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341870c2:	3b01      	subs	r3, #1
341870c4:	041b      	lsls	r3, r3, #16
341870c6:	4313      	orrs	r3, r2
341870c8:	4a40      	ldr	r2, [pc, #256]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
341870ca:	430b      	orrs	r3, r1
341870cc:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
341870d0:	f7ff f928 	bl	34186324 <LL_RCC_IC10_Enable>
341870d4:	e026      	b.n	34187124 <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
341870d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341870da:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
341870de:	4b40      	ldr	r3, [pc, #256]	@ (341871e0 <HAL_RCCEx_PeriphCLKConfig+0xd88>)
341870e0:	429a      	cmp	r2, r3
341870e2:	d116      	bne.n	34187112 <HAL_RCCEx_PeriphCLKConfig+0xcba>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
341870e4:	4b39      	ldr	r3, [pc, #228]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
341870e6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341870ea:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341870ee:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341870f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341870f6:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
341870f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341870fc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
341870fe:	3b01      	subs	r3, #1
34187100:	041b      	lsls	r3, r3, #16
34187102:	4313      	orrs	r3, r2
34187104:	4a31      	ldr	r2, [pc, #196]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34187106:	430b      	orrs	r3, r1
34187108:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418710c:	f7ff f942 	bl	34186394 <LL_RCC_IC15_Enable>
34187110:	e008      	b.n	34187124 <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
34187112:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187116:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3418711a:	4b32      	ldr	r3, [pc, #200]	@ (341871e4 <HAL_RCCEx_PeriphCLKConfig+0xd8c>)
3418711c:	429a      	cmp	r2, r3
3418711e:	d101      	bne.n	34187124 <HAL_RCCEx_PeriphCLKConfig+0xccc>
    {
      LL_RCC_CLKP_Enable();
34187120:	f7ff f98c 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C2 clock*/
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
34187124:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187128:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3418712c:	4618      	mov	r0, r3
3418712e:	f7fe fd17 	bl	34185b60 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C3 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
34187132:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187136:	e9d3 2300 	ldrd	r2, r3, [r3]
3418713a:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
3418713e:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
34187142:	2300      	movs	r3, #0
34187144:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
34187148:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
3418714c:	4603      	mov	r3, r0
3418714e:	460a      	mov	r2, r1
34187150:	4313      	orrs	r3, r2
34187152:	d05d      	beq.n	34187210 <HAL_RCCEx_PeriphCLKConfig+0xdb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
34187154:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187158:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3418715c:	4b22      	ldr	r3, [pc, #136]	@ (341871e8 <HAL_RCCEx_PeriphCLKConfig+0xd90>)
3418715e:	429a      	cmp	r2, r3
34187160:	d116      	bne.n	34187190 <HAL_RCCEx_PeriphCLKConfig+0xd38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34187162:	4b1a      	ldr	r3, [pc, #104]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34187164:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34187168:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418716c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187170:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187174:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34187176:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418717a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418717c:	3b01      	subs	r3, #1
3418717e:	041b      	lsls	r3, r3, #16
34187180:	4313      	orrs	r3, r2
34187182:	4a12      	ldr	r2, [pc, #72]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34187184:	430b      	orrs	r3, r1
34187186:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3418718a:	f7ff f8cb 	bl	34186324 <LL_RCC_IC10_Enable>
3418718e:	e038      	b.n	34187202 <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
34187190:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187194:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34187198:	4b14      	ldr	r3, [pc, #80]	@ (341871ec <HAL_RCCEx_PeriphCLKConfig+0xd94>)
3418719a:	429a      	cmp	r2, r3
3418719c:	d128      	bne.n	341871f0 <HAL_RCCEx_PeriphCLKConfig+0xd98>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418719e:	4b0b      	ldr	r3, [pc, #44]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
341871a0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341871a4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341871a8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341871ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341871b0:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
341871b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341871b6:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
341871b8:	3b01      	subs	r3, #1
341871ba:	041b      	lsls	r3, r3, #16
341871bc:	4313      	orrs	r3, r2
341871be:	4a03      	ldr	r2, [pc, #12]	@ (341871cc <HAL_RCCEx_PeriphCLKConfig+0xd74>)
341871c0:	430b      	orrs	r3, r1
341871c2:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
341871c6:	f7ff f8e5 	bl	34186394 <LL_RCC_IC15_Enable>
341871ca:	e01a      	b.n	34187202 <HAL_RCCEx_PeriphCLKConfig+0xdaa>
341871cc:	56028000 	.word	0x56028000
341871d0:	0702000c 	.word	0x0702000c
341871d4:	0703000c 	.word	0x0703000c
341871d8:	0701000c 	.word	0x0701000c
341871dc:	0702040c 	.word	0x0702040c
341871e0:	0703040c 	.word	0x0703040c
341871e4:	0701040c 	.word	0x0701040c
341871e8:	0702080c 	.word	0x0702080c
341871ec:	0703080c 	.word	0x0703080c
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
341871f0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341871f4:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
341871f8:	4bc8      	ldr	r3, [pc, #800]	@ (3418751c <HAL_RCCEx_PeriphCLKConfig+0x10c4>)
341871fa:	429a      	cmp	r2, r3
341871fc:	d101      	bne.n	34187202 <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    {
      LL_RCC_CLKP_Enable();
341871fe:	f7ff f91d 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C3 clock*/
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
34187202:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187206:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3418720a:	4618      	mov	r0, r3
3418720c:	f7fe fca8 	bl	34185b60 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
34187210:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187214:	e9d3 2300 	ldrd	r2, r3, [r3]
34187218:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
3418721c:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
34187220:	2300      	movs	r3, #0
34187222:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
34187226:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
3418722a:	4603      	mov	r3, r0
3418722c:	460a      	mov	r2, r1
3418722e:	4313      	orrs	r3, r2
34187230:	d04b      	beq.n	341872ca <HAL_RCCEx_PeriphCLKConfig+0xe72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
34187232:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187236:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3418723a:	4bb9      	ldr	r3, [pc, #740]	@ (34187520 <HAL_RCCEx_PeriphCLKConfig+0x10c8>)
3418723c:	429a      	cmp	r2, r3
3418723e:	d116      	bne.n	3418726e <HAL_RCCEx_PeriphCLKConfig+0xe16>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34187240:	4bb8      	ldr	r3, [pc, #736]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34187242:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34187246:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418724a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418724e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187252:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34187254:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187258:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418725a:	3b01      	subs	r3, #1
3418725c:	041b      	lsls	r3, r3, #16
3418725e:	4313      	orrs	r3, r2
34187260:	4ab0      	ldr	r2, [pc, #704]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34187262:	430b      	orrs	r3, r1
34187264:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34187268:	f7ff f85c 	bl	34186324 <LL_RCC_IC10_Enable>
3418726c:	e026      	b.n	341872bc <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
3418726e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187272:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34187276:	4bac      	ldr	r3, [pc, #688]	@ (34187528 <HAL_RCCEx_PeriphCLKConfig+0x10d0>)
34187278:	429a      	cmp	r2, r3
3418727a:	d116      	bne.n	341872aa <HAL_RCCEx_PeriphCLKConfig+0xe52>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418727c:	4ba9      	ldr	r3, [pc, #676]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418727e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34187282:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187286:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418728a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418728e:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34187290:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187294:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34187296:	3b01      	subs	r3, #1
34187298:	041b      	lsls	r3, r3, #16
3418729a:	4313      	orrs	r3, r2
3418729c:	4aa1      	ldr	r2, [pc, #644]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418729e:	430b      	orrs	r3, r1
341872a0:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
341872a4:	f7ff f876 	bl	34186394 <LL_RCC_IC15_Enable>
341872a8:	e008      	b.n	341872bc <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
341872aa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341872ae:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
341872b2:	4b9e      	ldr	r3, [pc, #632]	@ (3418752c <HAL_RCCEx_PeriphCLKConfig+0x10d4>)
341872b4:	429a      	cmp	r2, r3
341872b6:	d101      	bne.n	341872bc <HAL_RCCEx_PeriphCLKConfig+0xe64>
    {
      LL_RCC_CLKP_Enable();
341872b8:	f7ff f8c0 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C4 clock*/
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
341872bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341872c0:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
341872c4:	4618      	mov	r0, r3
341872c6:	f7fe fc4b 	bl	34185b60 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I3C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
341872ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341872ce:	e9d3 2300 	ldrd	r2, r3, [r3]
341872d2:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
341872d6:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
341872da:	2300      	movs	r3, #0
341872dc:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
341872e0:	e9d7 0144 	ldrd	r0, r1, [r7, #272]	@ 0x110
341872e4:	4603      	mov	r3, r0
341872e6:	460a      	mov	r2, r1
341872e8:	4313      	orrs	r3, r2
341872ea:	d04b      	beq.n	34187384 <HAL_RCCEx_PeriphCLKConfig+0xf2c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));

    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
341872ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341872f0:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
341872f4:	4b8e      	ldr	r3, [pc, #568]	@ (34187530 <HAL_RCCEx_PeriphCLKConfig+0x10d8>)
341872f6:	429a      	cmp	r2, r3
341872f8:	d116      	bne.n	34187328 <HAL_RCCEx_PeriphCLKConfig+0xed0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
341872fa:	4b8a      	ldr	r3, [pc, #552]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
341872fc:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34187300:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187304:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187308:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418730c:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3418730e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187312:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34187314:	3b01      	subs	r3, #1
34187316:	041b      	lsls	r3, r3, #16
34187318:	4313      	orrs	r3, r2
3418731a:	4a82      	ldr	r2, [pc, #520]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418731c:	430b      	orrs	r3, r1
3418731e:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34187322:	f7fe ffff 	bl	34186324 <LL_RCC_IC10_Enable>
34187326:	e026      	b.n	34187376 <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
34187328:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418732c:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34187330:	4b80      	ldr	r3, [pc, #512]	@ (34187534 <HAL_RCCEx_PeriphCLKConfig+0x10dc>)
34187332:	429a      	cmp	r2, r3
34187334:	d116      	bne.n	34187364 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34187336:	4b7b      	ldr	r3, [pc, #492]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34187338:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418733c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187340:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187344:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187348:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418734a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418734e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34187350:	3b01      	subs	r3, #1
34187352:	041b      	lsls	r3, r3, #16
34187354:	4313      	orrs	r3, r2
34187356:	4a73      	ldr	r2, [pc, #460]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34187358:	430b      	orrs	r3, r1
3418735a:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418735e:	f7ff f819 	bl	34186394 <LL_RCC_IC15_Enable>
34187362:	e008      	b.n	34187376 <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
34187364:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187368:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3418736c:	4b72      	ldr	r3, [pc, #456]	@ (34187538 <HAL_RCCEx_PeriphCLKConfig+0x10e0>)
3418736e:	429a      	cmp	r2, r3
34187370:	d101      	bne.n	34187376 <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    {
      LL_RCC_CLKP_Enable();
34187372:	f7ff f863 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C1 clock*/
    __HAL_RCC_I3C1_CONFIG(PeriphClkInit->I3c1ClockSelection);
34187376:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418737a:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418737e:	4618      	mov	r0, r3
34187380:	f7fe fbf9 	bl	34185b76 <LL_RCC_SetI3CClockSource>
  }

  /*------------------------------ I3C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
34187384:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187388:	e9d3 2300 	ldrd	r2, r3, [r3]
3418738c:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
34187390:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
34187394:	2300      	movs	r3, #0
34187396:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
3418739a:	e9d7 0142 	ldrd	r0, r1, [r7, #264]	@ 0x108
3418739e:	4603      	mov	r3, r0
341873a0:	460a      	mov	r2, r1
341873a2:	4313      	orrs	r3, r2
341873a4:	d04b      	beq.n	3418743e <HAL_RCCEx_PeriphCLKConfig+0xfe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));

    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
341873a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341873aa:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
341873ae:	4b63      	ldr	r3, [pc, #396]	@ (3418753c <HAL_RCCEx_PeriphCLKConfig+0x10e4>)
341873b0:	429a      	cmp	r2, r3
341873b2:	d116      	bne.n	341873e2 <HAL_RCCEx_PeriphCLKConfig+0xf8a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
341873b4:	4b5b      	ldr	r3, [pc, #364]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
341873b6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
341873ba:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341873be:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341873c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341873c6:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
341873c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341873cc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341873ce:	3b01      	subs	r3, #1
341873d0:	041b      	lsls	r3, r3, #16
341873d2:	4313      	orrs	r3, r2
341873d4:	4a53      	ldr	r2, [pc, #332]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
341873d6:	430b      	orrs	r3, r1
341873d8:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
341873dc:	f7fe ffa2 	bl	34186324 <LL_RCC_IC10_Enable>
341873e0:	e026      	b.n	34187430 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
341873e2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341873e6:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
341873ea:	4b55      	ldr	r3, [pc, #340]	@ (34187540 <HAL_RCCEx_PeriphCLKConfig+0x10e8>)
341873ec:	429a      	cmp	r2, r3
341873ee:	d116      	bne.n	3418741e <HAL_RCCEx_PeriphCLKConfig+0xfc6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
341873f0:	4b4c      	ldr	r3, [pc, #304]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
341873f2:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341873f6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341873fa:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341873fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187402:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34187404:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187408:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418740a:	3b01      	subs	r3, #1
3418740c:	041b      	lsls	r3, r3, #16
3418740e:	4313      	orrs	r3, r2
34187410:	4a44      	ldr	r2, [pc, #272]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34187412:	430b      	orrs	r3, r1
34187414:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34187418:	f7fe ffbc 	bl	34186394 <LL_RCC_IC15_Enable>
3418741c:	e008      	b.n	34187430 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
3418741e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187422:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34187426:	4b47      	ldr	r3, [pc, #284]	@ (34187544 <HAL_RCCEx_PeriphCLKConfig+0x10ec>)
34187428:	429a      	cmp	r2, r3
3418742a:	d101      	bne.n	34187430 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    {
      LL_RCC_CLKP_Enable();
3418742c:	f7ff f806 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C2 clock*/
    __HAL_RCC_I3C2_CONFIG(PeriphClkInit->I3c2ClockSelection);
34187430:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187434:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34187438:	4618      	mov	r0, r3
3418743a:	f7fe fb9c 	bl	34185b76 <LL_RCC_SetI3CClockSource>
  }

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
3418743e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187442:	e9d3 2300 	ldrd	r2, r3, [r3]
34187446:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
3418744a:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
3418744e:	2300      	movs	r3, #0
34187450:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
34187454:	e9d7 0140 	ldrd	r0, r1, [r7, #256]	@ 0x100
34187458:	4603      	mov	r3, r0
3418745a:	460a      	mov	r2, r1
3418745c:	4313      	orrs	r3, r2
3418745e:	d02d      	beq.n	341874bc <HAL_RCCEx_PeriphCLKConfig+0x1064>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
34187460:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187464:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34187468:	4b37      	ldr	r3, [pc, #220]	@ (34187548 <HAL_RCCEx_PeriphCLKConfig+0x10f0>)
3418746a:	429a      	cmp	r2, r3
3418746c:	d116      	bne.n	3418749c <HAL_RCCEx_PeriphCLKConfig+0x1044>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418746e:	4b2d      	ldr	r3, [pc, #180]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34187470:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34187474:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187478:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418747c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187480:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34187482:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187486:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34187488:	3b01      	subs	r3, #1
3418748a:	041b      	lsls	r3, r3, #16
3418748c:	4313      	orrs	r3, r2
3418748e:	4a25      	ldr	r2, [pc, #148]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34187490:	430b      	orrs	r3, r1
34187492:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34187496:	f7fe ff7d 	bl	34186394 <LL_RCC_IC15_Enable>
3418749a:	e008      	b.n	341874ae <HAL_RCCEx_PeriphCLKConfig+0x1056>
    }
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
3418749c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341874a0:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
341874a4:	4b29      	ldr	r3, [pc, #164]	@ (3418754c <HAL_RCCEx_PeriphCLKConfig+0x10f4>)
341874a6:	429a      	cmp	r2, r3
341874a8:	d101      	bne.n	341874ae <HAL_RCCEx_PeriphCLKConfig+0x1056>
    {
      LL_RCC_CLKP_Enable();
341874aa:	f7fe ffc7 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM1 clock*/
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
341874ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341874b2:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
341874b6:	4618      	mov	r0, r3
341874b8:	f7fe fb68 	bl	34185b8c <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM2 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
341874bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341874c0:	e9d3 2300 	ldrd	r2, r3, [r3]
341874c4:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
341874c8:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
341874cc:	2300      	movs	r3, #0
341874ce:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
341874d2:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
341874d6:	4603      	mov	r3, r0
341874d8:	460a      	mov	r2, r1
341874da:	4313      	orrs	r3, r2
341874dc:	d04a      	beq.n	34187574 <HAL_RCCEx_PeriphCLKConfig+0x111c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
341874de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341874e2:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
341874e6:	4b1a      	ldr	r3, [pc, #104]	@ (34187550 <HAL_RCCEx_PeriphCLKConfig+0x10f8>)
341874e8:	429a      	cmp	r2, r3
341874ea:	d133      	bne.n	34187554 <HAL_RCCEx_PeriphCLKConfig+0x10fc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
341874ec:	4b0d      	ldr	r3, [pc, #52]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
341874ee:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341874f2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341874f6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341874fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341874fe:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34187500:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187504:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34187506:	3b01      	subs	r3, #1
34187508:	041b      	lsls	r3, r3, #16
3418750a:	4313      	orrs	r3, r2
3418750c:	4a05      	ldr	r2, [pc, #20]	@ (34187524 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418750e:	430b      	orrs	r3, r1
34187510:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34187514:	f7fe ff3e 	bl	34186394 <LL_RCC_IC15_Enable>
34187518:	e025      	b.n	34187566 <HAL_RCCEx_PeriphCLKConfig+0x110e>
3418751a:	bf00      	nop
3418751c:	0701080c 	.word	0x0701080c
34187520:	07020c0c 	.word	0x07020c0c
34187524:	56028000 	.word	0x56028000
34187528:	07030c0c 	.word	0x07030c0c
3418752c:	07010c0c 	.word	0x07010c0c
34187530:	0702100c 	.word	0x0702100c
34187534:	0703100c 	.word	0x0703100c
34187538:	0701100c 	.word	0x0701100c
3418753c:	0702140c 	.word	0x0702140c
34187540:	0703140c 	.word	0x0703140c
34187544:	0701140c 	.word	0x0701140c
34187548:	0702082c 	.word	0x0702082c
3418754c:	0701082c 	.word	0x0701082c
34187550:	07020c2c 	.word	0x07020c2c
    }
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
34187554:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187558:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3418755c:	4bca      	ldr	r3, [pc, #808]	@ (34187888 <HAL_RCCEx_PeriphCLKConfig+0x1430>)
3418755e:	429a      	cmp	r2, r3
34187560:	d101      	bne.n	34187566 <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      LL_RCC_CLKP_Enable();
34187562:	f7fe ff6b 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM2 clock*/
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
34187566:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418756a:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3418756e:	4618      	mov	r0, r3
34187570:	f7fe fb0c 	bl	34185b8c <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM3 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
34187574:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187578:	e9d3 2300 	ldrd	r2, r3, [r3]
3418757c:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
34187580:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
34187584:	2300      	movs	r3, #0
34187586:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
3418758a:	e9d7 013c 	ldrd	r0, r1, [r7, #240]	@ 0xf0
3418758e:	4603      	mov	r3, r0
34187590:	460a      	mov	r2, r1
34187592:	4313      	orrs	r3, r2
34187594:	d02d      	beq.n	341875f2 <HAL_RCCEx_PeriphCLKConfig+0x119a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
34187596:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418759a:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3418759e:	4bbb      	ldr	r3, [pc, #748]	@ (3418788c <HAL_RCCEx_PeriphCLKConfig+0x1434>)
341875a0:	429a      	cmp	r2, r3
341875a2:	d116      	bne.n	341875d2 <HAL_RCCEx_PeriphCLKConfig+0x117a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
341875a4:	4bba      	ldr	r3, [pc, #744]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
341875a6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341875aa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341875ae:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341875b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341875b6:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
341875b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341875bc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
341875be:	3b01      	subs	r3, #1
341875c0:	041b      	lsls	r3, r3, #16
341875c2:	4313      	orrs	r3, r2
341875c4:	4ab2      	ldr	r2, [pc, #712]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
341875c6:	430b      	orrs	r3, r1
341875c8:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
341875cc:	f7fe fee2 	bl	34186394 <LL_RCC_IC15_Enable>
341875d0:	e008      	b.n	341875e4 <HAL_RCCEx_PeriphCLKConfig+0x118c>
    }
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
341875d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341875d6:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
341875da:	4bae      	ldr	r3, [pc, #696]	@ (34187894 <HAL_RCCEx_PeriphCLKConfig+0x143c>)
341875dc:	429a      	cmp	r2, r3
341875de:	d101      	bne.n	341875e4 <HAL_RCCEx_PeriphCLKConfig+0x118c>
    {
      LL_RCC_CLKP_Enable();
341875e0:	f7fe ff2c 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM3 clock */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
341875e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341875e8:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
341875ec:	4618      	mov	r0, r3
341875ee:	f7fe facd 	bl	34185b8c <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM4 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
341875f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341875f6:	e9d3 2300 	ldrd	r2, r3, [r3]
341875fa:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
341875fe:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
34187602:	2300      	movs	r3, #0
34187604:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
34187608:	e9d7 013a 	ldrd	r0, r1, [r7, #232]	@ 0xe8
3418760c:	4603      	mov	r3, r0
3418760e:	460a      	mov	r2, r1
34187610:	4313      	orrs	r3, r2
34187612:	d02d      	beq.n	34187670 <HAL_RCCEx_PeriphCLKConfig+0x1218>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));

    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
34187614:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187618:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3418761c:	4b9e      	ldr	r3, [pc, #632]	@ (34187898 <HAL_RCCEx_PeriphCLKConfig+0x1440>)
3418761e:	429a      	cmp	r2, r3
34187620:	d116      	bne.n	34187650 <HAL_RCCEx_PeriphCLKConfig+0x11f8>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34187622:	4b9b      	ldr	r3, [pc, #620]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34187624:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34187628:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418762c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187630:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187634:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34187636:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418763a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418763c:	3b01      	subs	r3, #1
3418763e:	041b      	lsls	r3, r3, #16
34187640:	4313      	orrs	r3, r2
34187642:	4a93      	ldr	r2, [pc, #588]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34187644:	430b      	orrs	r3, r1
34187646:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418764a:	f7fe fea3 	bl	34186394 <LL_RCC_IC15_Enable>
3418764e:	e008      	b.n	34187662 <HAL_RCCEx_PeriphCLKConfig+0x120a>
    }
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
34187650:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187654:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34187658:	4b90      	ldr	r3, [pc, #576]	@ (3418789c <HAL_RCCEx_PeriphCLKConfig+0x1444>)
3418765a:	429a      	cmp	r2, r3
3418765c:	d101      	bne.n	34187662 <HAL_RCCEx_PeriphCLKConfig+0x120a>
    {
      LL_RCC_CLKP_Enable();
3418765e:	f7fe feed 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM4 clock */
    __HAL_RCC_LPTIM4_CONFIG(PeriphClkInit->Lptim4ClockSelection);
34187662:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187666:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3418766a:	4618      	mov	r0, r3
3418766c:	f7fe fa8e 	bl	34185b8c <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM5 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
34187670:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187674:	e9d3 2300 	ldrd	r2, r3, [r3]
34187678:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
3418767c:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
34187680:	2300      	movs	r3, #0
34187682:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
34187686:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
3418768a:	4603      	mov	r3, r0
3418768c:	460a      	mov	r2, r1
3418768e:	4313      	orrs	r3, r2
34187690:	d02d      	beq.n	341876ee <HAL_RCCEx_PeriphCLKConfig+0x1296>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));

    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
34187692:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187696:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3418769a:	4b81      	ldr	r3, [pc, #516]	@ (341878a0 <HAL_RCCEx_PeriphCLKConfig+0x1448>)
3418769c:	429a      	cmp	r2, r3
3418769e:	d116      	bne.n	341876ce <HAL_RCCEx_PeriphCLKConfig+0x1276>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
341876a0:	4b7b      	ldr	r3, [pc, #492]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
341876a2:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341876a6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341876aa:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341876ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341876b2:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
341876b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341876b8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
341876ba:	3b01      	subs	r3, #1
341876bc:	041b      	lsls	r3, r3, #16
341876be:	4313      	orrs	r3, r2
341876c0:	4a73      	ldr	r2, [pc, #460]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
341876c2:	430b      	orrs	r3, r1
341876c4:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
341876c8:	f7fe fe64 	bl	34186394 <LL_RCC_IC15_Enable>
341876cc:	e008      	b.n	341876e0 <HAL_RCCEx_PeriphCLKConfig+0x1288>
    }
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
341876ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341876d2:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
341876d6:	4b73      	ldr	r3, [pc, #460]	@ (341878a4 <HAL_RCCEx_PeriphCLKConfig+0x144c>)
341876d8:	429a      	cmp	r2, r3
341876da:	d101      	bne.n	341876e0 <HAL_RCCEx_PeriphCLKConfig+0x1288>
    {
      LL_RCC_CLKP_Enable();
341876dc:	f7fe feae 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM5 clock */
    __HAL_RCC_LPTIM5_CONFIG(PeriphClkInit->Lptim5ClockSelection);
341876e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341876e4:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
341876e8:	4618      	mov	r0, r3
341876ea:	f7fe fa4f 	bl	34185b8c <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
341876ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341876f2:	e9d3 2300 	ldrd	r2, r3, [r3]
341876f6:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
341876fa:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
341876fe:	2300      	movs	r3, #0
34187700:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
34187704:	e9d7 0136 	ldrd	r0, r1, [r7, #216]	@ 0xd8
34187708:	4603      	mov	r3, r0
3418770a:	460a      	mov	r2, r1
3418770c:	4313      	orrs	r3, r2
3418770e:	d04b      	beq.n	341877a8 <HAL_RCCEx_PeriphCLKConfig+0x1350>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
34187710:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187714:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34187718:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418771c:	d116      	bne.n	3418774c <HAL_RCCEx_PeriphCLKConfig+0x12f4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418771e:	4b5c      	ldr	r3, [pc, #368]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34187720:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34187724:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187728:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418772c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187730:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34187732:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187736:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34187738:	3b01      	subs	r3, #1
3418773a:	041b      	lsls	r3, r3, #16
3418773c:	4313      	orrs	r3, r2
3418773e:	4a54      	ldr	r2, [pc, #336]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34187740:	430b      	orrs	r3, r1
34187742:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34187746:	f7fe fddf 	bl	34186308 <LL_RCC_IC9_Enable>
3418774a:	e026      	b.n	3418779a <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
3418774c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187750:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34187754:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34187758:	d116      	bne.n	34187788 <HAL_RCCEx_PeriphCLKConfig+0x1330>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418775a:	4b4d      	ldr	r3, [pc, #308]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418775c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34187760:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187764:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187768:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418776c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418776e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187772:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34187774:	3b01      	subs	r3, #1
34187776:	041b      	lsls	r3, r3, #16
34187778:	4313      	orrs	r3, r2
3418777a:	4a45      	ldr	r2, [pc, #276]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418777c:	430b      	orrs	r3, r1
3418777e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34187782:	f7fe fdf9 	bl	34186378 <LL_RCC_IC14_Enable>
34187786:	e008      	b.n	3418779a <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
34187788:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418778c:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34187790:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34187794:	d101      	bne.n	3418779a <HAL_RCCEx_PeriphCLKConfig+0x1342>
    {
      LL_RCC_CLKP_Enable();
34187796:	f7fe fe51 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPUART1 clock */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
3418779a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418779e:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
341877a2:	4618      	mov	r0, r3
341877a4:	f7fe f9fe 	bl	34185ba4 <LL_RCC_SetLPUARTClockSource>
  }

  /*-------------------------- LTDC Configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
341877a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341877ac:	e9d3 2300 	ldrd	r2, r3, [r3]
341877b0:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
341877b4:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
341877b8:	2300      	movs	r3, #0
341877ba:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
341877be:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
341877c2:	4603      	mov	r3, r0
341877c4:	460a      	mov	r2, r1
341877c6:	4313      	orrs	r3, r2
341877c8:	d02f      	beq.n	3418782a <HAL_RCCEx_PeriphCLKConfig+0x13d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));

    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
341877ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341877ce:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
341877d2:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
341877d6:	d118      	bne.n	3418780a <HAL_RCCEx_PeriphCLKConfig+0x13b2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));

      /* Set IC16 configuration */
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
341877d8:	4b2d      	ldr	r3, [pc, #180]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
341877da:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
341877de:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341877e2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341877e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341877ea:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
341877ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341877f2:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
341877f6:	3b01      	subs	r3, #1
341877f8:	041b      	lsls	r3, r3, #16
341877fa:	4313      	orrs	r3, r2
341877fc:	4a24      	ldr	r2, [pc, #144]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
341877fe:	430b      	orrs	r3, r1
34187800:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
                 PeriphClkInit->ICSelection[RCC_IC16].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC16].ClockDivider - 1U) << RCC_IC16CFGR_IC16INT_Pos));

      LL_RCC_IC16_Enable();
34187804:	f7fe fdd4 	bl	341863b0 <LL_RCC_IC16_Enable>
34187808:	e008      	b.n	3418781c <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    }
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
3418780a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418780e:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34187812:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34187816:	d101      	bne.n	3418781c <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    {
      LL_RCC_CLKP_Enable();
34187818:	f7fe fe10 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LTDC clock */
    __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
3418781c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187820:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34187824:	4618      	mov	r0, r3
34187826:	f7fe f9d3 	bl	34185bd0 <LL_RCC_SetLTDCClockSource>
  }

  /*---------------------------- MDF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
3418782a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418782e:	e9d3 2300 	ldrd	r2, r3, [r3]
34187832:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
34187836:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
3418783a:	2300      	movs	r3, #0
3418783c:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
34187840:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
34187844:	4603      	mov	r3, r0
34187846:	460a      	mov	r2, r1
34187848:	4313      	orrs	r3, r2
3418784a:	d05b      	beq.n	34187904 <HAL_RCCEx_PeriphCLKConfig+0x14ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));

    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
3418784c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187850:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34187854:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34187858:	d126      	bne.n	341878a8 <HAL_RCCEx_PeriphCLKConfig+0x1450>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418785a:	4b0d      	ldr	r3, [pc, #52]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418785c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34187860:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187864:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187868:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418786c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418786e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187872:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34187874:	3b01      	subs	r3, #1
34187876:	041b      	lsls	r3, r3, #16
34187878:	4313      	orrs	r3, r2
3418787a:	4a05      	ldr	r2, [pc, #20]	@ (34187890 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418787c:	430b      	orrs	r3, r1
3418787e:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34187882:	f7fe fd25 	bl	341862d0 <LL_RCC_IC7_Enable>
34187886:	e036      	b.n	341878f6 <HAL_RCCEx_PeriphCLKConfig+0x149e>
34187888:	07010c2c 	.word	0x07010c2c
3418788c:	0702102c 	.word	0x0702102c
34187890:	56028000 	.word	0x56028000
34187894:	0701102c 	.word	0x0701102c
34187898:	0702142c 	.word	0x0702142c
3418789c:	0701142c 	.word	0x0701142c
341878a0:	0702182c 	.word	0x0702182c
341878a4:	0701182c 	.word	0x0701182c
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
341878a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341878ac:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
341878b0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
341878b4:	d116      	bne.n	341878e4 <HAL_RCCEx_PeriphCLKConfig+0x148c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
341878b6:	4bb5      	ldr	r3, [pc, #724]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
341878b8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
341878bc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341878c0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341878c4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341878c8:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
341878ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341878ce:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341878d0:	3b01      	subs	r3, #1
341878d2:	041b      	lsls	r3, r3, #16
341878d4:	4313      	orrs	r3, r2
341878d6:	4aad      	ldr	r2, [pc, #692]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
341878d8:	430b      	orrs	r3, r1
341878da:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
341878de:	f7fe fd05 	bl	341862ec <LL_RCC_IC8_Enable>
341878e2:	e008      	b.n	341878f6 <HAL_RCCEx_PeriphCLKConfig+0x149e>
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
341878e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341878e8:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
341878ec:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
341878f0:	d101      	bne.n	341878f6 <HAL_RCCEx_PeriphCLKConfig+0x149e>
    {
      LL_RCC_CLKP_Enable();
341878f2:	f7fe fda3 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of MDF1 clock*/
    __HAL_RCC_MDF1_CONFIG(PeriphClkInit->Mdf1ClockSelection);
341878f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341878fa:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
341878fe:	4618      	mov	r0, r3
34187900:	f7fe f97c 	bl	34185bfc <LL_RCC_SetMDFClockSource>
  }

  /*---------------------------- PSSI configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
34187904:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187908:	e9d3 2300 	ldrd	r2, r3, [r3]
3418790c:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
34187910:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
34187914:	2300      	movs	r3, #0
34187916:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
3418791a:	e9d7 0130 	ldrd	r0, r1, [r7, #192]	@ 0xc0
3418791e:	4603      	mov	r3, r0
34187920:	460a      	mov	r2, r1
34187922:	4313      	orrs	r3, r2
34187924:	d02d      	beq.n	34187982 <HAL_RCCEx_PeriphCLKConfig+0x152a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));

    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
34187926:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418792a:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3418792e:	2b20      	cmp	r3, #32
34187930:	d118      	bne.n	34187964 <HAL_RCCEx_PeriphCLKConfig+0x150c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
34187932:	4b96      	ldr	r3, [pc, #600]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34187934:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34187938:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418793c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187940:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187944:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34187948:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418794c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34187950:	3b01      	subs	r3, #1
34187952:	041b      	lsls	r3, r3, #16
34187954:	4313      	orrs	r3, r2
34187956:	4a8d      	ldr	r2, [pc, #564]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34187958:	430b      	orrs	r3, r1
3418795a:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
3418795e:	f7fe fd5f 	bl	34186420 <LL_RCC_IC20_Enable>
34187962:	e007      	b.n	34187974 <HAL_RCCEx_PeriphCLKConfig+0x151c>
    }
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
34187964:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187968:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3418796c:	2b10      	cmp	r3, #16
3418796e:	d101      	bne.n	34187974 <HAL_RCCEx_PeriphCLKConfig+0x151c>
    {
      LL_RCC_CLKP_Enable();
34187970:	f7fe fd64 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of PSSI clock*/
    __HAL_RCC_PSSI_CONFIG(PeriphClkInit->PssiClockSelection);
34187974:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187978:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3418797c:	4618      	mov	r0, r3
3418797e:	f7fe f969 	bl	34185c54 <LL_RCC_SetPSSIClockSource>
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
34187982:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187986:	e9d3 2300 	ldrd	r2, r3, [r3]
3418798a:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
3418798e:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
34187992:	2300      	movs	r3, #0
34187994:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
34187998:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
3418799c:	4603      	mov	r3, r0
3418799e:	460a      	mov	r2, r1
341879a0:	4313      	orrs	r3, r2
341879a2:	d04b      	beq.n	34187a3c <HAL_RCCEx_PeriphCLKConfig+0x15e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
341879a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341879a8:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
341879ac:	4b78      	ldr	r3, [pc, #480]	@ (34187b90 <HAL_RCCEx_PeriphCLKConfig+0x1738>)
341879ae:	429a      	cmp	r2, r3
341879b0:	d116      	bne.n	341879e0 <HAL_RCCEx_PeriphCLKConfig+0x1588>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
341879b2:	4b76      	ldr	r3, [pc, #472]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
341879b4:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
341879b8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341879bc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341879c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341879c4:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
341879c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341879ca:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
341879cc:	3b01      	subs	r3, #1
341879ce:	041b      	lsls	r3, r3, #16
341879d0:	4313      	orrs	r3, r2
341879d2:	4a6e      	ldr	r2, [pc, #440]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
341879d4:	430b      	orrs	r3, r1
341879d6:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
341879da:	f7fe fc79 	bl	341862d0 <LL_RCC_IC7_Enable>
341879de:	e026      	b.n	34187a2e <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
341879e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341879e4:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
341879e8:	4b6a      	ldr	r3, [pc, #424]	@ (34187b94 <HAL_RCCEx_PeriphCLKConfig+0x173c>)
341879ea:	429a      	cmp	r2, r3
341879ec:	d116      	bne.n	34187a1c <HAL_RCCEx_PeriphCLKConfig+0x15c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
341879ee:	4b67      	ldr	r3, [pc, #412]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
341879f0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
341879f4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341879f8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341879fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187a00:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34187a02:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187a06:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34187a08:	3b01      	subs	r3, #1
34187a0a:	041b      	lsls	r3, r3, #16
34187a0c:	4313      	orrs	r3, r2
34187a0e:	4a5f      	ldr	r2, [pc, #380]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34187a10:	430b      	orrs	r3, r1
34187a12:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34187a16:	f7fe fc69 	bl	341862ec <LL_RCC_IC8_Enable>
34187a1a:	e008      	b.n	34187a2e <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
34187a1c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187a20:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34187a24:	4b5c      	ldr	r3, [pc, #368]	@ (34187b98 <HAL_RCCEx_PeriphCLKConfig+0x1740>)
34187a26:	429a      	cmp	r2, r3
34187a28:	d101      	bne.n	34187a2e <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    {
      LL_RCC_CLKP_Enable();
34187a2a:	f7fe fd07 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI1 clock*/
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
34187a2e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187a32:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
34187a36:	4618      	mov	r0, r3
34187a38:	f7fe f922 	bl	34185c80 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
34187a3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187a40:	e9d3 2300 	ldrd	r2, r3, [r3]
34187a44:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
34187a48:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
34187a4c:	2300      	movs	r3, #0
34187a4e:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
34187a52:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
34187a56:	4603      	mov	r3, r0
34187a58:	460a      	mov	r2, r1
34187a5a:	4313      	orrs	r3, r2
34187a5c:	d04b      	beq.n	34187af6 <HAL_RCCEx_PeriphCLKConfig+0x169e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
34187a5e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187a62:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34187a66:	4b4d      	ldr	r3, [pc, #308]	@ (34187b9c <HAL_RCCEx_PeriphCLKConfig+0x1744>)
34187a68:	429a      	cmp	r2, r3
34187a6a:	d116      	bne.n	34187a9a <HAL_RCCEx_PeriphCLKConfig+0x1642>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34187a6c:	4b47      	ldr	r3, [pc, #284]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34187a6e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34187a72:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187a76:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187a7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187a7e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34187a80:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187a84:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34187a86:	3b01      	subs	r3, #1
34187a88:	041b      	lsls	r3, r3, #16
34187a8a:	4313      	orrs	r3, r2
34187a8c:	4a3f      	ldr	r2, [pc, #252]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34187a8e:	430b      	orrs	r3, r1
34187a90:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34187a94:	f7fe fc1c 	bl	341862d0 <LL_RCC_IC7_Enable>
34187a98:	e026      	b.n	34187ae8 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
34187a9a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187a9e:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34187aa2:	4b3f      	ldr	r3, [pc, #252]	@ (34187ba0 <HAL_RCCEx_PeriphCLKConfig+0x1748>)
34187aa4:	429a      	cmp	r2, r3
34187aa6:	d116      	bne.n	34187ad6 <HAL_RCCEx_PeriphCLKConfig+0x167e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34187aa8:	4b38      	ldr	r3, [pc, #224]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34187aaa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34187aae:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187ab2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187ab6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187aba:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34187abc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187ac0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34187ac2:	3b01      	subs	r3, #1
34187ac4:	041b      	lsls	r3, r3, #16
34187ac6:	4313      	orrs	r3, r2
34187ac8:	4a30      	ldr	r2, [pc, #192]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34187aca:	430b      	orrs	r3, r1
34187acc:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34187ad0:	f7fe fc0c 	bl	341862ec <LL_RCC_IC8_Enable>
34187ad4:	e008      	b.n	34187ae8 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
34187ad6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187ada:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34187ade:	4b31      	ldr	r3, [pc, #196]	@ (34187ba4 <HAL_RCCEx_PeriphCLKConfig+0x174c>)
34187ae0:	429a      	cmp	r2, r3
34187ae2:	d101      	bne.n	34187ae8 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    {
      LL_RCC_CLKP_Enable();
34187ae4:	f7fe fcaa 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI2 clock*/
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
34187ae8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187aec:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
34187af0:	4618      	mov	r0, r3
34187af2:	f7fe f8c5 	bl	34185c80 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SPDIFRX1 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
34187af6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187afa:	e9d3 2300 	ldrd	r2, r3, [r3]
34187afe:	2100      	movs	r1, #0
34187b00:	f8c7 10a8 	str.w	r1, [r7, #168]	@ 0xa8
34187b04:	f003 0301 	and.w	r3, r3, #1
34187b08:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
34187b0c:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
34187b10:	4603      	mov	r3, r0
34187b12:	460a      	mov	r2, r1
34187b14:	4313      	orrs	r3, r2
34187b16:	d056      	beq.n	34187bc6 <HAL_RCCEx_PeriphCLKConfig+0x176e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));

    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
34187b18:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187b1c:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34187b20:	2b02      	cmp	r3, #2
34187b22:	d116      	bne.n	34187b52 <HAL_RCCEx_PeriphCLKConfig+0x16fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34187b24:	4b19      	ldr	r3, [pc, #100]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34187b26:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34187b2a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187b2e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187b32:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187b36:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34187b38:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187b3c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34187b3e:	3b01      	subs	r3, #1
34187b40:	041b      	lsls	r3, r3, #16
34187b42:	4313      	orrs	r3, r2
34187b44:	4a11      	ldr	r2, [pc, #68]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34187b46:	430b      	orrs	r3, r1
34187b48:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34187b4c:	f7fe fbc0 	bl	341862d0 <LL_RCC_IC7_Enable>
34187b50:	e032      	b.n	34187bb8 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
34187b52:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187b56:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34187b5a:	2b03      	cmp	r3, #3
34187b5c:	d124      	bne.n	34187ba8 <HAL_RCCEx_PeriphCLKConfig+0x1750>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34187b5e:	4b0b      	ldr	r3, [pc, #44]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34187b60:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34187b64:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187b68:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187b6c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187b70:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34187b72:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187b76:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34187b78:	3b01      	subs	r3, #1
34187b7a:	041b      	lsls	r3, r3, #16
34187b7c:	4313      	orrs	r3, r2
34187b7e:	4a03      	ldr	r2, [pc, #12]	@ (34187b8c <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34187b80:	430b      	orrs	r3, r1
34187b82:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34187b86:	f7fe fbb1 	bl	341862ec <LL_RCC_IC8_Enable>
34187b8a:	e015      	b.n	34187bb8 <HAL_RCCEx_PeriphCLKConfig+0x1760>
34187b8c:	56028000 	.word	0x56028000
34187b90:	07021418 	.word	0x07021418
34187b94:	07031418 	.word	0x07031418
34187b98:	07011418 	.word	0x07011418
34187b9c:	07021818 	.word	0x07021818
34187ba0:	07031818 	.word	0x07031818
34187ba4:	07011818 	.word	0x07011818
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
34187ba8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187bac:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34187bb0:	2b01      	cmp	r3, #1
34187bb2:	d101      	bne.n	34187bb8 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    {
      LL_RCC_CLKP_Enable();
34187bb4:	f7fe fc42 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPDIFRX1 clock */
    __HAL_RCC_SPDIFRX1_CONFIG(PeriphClkInit->Spdifrx1ClockSelection);
34187bb8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187bbc:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34187bc0:	4618      	mov	r0, r3
34187bc2:	f7fe f873 	bl	34185cac <LL_RCC_SetSPDIFRXClockSource>
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
34187bc6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187bca:	e9d3 2300 	ldrd	r2, r3, [r3]
34187bce:	2100      	movs	r1, #0
34187bd0:	f8c7 10a0 	str.w	r1, [r7, #160]	@ 0xa0
34187bd4:	f003 0302 	and.w	r3, r3, #2
34187bd8:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
34187bdc:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
34187be0:	4603      	mov	r3, r0
34187be2:	460a      	mov	r2, r1
34187be4:	4313      	orrs	r3, r2
34187be6:	d04b      	beq.n	34187c80 <HAL_RCCEx_PeriphCLKConfig+0x1828>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));

    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
34187be8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187bec:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34187bf0:	4bc6      	ldr	r3, [pc, #792]	@ (34187f0c <HAL_RCCEx_PeriphCLKConfig+0x1ab4>)
34187bf2:	429a      	cmp	r2, r3
34187bf4:	d116      	bne.n	34187c24 <HAL_RCCEx_PeriphCLKConfig+0x17cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34187bf6:	4bc6      	ldr	r3, [pc, #792]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187bf8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34187bfc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187c00:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187c04:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187c08:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34187c0a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187c0e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34187c10:	3b01      	subs	r3, #1
34187c12:	041b      	lsls	r3, r3, #16
34187c14:	4313      	orrs	r3, r2
34187c16:	4abe      	ldr	r2, [pc, #760]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187c18:	430b      	orrs	r3, r1
34187c1a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34187c1e:	f7fe fb65 	bl	341862ec <LL_RCC_IC8_Enable>
34187c22:	e026      	b.n	34187c72 <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
34187c24:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187c28:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34187c2c:	4bb9      	ldr	r3, [pc, #740]	@ (34187f14 <HAL_RCCEx_PeriphCLKConfig+0x1abc>)
34187c2e:	429a      	cmp	r2, r3
34187c30:	d116      	bne.n	34187c60 <HAL_RCCEx_PeriphCLKConfig+0x1808>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34187c32:	4bb7      	ldr	r3, [pc, #732]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187c34:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34187c38:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187c3c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187c40:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187c44:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34187c46:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187c4a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34187c4c:	3b01      	subs	r3, #1
34187c4e:	041b      	lsls	r3, r3, #16
34187c50:	4313      	orrs	r3, r2
34187c52:	4aaf      	ldr	r2, [pc, #700]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187c54:	430b      	orrs	r3, r1
34187c56:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34187c5a:	f7fe fb55 	bl	34186308 <LL_RCC_IC9_Enable>
34187c5e:	e008      	b.n	34187c72 <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
34187c60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187c64:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34187c68:	4bab      	ldr	r3, [pc, #684]	@ (34187f18 <HAL_RCCEx_PeriphCLKConfig+0x1ac0>)
34187c6a:	429a      	cmp	r2, r3
34187c6c:	d101      	bne.n	34187c72 <HAL_RCCEx_PeriphCLKConfig+0x181a>
    {
      LL_RCC_CLKP_Enable();
34187c6e:	f7fe fbe5 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI1 clock*/
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
34187c72:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187c76:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
34187c7a:	4618      	mov	r0, r3
34187c7c:	f7fe f82c 	bl	34185cd8 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI2 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
34187c80:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187c84:	e9d3 2300 	ldrd	r2, r3, [r3]
34187c88:	2100      	movs	r1, #0
34187c8a:	f8c7 1098 	str.w	r1, [r7, #152]	@ 0x98
34187c8e:	f003 0304 	and.w	r3, r3, #4
34187c92:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
34187c96:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
34187c9a:	4603      	mov	r3, r0
34187c9c:	460a      	mov	r2, r1
34187c9e:	4313      	orrs	r3, r2
34187ca0:	d04b      	beq.n	34187d3a <HAL_RCCEx_PeriphCLKConfig+0x18e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));

    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
34187ca2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187ca6:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34187caa:	4b9c      	ldr	r3, [pc, #624]	@ (34187f1c <HAL_RCCEx_PeriphCLKConfig+0x1ac4>)
34187cac:	429a      	cmp	r2, r3
34187cae:	d116      	bne.n	34187cde <HAL_RCCEx_PeriphCLKConfig+0x1886>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34187cb0:	4b97      	ldr	r3, [pc, #604]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187cb2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34187cb6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187cba:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187cbe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187cc2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34187cc4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187cc8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34187cca:	3b01      	subs	r3, #1
34187ccc:	041b      	lsls	r3, r3, #16
34187cce:	4313      	orrs	r3, r2
34187cd0:	4a8f      	ldr	r2, [pc, #572]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187cd2:	430b      	orrs	r3, r1
34187cd4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34187cd8:	f7fe fb08 	bl	341862ec <LL_RCC_IC8_Enable>
34187cdc:	e026      	b.n	34187d2c <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
34187cde:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187ce2:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34187ce6:	4b8e      	ldr	r3, [pc, #568]	@ (34187f20 <HAL_RCCEx_PeriphCLKConfig+0x1ac8>)
34187ce8:	429a      	cmp	r2, r3
34187cea:	d116      	bne.n	34187d1a <HAL_RCCEx_PeriphCLKConfig+0x18c2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34187cec:	4b88      	ldr	r3, [pc, #544]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187cee:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34187cf2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187cf6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187cfa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187cfe:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34187d00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187d04:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34187d06:	3b01      	subs	r3, #1
34187d08:	041b      	lsls	r3, r3, #16
34187d0a:	4313      	orrs	r3, r2
34187d0c:	4a80      	ldr	r2, [pc, #512]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187d0e:	430b      	orrs	r3, r1
34187d10:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34187d14:	f7fe faf8 	bl	34186308 <LL_RCC_IC9_Enable>
34187d18:	e008      	b.n	34187d2c <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
34187d1a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187d1e:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34187d22:	4b80      	ldr	r3, [pc, #512]	@ (34187f24 <HAL_RCCEx_PeriphCLKConfig+0x1acc>)
34187d24:	429a      	cmp	r2, r3
34187d26:	d101      	bne.n	34187d2c <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    {
      LL_RCC_CLKP_Enable();
34187d28:	f7fe fb88 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI2 clock*/
    __HAL_RCC_SPI2_CONFIG(PeriphClkInit->Spi2ClockSelection);
34187d2c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187d30:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
34187d34:	4618      	mov	r0, r3
34187d36:	f7fd ffcf 	bl	34185cd8 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI3 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
34187d3a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187d3e:	e9d3 2300 	ldrd	r2, r3, [r3]
34187d42:	2100      	movs	r1, #0
34187d44:	f8c7 1090 	str.w	r1, [r7, #144]	@ 0x90
34187d48:	f003 0308 	and.w	r3, r3, #8
34187d4c:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
34187d50:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
34187d54:	4603      	mov	r3, r0
34187d56:	460a      	mov	r2, r1
34187d58:	4313      	orrs	r3, r2
34187d5a:	d04b      	beq.n	34187df4 <HAL_RCCEx_PeriphCLKConfig+0x199c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));

    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
34187d5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187d60:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34187d64:	4b70      	ldr	r3, [pc, #448]	@ (34187f28 <HAL_RCCEx_PeriphCLKConfig+0x1ad0>)
34187d66:	429a      	cmp	r2, r3
34187d68:	d116      	bne.n	34187d98 <HAL_RCCEx_PeriphCLKConfig+0x1940>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34187d6a:	4b69      	ldr	r3, [pc, #420]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187d6c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34187d70:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187d74:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187d78:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187d7c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34187d7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187d82:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34187d84:	3b01      	subs	r3, #1
34187d86:	041b      	lsls	r3, r3, #16
34187d88:	4313      	orrs	r3, r2
34187d8a:	4a61      	ldr	r2, [pc, #388]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187d8c:	430b      	orrs	r3, r1
34187d8e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34187d92:	f7fe faab 	bl	341862ec <LL_RCC_IC8_Enable>
34187d96:	e026      	b.n	34187de6 <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
34187d98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187d9c:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34187da0:	4b62      	ldr	r3, [pc, #392]	@ (34187f2c <HAL_RCCEx_PeriphCLKConfig+0x1ad4>)
34187da2:	429a      	cmp	r2, r3
34187da4:	d116      	bne.n	34187dd4 <HAL_RCCEx_PeriphCLKConfig+0x197c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34187da6:	4b5a      	ldr	r3, [pc, #360]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187da8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34187dac:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187db0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187db4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187db8:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34187dba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187dbe:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34187dc0:	3b01      	subs	r3, #1
34187dc2:	041b      	lsls	r3, r3, #16
34187dc4:	4313      	orrs	r3, r2
34187dc6:	4a52      	ldr	r2, [pc, #328]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187dc8:	430b      	orrs	r3, r1
34187dca:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34187dce:	f7fe fa9b 	bl	34186308 <LL_RCC_IC9_Enable>
34187dd2:	e008      	b.n	34187de6 <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
34187dd4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187dd8:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34187ddc:	4b54      	ldr	r3, [pc, #336]	@ (34187f30 <HAL_RCCEx_PeriphCLKConfig+0x1ad8>)
34187dde:	429a      	cmp	r2, r3
34187de0:	d101      	bne.n	34187de6 <HAL_RCCEx_PeriphCLKConfig+0x198e>
    {
      LL_RCC_CLKP_Enable();
34187de2:	f7fe fb2b 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI3 clock*/
    __HAL_RCC_SPI3_CONFIG(PeriphClkInit->Spi3ClockSelection);
34187de6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187dea:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
34187dee:	4618      	mov	r0, r3
34187df0:	f7fd ff72 	bl	34185cd8 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI4 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
34187df4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187df8:	e9d3 2300 	ldrd	r2, r3, [r3]
34187dfc:	2100      	movs	r1, #0
34187dfe:	f8c7 1088 	str.w	r1, [r7, #136]	@ 0x88
34187e02:	f003 0310 	and.w	r3, r3, #16
34187e06:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
34187e0a:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
34187e0e:	4603      	mov	r3, r0
34187e10:	460a      	mov	r2, r1
34187e12:	4313      	orrs	r3, r2
34187e14:	d04b      	beq.n	34187eae <HAL_RCCEx_PeriphCLKConfig+0x1a56>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));

    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
34187e16:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187e1a:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34187e1e:	4b45      	ldr	r3, [pc, #276]	@ (34187f34 <HAL_RCCEx_PeriphCLKConfig+0x1adc>)
34187e20:	429a      	cmp	r2, r3
34187e22:	d116      	bne.n	34187e52 <HAL_RCCEx_PeriphCLKConfig+0x19fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34187e24:	4b3a      	ldr	r3, [pc, #232]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187e26:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34187e2a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187e2e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187e32:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187e36:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34187e38:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187e3c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34187e3e:	3b01      	subs	r3, #1
34187e40:	041b      	lsls	r3, r3, #16
34187e42:	4313      	orrs	r3, r2
34187e44:	4a32      	ldr	r2, [pc, #200]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187e46:	430b      	orrs	r3, r1
34187e48:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34187e4c:	f7fe fa5c 	bl	34186308 <LL_RCC_IC9_Enable>
34187e50:	e026      	b.n	34187ea0 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
34187e52:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187e56:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34187e5a:	4b37      	ldr	r3, [pc, #220]	@ (34187f38 <HAL_RCCEx_PeriphCLKConfig+0x1ae0>)
34187e5c:	429a      	cmp	r2, r3
34187e5e:	d116      	bne.n	34187e8e <HAL_RCCEx_PeriphCLKConfig+0x1a36>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34187e60:	4b2b      	ldr	r3, [pc, #172]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187e62:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34187e66:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187e6a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187e6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187e72:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34187e74:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187e78:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34187e7a:	3b01      	subs	r3, #1
34187e7c:	041b      	lsls	r3, r3, #16
34187e7e:	4313      	orrs	r3, r2
34187e80:	4a23      	ldr	r2, [pc, #140]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187e82:	430b      	orrs	r3, r1
34187e84:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34187e88:	f7fe fa76 	bl	34186378 <LL_RCC_IC14_Enable>
34187e8c:	e008      	b.n	34187ea0 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
34187e8e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187e92:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34187e96:	4b29      	ldr	r3, [pc, #164]	@ (34187f3c <HAL_RCCEx_PeriphCLKConfig+0x1ae4>)
34187e98:	429a      	cmp	r2, r3
34187e9a:	d101      	bne.n	34187ea0 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    {
      LL_RCC_CLKP_Enable();
34187e9c:	f7fe face 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI4 clock */
    __HAL_RCC_SPI4_CONFIG(PeriphClkInit->Spi4ClockSelection);
34187ea0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187ea4:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
34187ea8:	4618      	mov	r0, r3
34187eaa:	f7fd ff15 	bl	34185cd8 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI5 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
34187eae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187eb2:	e9d3 2300 	ldrd	r2, r3, [r3]
34187eb6:	2100      	movs	r1, #0
34187eb8:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
34187ebc:	f003 0320 	and.w	r3, r3, #32
34187ec0:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
34187ec4:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
34187ec8:	4603      	mov	r3, r0
34187eca:	460a      	mov	r2, r1
34187ecc:	4313      	orrs	r3, r2
34187ece:	d067      	beq.n	34187fa0 <HAL_RCCEx_PeriphCLKConfig+0x1b48>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));

    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
34187ed0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187ed4:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34187ed8:	4b19      	ldr	r3, [pc, #100]	@ (34187f40 <HAL_RCCEx_PeriphCLKConfig+0x1ae8>)
34187eda:	429a      	cmp	r2, r3
34187edc:	d132      	bne.n	34187f44 <HAL_RCCEx_PeriphCLKConfig+0x1aec>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34187ede:	4b0c      	ldr	r3, [pc, #48]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187ee0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34187ee4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187ee8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187eec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187ef0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34187ef2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187ef6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34187ef8:	3b01      	subs	r3, #1
34187efa:	041b      	lsls	r3, r3, #16
34187efc:	4313      	orrs	r3, r2
34187efe:	4a04      	ldr	r2, [pc, #16]	@ (34187f10 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34187f00:	430b      	orrs	r3, r1
34187f02:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34187f06:	f7fe f9ff 	bl	34186308 <LL_RCC_IC9_Enable>
34187f0a:	e042      	b.n	34187f92 <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
34187f0c:	07020420 	.word	0x07020420
34187f10:	56028000 	.word	0x56028000
34187f14:	07030420 	.word	0x07030420
34187f18:	07010420 	.word	0x07010420
34187f1c:	07020820 	.word	0x07020820
34187f20:	07030820 	.word	0x07030820
34187f24:	07010820 	.word	0x07010820
34187f28:	07020c20 	.word	0x07020c20
34187f2c:	07030c20 	.word	0x07030c20
34187f30:	07010c20 	.word	0x07010c20
34187f34:	07021020 	.word	0x07021020
34187f38:	07031020 	.word	0x07031020
34187f3c:	07011020 	.word	0x07011020
34187f40:	07021420 	.word	0x07021420
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
34187f44:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187f48:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34187f4c:	4bc2      	ldr	r3, [pc, #776]	@ (34188258 <HAL_RCCEx_PeriphCLKConfig+0x1e00>)
34187f4e:	429a      	cmp	r2, r3
34187f50:	d116      	bne.n	34187f80 <HAL_RCCEx_PeriphCLKConfig+0x1b28>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34187f52:	4bc2      	ldr	r3, [pc, #776]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34187f54:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34187f58:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187f5c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187f60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187f64:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34187f66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187f6a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34187f6c:	3b01      	subs	r3, #1
34187f6e:	041b      	lsls	r3, r3, #16
34187f70:	4313      	orrs	r3, r2
34187f72:	4aba      	ldr	r2, [pc, #744]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34187f74:	430b      	orrs	r3, r1
34187f76:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34187f7a:	f7fe f9fd 	bl	34186378 <LL_RCC_IC14_Enable>
34187f7e:	e008      	b.n	34187f92 <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
34187f80:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187f84:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34187f88:	4bb5      	ldr	r3, [pc, #724]	@ (34188260 <HAL_RCCEx_PeriphCLKConfig+0x1e08>)
34187f8a:	429a      	cmp	r2, r3
34187f8c:	d101      	bne.n	34187f92 <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    {
      LL_RCC_CLKP_Enable();
34187f8e:	f7fe fa55 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI5 clock */
    __HAL_RCC_SPI5_CONFIG(PeriphClkInit->Spi5ClockSelection);
34187f92:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187f96:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34187f9a:	4618      	mov	r0, r3
34187f9c:	f7fd fe9c 	bl	34185cd8 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
34187fa0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187fa4:	e9d3 2300 	ldrd	r2, r3, [r3]
34187fa8:	2100      	movs	r1, #0
34187faa:	67b9      	str	r1, [r7, #120]	@ 0x78
34187fac:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34187fb0:	67fb      	str	r3, [r7, #124]	@ 0x7c
34187fb2:	e9d7 011e 	ldrd	r0, r1, [r7, #120]	@ 0x78
34187fb6:	4603      	mov	r3, r0
34187fb8:	460a      	mov	r2, r1
34187fba:	4313      	orrs	r3, r2
34187fbc:	d04b      	beq.n	34188056 <HAL_RCCEx_PeriphCLKConfig+0x1bfe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));

    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
34187fbe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187fc2:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
34187fc6:	4ba7      	ldr	r3, [pc, #668]	@ (34188264 <HAL_RCCEx_PeriphCLKConfig+0x1e0c>)
34187fc8:	429a      	cmp	r2, r3
34187fca:	d116      	bne.n	34187ffa <HAL_RCCEx_PeriphCLKConfig+0x1ba2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34187fcc:	4ba3      	ldr	r3, [pc, #652]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34187fce:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34187fd2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34187fd6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34187fda:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187fde:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34187fe0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187fe4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34187fe6:	3b01      	subs	r3, #1
34187fe8:	041b      	lsls	r3, r3, #16
34187fea:	4313      	orrs	r3, r2
34187fec:	4a9b      	ldr	r2, [pc, #620]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34187fee:	430b      	orrs	r3, r1
34187ff0:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34187ff4:	f7fe f97a 	bl	341862ec <LL_RCC_IC8_Enable>
34187ff8:	e026      	b.n	34188048 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
34187ffa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34187ffe:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
34188002:	4b99      	ldr	r3, [pc, #612]	@ (34188268 <HAL_RCCEx_PeriphCLKConfig+0x1e10>)
34188004:	429a      	cmp	r2, r3
34188006:	d116      	bne.n	34188036 <HAL_RCCEx_PeriphCLKConfig+0x1bde>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34188008:	4b94      	ldr	r3, [pc, #592]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3418800a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418800e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34188012:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34188016:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418801a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3418801c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188020:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34188022:	3b01      	subs	r3, #1
34188024:	041b      	lsls	r3, r3, #16
34188026:	4313      	orrs	r3, r2
34188028:	4a8c      	ldr	r2, [pc, #560]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3418802a:	430b      	orrs	r3, r1
3418802c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34188030:	f7fe f96a 	bl	34186308 <LL_RCC_IC9_Enable>
34188034:	e008      	b.n	34188048 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
34188036:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418803a:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3418803e:	4b8b      	ldr	r3, [pc, #556]	@ (3418826c <HAL_RCCEx_PeriphCLKConfig+0x1e14>)
34188040:	429a      	cmp	r2, r3
34188042:	d101      	bne.n	34188048 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    {
      LL_RCC_CLKP_Enable();
34188044:	f7fe f9fa 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI6 clock*/
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
34188048:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418804c:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34188050:	4618      	mov	r0, r3
34188052:	f7fd fe41 	bl	34185cd8 <LL_RCC_SetSPIClockSource>
  }

  /*-------------------------- USART1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
34188056:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418805a:	e9d3 2300 	ldrd	r2, r3, [r3]
3418805e:	2100      	movs	r1, #0
34188060:	6739      	str	r1, [r7, #112]	@ 0x70
34188062:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34188066:	677b      	str	r3, [r7, #116]	@ 0x74
34188068:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
3418806c:	4603      	mov	r3, r0
3418806e:	460a      	mov	r2, r1
34188070:	4313      	orrs	r3, r2
34188072:	d04b      	beq.n	3418810c <HAL_RCCEx_PeriphCLKConfig+0x1cb4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
34188074:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188078:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3418807c:	4b7c      	ldr	r3, [pc, #496]	@ (34188270 <HAL_RCCEx_PeriphCLKConfig+0x1e18>)
3418807e:	429a      	cmp	r2, r3
34188080:	d116      	bne.n	341880b0 <HAL_RCCEx_PeriphCLKConfig+0x1c58>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34188082:	4b76      	ldr	r3, [pc, #472]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34188084:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34188088:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418808c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34188090:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188094:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34188096:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418809a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3418809c:	3b01      	subs	r3, #1
3418809e:	041b      	lsls	r3, r3, #16
341880a0:	4313      	orrs	r3, r2
341880a2:	4a6e      	ldr	r2, [pc, #440]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341880a4:	430b      	orrs	r3, r1
341880a6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341880aa:	f7fe f92d 	bl	34186308 <LL_RCC_IC9_Enable>
341880ae:	e026      	b.n	341880fe <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
341880b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341880b4:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
341880b8:	4b6e      	ldr	r3, [pc, #440]	@ (34188274 <HAL_RCCEx_PeriphCLKConfig+0x1e1c>)
341880ba:	429a      	cmp	r2, r3
341880bc:	d116      	bne.n	341880ec <HAL_RCCEx_PeriphCLKConfig+0x1c94>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341880be:	4b67      	ldr	r3, [pc, #412]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341880c0:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341880c4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341880c8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341880cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341880d0:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341880d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341880d6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341880d8:	3b01      	subs	r3, #1
341880da:	041b      	lsls	r3, r3, #16
341880dc:	4313      	orrs	r3, r2
341880de:	4a5f      	ldr	r2, [pc, #380]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341880e0:	430b      	orrs	r3, r1
341880e2:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341880e6:	f7fe f947 	bl	34186378 <LL_RCC_IC14_Enable>
341880ea:	e008      	b.n	341880fe <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
341880ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341880f0:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
341880f4:	4b60      	ldr	r3, [pc, #384]	@ (34188278 <HAL_RCCEx_PeriphCLKConfig+0x1e20>)
341880f6:	429a      	cmp	r2, r3
341880f8:	d101      	bne.n	341880fe <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    {
      LL_RCC_CLKP_Enable();
341880fa:	f7fe f99f 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART1 clock */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
341880fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188102:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
34188106:	4618      	mov	r0, r3
34188108:	f7fd fdf1 	bl	34185cee <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
3418810c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188110:	e9d3 2300 	ldrd	r2, r3, [r3]
34188114:	2100      	movs	r1, #0
34188116:	66b9      	str	r1, [r7, #104]	@ 0x68
34188118:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418811c:	66fb      	str	r3, [r7, #108]	@ 0x6c
3418811e:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
34188122:	4603      	mov	r3, r0
34188124:	460a      	mov	r2, r1
34188126:	4313      	orrs	r3, r2
34188128:	d04b      	beq.n	341881c2 <HAL_RCCEx_PeriphCLKConfig+0x1d6a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
3418812a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418812e:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34188132:	4b52      	ldr	r3, [pc, #328]	@ (3418827c <HAL_RCCEx_PeriphCLKConfig+0x1e24>)
34188134:	429a      	cmp	r2, r3
34188136:	d116      	bne.n	34188166 <HAL_RCCEx_PeriphCLKConfig+0x1d0e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34188138:	4b48      	ldr	r3, [pc, #288]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3418813a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418813e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34188142:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34188146:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418814a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3418814c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188150:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34188152:	3b01      	subs	r3, #1
34188154:	041b      	lsls	r3, r3, #16
34188156:	4313      	orrs	r3, r2
34188158:	4a40      	ldr	r2, [pc, #256]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3418815a:	430b      	orrs	r3, r1
3418815c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34188160:	f7fe f8d2 	bl	34186308 <LL_RCC_IC9_Enable>
34188164:	e026      	b.n	341881b4 <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
34188166:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418816a:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3418816e:	4b44      	ldr	r3, [pc, #272]	@ (34188280 <HAL_RCCEx_PeriphCLKConfig+0x1e28>)
34188170:	429a      	cmp	r2, r3
34188172:	d116      	bne.n	341881a2 <HAL_RCCEx_PeriphCLKConfig+0x1d4a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34188174:	4b39      	ldr	r3, [pc, #228]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34188176:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418817a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418817e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34188182:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188186:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34188188:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418818c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3418818e:	3b01      	subs	r3, #1
34188190:	041b      	lsls	r3, r3, #16
34188192:	4313      	orrs	r3, r2
34188194:	4a31      	ldr	r2, [pc, #196]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34188196:	430b      	orrs	r3, r1
34188198:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3418819c:	f7fe f8ec 	bl	34186378 <LL_RCC_IC14_Enable>
341881a0:	e008      	b.n	341881b4 <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
341881a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341881a6:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
341881aa:	4b36      	ldr	r3, [pc, #216]	@ (34188284 <HAL_RCCEx_PeriphCLKConfig+0x1e2c>)
341881ac:	429a      	cmp	r2, r3
341881ae:	d101      	bne.n	341881b4 <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    {
      LL_RCC_CLKP_Enable();
341881b0:	f7fe f944 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART2 clock */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
341881b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341881b8:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
341881bc:	4618      	mov	r0, r3
341881be:	f7fd fd96 	bl	34185cee <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART3 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
341881c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341881c6:	e9d3 2300 	ldrd	r2, r3, [r3]
341881ca:	2100      	movs	r1, #0
341881cc:	6639      	str	r1, [r7, #96]	@ 0x60
341881ce:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341881d2:	667b      	str	r3, [r7, #100]	@ 0x64
341881d4:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
341881d8:	4603      	mov	r3, r0
341881da:	460a      	mov	r2, r1
341881dc:	4313      	orrs	r3, r2
341881de:	d067      	beq.n	341882b0 <HAL_RCCEx_PeriphCLKConfig+0x1e58>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
341881e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341881e4:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
341881e8:	4b27      	ldr	r3, [pc, #156]	@ (34188288 <HAL_RCCEx_PeriphCLKConfig+0x1e30>)
341881ea:	429a      	cmp	r2, r3
341881ec:	d116      	bne.n	3418821c <HAL_RCCEx_PeriphCLKConfig+0x1dc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341881ee:	4b1b      	ldr	r3, [pc, #108]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341881f0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341881f4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341881f8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341881fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188200:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34188202:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188206:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34188208:	3b01      	subs	r3, #1
3418820a:	041b      	lsls	r3, r3, #16
3418820c:	4313      	orrs	r3, r2
3418820e:	4a13      	ldr	r2, [pc, #76]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34188210:	430b      	orrs	r3, r1
34188212:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34188216:	f7fe f877 	bl	34186308 <LL_RCC_IC9_Enable>
3418821a:	e042      	b.n	341882a2 <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
3418821c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188220:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34188224:	4b19      	ldr	r3, [pc, #100]	@ (3418828c <HAL_RCCEx_PeriphCLKConfig+0x1e34>)
34188226:	429a      	cmp	r2, r3
34188228:	d132      	bne.n	34188290 <HAL_RCCEx_PeriphCLKConfig+0x1e38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418822a:	4b0c      	ldr	r3, [pc, #48]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3418822c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34188230:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34188234:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34188238:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418823c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418823e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188242:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34188244:	3b01      	subs	r3, #1
34188246:	041b      	lsls	r3, r3, #16
34188248:	4313      	orrs	r3, r2
3418824a:	4a04      	ldr	r2, [pc, #16]	@ (3418825c <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3418824c:	430b      	orrs	r3, r1
3418824e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34188252:	f7fe f891 	bl	34186378 <LL_RCC_IC14_Enable>
34188256:	e024      	b.n	341882a2 <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
34188258:	07031420 	.word	0x07031420
3418825c:	56028000 	.word	0x56028000
34188260:	07011420 	.word	0x07011420
34188264:	07021820 	.word	0x07021820
34188268:	07031820 	.word	0x07031820
3418826c:	07011820 	.word	0x07011820
34188270:	07020030 	.word	0x07020030
34188274:	07030030 	.word	0x07030030
34188278:	07010030 	.word	0x07010030
3418827c:	07020430 	.word	0x07020430
34188280:	07030430 	.word	0x07030430
34188284:	07010430 	.word	0x07010430
34188288:	07020830 	.word	0x07020830
3418828c:	07030830 	.word	0x07030830
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
34188290:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188294:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34188298:	4bb3      	ldr	r3, [pc, #716]	@ (34188568 <HAL_RCCEx_PeriphCLKConfig+0x2110>)
3418829a:	429a      	cmp	r2, r3
3418829c:	d101      	bne.n	341882a2 <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    {
      LL_RCC_CLKP_Enable();
3418829e:	f7fe f8cd 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART3 clock */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
341882a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341882a6:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
341882aa:	4618      	mov	r0, r3
341882ac:	f7fd fd1f 	bl	34185cee <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART4 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
341882b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341882b4:	e9d3 2300 	ldrd	r2, r3, [r3]
341882b8:	2100      	movs	r1, #0
341882ba:	65b9      	str	r1, [r7, #88]	@ 0x58
341882bc:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
341882c0:	65fb      	str	r3, [r7, #92]	@ 0x5c
341882c2:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
341882c6:	4603      	mov	r3, r0
341882c8:	460a      	mov	r2, r1
341882ca:	4313      	orrs	r3, r2
341882cc:	d04b      	beq.n	34188366 <HAL_RCCEx_PeriphCLKConfig+0x1f0e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
341882ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341882d2:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
341882d6:	4ba5      	ldr	r3, [pc, #660]	@ (3418856c <HAL_RCCEx_PeriphCLKConfig+0x2114>)
341882d8:	429a      	cmp	r2, r3
341882da:	d116      	bne.n	3418830a <HAL_RCCEx_PeriphCLKConfig+0x1eb2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341882dc:	4ba4      	ldr	r3, [pc, #656]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341882de:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341882e2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341882e6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341882ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341882ee:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341882f0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341882f4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341882f6:	3b01      	subs	r3, #1
341882f8:	041b      	lsls	r3, r3, #16
341882fa:	4313      	orrs	r3, r2
341882fc:	4a9c      	ldr	r2, [pc, #624]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341882fe:	430b      	orrs	r3, r1
34188300:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34188304:	f7fe f800 	bl	34186308 <LL_RCC_IC9_Enable>
34188308:	e026      	b.n	34188358 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
3418830a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418830e:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34188312:	4b98      	ldr	r3, [pc, #608]	@ (34188574 <HAL_RCCEx_PeriphCLKConfig+0x211c>)
34188314:	429a      	cmp	r2, r3
34188316:	d116      	bne.n	34188346 <HAL_RCCEx_PeriphCLKConfig+0x1eee>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34188318:	4b95      	ldr	r3, [pc, #596]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3418831a:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418831e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34188322:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34188326:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418832a:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418832c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188330:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34188332:	3b01      	subs	r3, #1
34188334:	041b      	lsls	r3, r3, #16
34188336:	4313      	orrs	r3, r2
34188338:	4a8d      	ldr	r2, [pc, #564]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3418833a:	430b      	orrs	r3, r1
3418833c:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34188340:	f7fe f81a 	bl	34186378 <LL_RCC_IC14_Enable>
34188344:	e008      	b.n	34188358 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
34188346:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418834a:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3418834e:	4b8a      	ldr	r3, [pc, #552]	@ (34188578 <HAL_RCCEx_PeriphCLKConfig+0x2120>)
34188350:	429a      	cmp	r2, r3
34188352:	d101      	bne.n	34188358 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    {
      LL_RCC_CLKP_Enable();
34188354:	f7fe f872 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART4 clock */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
34188358:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418835c:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34188360:	4618      	mov	r0, r3
34188362:	f7fd fcc4 	bl	34185cee <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART5 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
34188366:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418836a:	e9d3 2300 	ldrd	r2, r3, [r3]
3418836e:	2100      	movs	r1, #0
34188370:	6539      	str	r1, [r7, #80]	@ 0x50
34188372:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34188376:	657b      	str	r3, [r7, #84]	@ 0x54
34188378:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
3418837c:	4603      	mov	r3, r0
3418837e:	460a      	mov	r2, r1
34188380:	4313      	orrs	r3, r2
34188382:	d04b      	beq.n	3418841c <HAL_RCCEx_PeriphCLKConfig+0x1fc4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
34188384:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188388:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3418838c:	4b7b      	ldr	r3, [pc, #492]	@ (3418857c <HAL_RCCEx_PeriphCLKConfig+0x2124>)
3418838e:	429a      	cmp	r2, r3
34188390:	d116      	bne.n	341883c0 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34188392:	4b77      	ldr	r3, [pc, #476]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34188394:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34188398:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418839c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341883a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341883a4:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341883a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341883aa:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341883ac:	3b01      	subs	r3, #1
341883ae:	041b      	lsls	r3, r3, #16
341883b0:	4313      	orrs	r3, r2
341883b2:	4a6f      	ldr	r2, [pc, #444]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341883b4:	430b      	orrs	r3, r1
341883b6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341883ba:	f7fd ffa5 	bl	34186308 <LL_RCC_IC9_Enable>
341883be:	e026      	b.n	3418840e <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
341883c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341883c4:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
341883c8:	4b6d      	ldr	r3, [pc, #436]	@ (34188580 <HAL_RCCEx_PeriphCLKConfig+0x2128>)
341883ca:	429a      	cmp	r2, r3
341883cc:	d116      	bne.n	341883fc <HAL_RCCEx_PeriphCLKConfig+0x1fa4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341883ce:	4b68      	ldr	r3, [pc, #416]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341883d0:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341883d4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341883d8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341883dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341883e0:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341883e2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341883e6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341883e8:	3b01      	subs	r3, #1
341883ea:	041b      	lsls	r3, r3, #16
341883ec:	4313      	orrs	r3, r2
341883ee:	4a60      	ldr	r2, [pc, #384]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341883f0:	430b      	orrs	r3, r1
341883f2:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341883f6:	f7fd ffbf 	bl	34186378 <LL_RCC_IC14_Enable>
341883fa:	e008      	b.n	3418840e <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
341883fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188400:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
34188404:	4b5f      	ldr	r3, [pc, #380]	@ (34188584 <HAL_RCCEx_PeriphCLKConfig+0x212c>)
34188406:	429a      	cmp	r2, r3
34188408:	d101      	bne.n	3418840e <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    {
      LL_RCC_CLKP_Enable();
3418840a:	f7fe f817 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART5 clock */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
3418840e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188412:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
34188416:	4618      	mov	r0, r3
34188418:	f7fd fc69 	bl	34185cee <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
3418841c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188420:	e9d3 2300 	ldrd	r2, r3, [r3]
34188424:	2100      	movs	r1, #0
34188426:	64b9      	str	r1, [r7, #72]	@ 0x48
34188428:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3418842c:	64fb      	str	r3, [r7, #76]	@ 0x4c
3418842e:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
34188432:	4603      	mov	r3, r0
34188434:	460a      	mov	r2, r1
34188436:	4313      	orrs	r3, r2
34188438:	d04b      	beq.n	341884d2 <HAL_RCCEx_PeriphCLKConfig+0x207a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
3418843a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418843e:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
34188442:	4b51      	ldr	r3, [pc, #324]	@ (34188588 <HAL_RCCEx_PeriphCLKConfig+0x2130>)
34188444:	429a      	cmp	r2, r3
34188446:	d116      	bne.n	34188476 <HAL_RCCEx_PeriphCLKConfig+0x201e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34188448:	4b49      	ldr	r3, [pc, #292]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3418844a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418844e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34188452:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34188456:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418845a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3418845c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188460:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34188462:	3b01      	subs	r3, #1
34188464:	041b      	lsls	r3, r3, #16
34188466:	4313      	orrs	r3, r2
34188468:	4a41      	ldr	r2, [pc, #260]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3418846a:	430b      	orrs	r3, r1
3418846c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34188470:	f7fd ff4a 	bl	34186308 <LL_RCC_IC9_Enable>
34188474:	e026      	b.n	341884c4 <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
34188476:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418847a:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3418847e:	4b43      	ldr	r3, [pc, #268]	@ (3418858c <HAL_RCCEx_PeriphCLKConfig+0x2134>)
34188480:	429a      	cmp	r2, r3
34188482:	d116      	bne.n	341884b2 <HAL_RCCEx_PeriphCLKConfig+0x205a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34188484:	4b3a      	ldr	r3, [pc, #232]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34188486:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418848a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418848e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34188492:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188496:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34188498:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418849c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3418849e:	3b01      	subs	r3, #1
341884a0:	041b      	lsls	r3, r3, #16
341884a2:	4313      	orrs	r3, r2
341884a4:	4a32      	ldr	r2, [pc, #200]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341884a6:	430b      	orrs	r3, r1
341884a8:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341884ac:	f7fd ff64 	bl	34186378 <LL_RCC_IC14_Enable>
341884b0:	e008      	b.n	341884c4 <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
341884b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341884b6:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
341884ba:	4b35      	ldr	r3, [pc, #212]	@ (34188590 <HAL_RCCEx_PeriphCLKConfig+0x2138>)
341884bc:	429a      	cmp	r2, r3
341884be:	d101      	bne.n	341884c4 <HAL_RCCEx_PeriphCLKConfig+0x206c>
    {
      LL_RCC_CLKP_Enable();
341884c0:	f7fd ffbc 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART6 clock */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
341884c4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341884c8:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
341884cc:	4618      	mov	r0, r3
341884ce:	f7fd fc0e 	bl	34185cee <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART7 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
341884d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341884d6:	e9d3 2300 	ldrd	r2, r3, [r3]
341884da:	2100      	movs	r1, #0
341884dc:	6439      	str	r1, [r7, #64]	@ 0x40
341884de:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
341884e2:	647b      	str	r3, [r7, #68]	@ 0x44
341884e4:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
341884e8:	4603      	mov	r3, r0
341884ea:	460a      	mov	r2, r1
341884ec:	4313      	orrs	r3, r2
341884ee:	d065      	beq.n	341885bc <HAL_RCCEx_PeriphCLKConfig+0x2164>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
341884f0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341884f4:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
341884f8:	4b26      	ldr	r3, [pc, #152]	@ (34188594 <HAL_RCCEx_PeriphCLKConfig+0x213c>)
341884fa:	429a      	cmp	r2, r3
341884fc:	d116      	bne.n	3418852c <HAL_RCCEx_PeriphCLKConfig+0x20d4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341884fe:	4b1c      	ldr	r3, [pc, #112]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34188500:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34188504:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34188508:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418850c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188510:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34188512:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188516:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34188518:	3b01      	subs	r3, #1
3418851a:	041b      	lsls	r3, r3, #16
3418851c:	4313      	orrs	r3, r2
3418851e:	4a14      	ldr	r2, [pc, #80]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34188520:	430b      	orrs	r3, r1
34188522:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34188526:	f7fd feef 	bl	34186308 <LL_RCC_IC9_Enable>
3418852a:	e040      	b.n	341885ae <HAL_RCCEx_PeriphCLKConfig+0x2156>
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
3418852c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188530:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34188534:	4b18      	ldr	r3, [pc, #96]	@ (34188598 <HAL_RCCEx_PeriphCLKConfig+0x2140>)
34188536:	429a      	cmp	r2, r3
34188538:	d130      	bne.n	3418859c <HAL_RCCEx_PeriphCLKConfig+0x2144>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418853a:	4b0d      	ldr	r3, [pc, #52]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3418853c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34188540:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34188544:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34188548:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418854c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418854e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188552:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34188554:	3b01      	subs	r3, #1
34188556:	041b      	lsls	r3, r3, #16
34188558:	4313      	orrs	r3, r2
3418855a:	4a05      	ldr	r2, [pc, #20]	@ (34188570 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3418855c:	430b      	orrs	r3, r1
3418855e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34188562:	f7fd ff09 	bl	34186378 <LL_RCC_IC14_Enable>
34188566:	e022      	b.n	341885ae <HAL_RCCEx_PeriphCLKConfig+0x2156>
34188568:	07010830 	.word	0x07010830
3418856c:	07020c30 	.word	0x07020c30
34188570:	56028000 	.word	0x56028000
34188574:	07030c30 	.word	0x07030c30
34188578:	07010c30 	.word	0x07010c30
3418857c:	07021030 	.word	0x07021030
34188580:	07031030 	.word	0x07031030
34188584:	07011030 	.word	0x07011030
34188588:	07021430 	.word	0x07021430
3418858c:	07031430 	.word	0x07031430
34188590:	07011430 	.word	0x07011430
34188594:	07021830 	.word	0x07021830
34188598:	07031830 	.word	0x07031830
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
3418859c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341885a0:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
341885a4:	4bc8      	ldr	r3, [pc, #800]	@ (341888c8 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
341885a6:	429a      	cmp	r2, r3
341885a8:	d101      	bne.n	341885ae <HAL_RCCEx_PeriphCLKConfig+0x2156>
    {
      LL_RCC_CLKP_Enable();
341885aa:	f7fd ff47 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART7 clock */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
341885ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341885b2:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
341885b6:	4618      	mov	r0, r3
341885b8:	f7fd fb99 	bl	34185cee <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART8 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
341885bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341885c0:	e9d3 2300 	ldrd	r2, r3, [r3]
341885c4:	2100      	movs	r1, #0
341885c6:	63b9      	str	r1, [r7, #56]	@ 0x38
341885c8:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
341885cc:	63fb      	str	r3, [r7, #60]	@ 0x3c
341885ce:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
341885d2:	4603      	mov	r3, r0
341885d4:	460a      	mov	r2, r1
341885d6:	4313      	orrs	r3, r2
341885d8:	d04b      	beq.n	34188672 <HAL_RCCEx_PeriphCLKConfig+0x221a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
341885da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341885de:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
341885e2:	4bba      	ldr	r3, [pc, #744]	@ (341888cc <HAL_RCCEx_PeriphCLKConfig+0x2474>)
341885e4:	429a      	cmp	r2, r3
341885e6:	d116      	bne.n	34188616 <HAL_RCCEx_PeriphCLKConfig+0x21be>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341885e8:	4bb9      	ldr	r3, [pc, #740]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341885ea:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341885ee:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341885f2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341885f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341885fa:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341885fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188600:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34188602:	3b01      	subs	r3, #1
34188604:	041b      	lsls	r3, r3, #16
34188606:	4313      	orrs	r3, r2
34188608:	4ab1      	ldr	r2, [pc, #708]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3418860a:	430b      	orrs	r3, r1
3418860c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34188610:	f7fd fe7a 	bl	34186308 <LL_RCC_IC9_Enable>
34188614:	e026      	b.n	34188664 <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
34188616:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418861a:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3418861e:	4bad      	ldr	r3, [pc, #692]	@ (341888d4 <HAL_RCCEx_PeriphCLKConfig+0x247c>)
34188620:	429a      	cmp	r2, r3
34188622:	d116      	bne.n	34188652 <HAL_RCCEx_PeriphCLKConfig+0x21fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34188624:	4baa      	ldr	r3, [pc, #680]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34188626:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418862a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418862e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34188632:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188636:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34188638:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418863c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3418863e:	3b01      	subs	r3, #1
34188640:	041b      	lsls	r3, r3, #16
34188642:	4313      	orrs	r3, r2
34188644:	4aa2      	ldr	r2, [pc, #648]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34188646:	430b      	orrs	r3, r1
34188648:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3418864c:	f7fd fe94 	bl	34186378 <LL_RCC_IC14_Enable>
34188650:	e008      	b.n	34188664 <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
34188652:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188656:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3418865a:	4b9f      	ldr	r3, [pc, #636]	@ (341888d8 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
3418865c:	429a      	cmp	r2, r3
3418865e:	d101      	bne.n	34188664 <HAL_RCCEx_PeriphCLKConfig+0x220c>
    {
      LL_RCC_CLKP_Enable();
34188660:	f7fd feec 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART8 clock */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
34188664:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188668:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
3418866c:	4618      	mov	r0, r3
3418866e:	f7fd fb3e 	bl	34185cee <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART9 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
34188672:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188676:	e9d3 2300 	ldrd	r2, r3, [r3]
3418867a:	2100      	movs	r1, #0
3418867c:	6339      	str	r1, [r7, #48]	@ 0x30
3418867e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34188682:	637b      	str	r3, [r7, #52]	@ 0x34
34188684:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
34188688:	4603      	mov	r3, r0
3418868a:	460a      	mov	r2, r1
3418868c:	4313      	orrs	r3, r2
3418868e:	d04b      	beq.n	34188728 <HAL_RCCEx_PeriphCLKConfig+0x22d0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));

    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
34188690:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188694:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34188698:	4a90      	ldr	r2, [pc, #576]	@ (341888dc <HAL_RCCEx_PeriphCLKConfig+0x2484>)
3418869a:	4293      	cmp	r3, r2
3418869c:	d116      	bne.n	341886cc <HAL_RCCEx_PeriphCLKConfig+0x2274>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418869e:	4b8c      	ldr	r3, [pc, #560]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341886a0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341886a4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341886a8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341886ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341886b0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341886b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341886b6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341886b8:	3b01      	subs	r3, #1
341886ba:	041b      	lsls	r3, r3, #16
341886bc:	4313      	orrs	r3, r2
341886be:	4a84      	ldr	r2, [pc, #528]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341886c0:	430b      	orrs	r3, r1
341886c2:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341886c6:	f7fd fe1f 	bl	34186308 <LL_RCC_IC9_Enable>
341886ca:	e026      	b.n	3418871a <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
341886cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341886d0:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
341886d4:	4a82      	ldr	r2, [pc, #520]	@ (341888e0 <HAL_RCCEx_PeriphCLKConfig+0x2488>)
341886d6:	4293      	cmp	r3, r2
341886d8:	d116      	bne.n	34188708 <HAL_RCCEx_PeriphCLKConfig+0x22b0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341886da:	4b7d      	ldr	r3, [pc, #500]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341886dc:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341886e0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341886e4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341886e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341886ec:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341886ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341886f2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341886f4:	3b01      	subs	r3, #1
341886f6:	041b      	lsls	r3, r3, #16
341886f8:	4313      	orrs	r3, r2
341886fa:	4a75      	ldr	r2, [pc, #468]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341886fc:	430b      	orrs	r3, r1
341886fe:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34188702:	f7fd fe39 	bl	34186378 <LL_RCC_IC14_Enable>
34188706:	e008      	b.n	3418871a <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
34188708:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418870c:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34188710:	4a74      	ldr	r2, [pc, #464]	@ (341888e4 <HAL_RCCEx_PeriphCLKConfig+0x248c>)
34188712:	4293      	cmp	r3, r2
34188714:	d101      	bne.n	3418871a <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    {
      LL_RCC_CLKP_Enable();
34188716:	f7fd fe91 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART9 clock */
    __HAL_RCC_UART9_CONFIG(PeriphClkInit->Uart9ClockSelection);
3418871a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418871e:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34188722:	4618      	mov	r0, r3
34188724:	f7fd fae3 	bl	34185cee <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART10 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
34188728:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418872c:	e9d3 2300 	ldrd	r2, r3, [r3]
34188730:	2100      	movs	r1, #0
34188732:	62b9      	str	r1, [r7, #40]	@ 0x28
34188734:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34188738:	62fb      	str	r3, [r7, #44]	@ 0x2c
3418873a:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
3418873e:	4603      	mov	r3, r0
34188740:	460a      	mov	r2, r1
34188742:	4313      	orrs	r3, r2
34188744:	d04b      	beq.n	341887de <HAL_RCCEx_PeriphCLKConfig+0x2386>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));

    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
34188746:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418874a:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3418874e:	4a66      	ldr	r2, [pc, #408]	@ (341888e8 <HAL_RCCEx_PeriphCLKConfig+0x2490>)
34188750:	4293      	cmp	r3, r2
34188752:	d116      	bne.n	34188782 <HAL_RCCEx_PeriphCLKConfig+0x232a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34188754:	4b5e      	ldr	r3, [pc, #376]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34188756:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418875a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418875e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34188762:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34188766:	6c91      	ldr	r1, [r2, #72]	@ 0x48
34188768:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3418876c:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
3418876e:	3a01      	subs	r2, #1
34188770:	0412      	lsls	r2, r2, #16
34188772:	430a      	orrs	r2, r1
34188774:	4956      	ldr	r1, [pc, #344]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34188776:	4313      	orrs	r3, r2
34188778:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3418877c:	f7fd fdc4 	bl	34186308 <LL_RCC_IC9_Enable>
34188780:	e026      	b.n	341887d0 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
34188782:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188786:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3418878a:	4a58      	ldr	r2, [pc, #352]	@ (341888ec <HAL_RCCEx_PeriphCLKConfig+0x2494>)
3418878c:	4293      	cmp	r3, r2
3418878e:	d116      	bne.n	341887be <HAL_RCCEx_PeriphCLKConfig+0x2366>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34188790:	4b4f      	ldr	r3, [pc, #316]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34188792:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34188796:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418879a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418879e:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
341887a2:	6f11      	ldr	r1, [r2, #112]	@ 0x70
341887a4:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
341887a8:	6f52      	ldr	r2, [r2, #116]	@ 0x74
341887aa:	3a01      	subs	r2, #1
341887ac:	0412      	lsls	r2, r2, #16
341887ae:	430a      	orrs	r2, r1
341887b0:	4947      	ldr	r1, [pc, #284]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341887b2:	4313      	orrs	r3, r2
341887b4:	f8c1 30f8 	str.w	r3, [r1, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341887b8:	f7fd fdde 	bl	34186378 <LL_RCC_IC14_Enable>
341887bc:	e008      	b.n	341887d0 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
341887be:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341887c2:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
341887c6:	4a4a      	ldr	r2, [pc, #296]	@ (341888f0 <HAL_RCCEx_PeriphCLKConfig+0x2498>)
341887c8:	4293      	cmp	r3, r2
341887ca:	d101      	bne.n	341887d0 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    {
      LL_RCC_CLKP_Enable();
341887cc:	f7fd fe36 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART10 clock */
    __HAL_RCC_USART10_CONFIG(PeriphClkInit->Usart10ClockSelection);
341887d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341887d4:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
341887d8:	4618      	mov	r0, r3
341887da:	f7fd fa88 	bl	34185cee <LL_RCC_SetUSARTClockSource>
  }

  /*------------------------------ USBPHY1 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
341887de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341887e2:	e9d3 2300 	ldrd	r2, r3, [r3]
341887e6:	2100      	movs	r1, #0
341887e8:	6239      	str	r1, [r7, #32]
341887ea:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
341887ee:	627b      	str	r3, [r7, #36]	@ 0x24
341887f0:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
341887f4:	4603      	mov	r3, r0
341887f6:	460a      	mov	r2, r1
341887f8:	4313      	orrs	r3, r2
341887fa:	d014      	beq.n	34188826 <HAL_RCCEx_PeriphCLKConfig+0x23ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));

    /* Set the source of USBPHY1 clock*/
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
341887fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188800:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34188804:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34188808:	4618      	mov	r0, r3
3418880a:	f7fd fa18 	bl	34185c3e <LL_RCC_SetOTGPHYCKREFClockSource>
3418880e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188812:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34188816:	0fdb      	lsrs	r3, r3, #31
34188818:	2b01      	cmp	r3, #1
3418881a:	d102      	bne.n	34188822 <HAL_RCCEx_PeriphCLKConfig+0x23ca>
3418881c:	f7fd f83c 	bl	34185898 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34188820:	e001      	b.n	34188826 <HAL_RCCEx_PeriphCLKConfig+0x23ce>
34188822:	f7fd f829 	bl	34185878 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBPHY2 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
34188826:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418882a:	e9d3 2300 	ldrd	r2, r3, [r3]
3418882e:	2100      	movs	r1, #0
34188830:	61b9      	str	r1, [r7, #24]
34188832:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34188836:	61fb      	str	r3, [r7, #28]
34188838:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
3418883c:	4603      	mov	r3, r0
3418883e:	460a      	mov	r2, r1
34188840:	4313      	orrs	r3, r2
34188842:	d014      	beq.n	3418886e <HAL_RCCEx_PeriphCLKConfig+0x2416>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));

    /* Set the source of USBPHY2 clock*/
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
34188844:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188848:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
3418884c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34188850:	4618      	mov	r0, r3
34188852:	f7fd f9f4 	bl	34185c3e <LL_RCC_SetOTGPHYCKREFClockSource>
34188856:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418885a:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
3418885e:	0fdb      	lsrs	r3, r3, #31
34188860:	2b01      	cmp	r3, #1
34188862:	d102      	bne.n	3418886a <HAL_RCCEx_PeriphCLKConfig+0x2412>
34188864:	f7fd f818 	bl	34185898 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34188868:	e001      	b.n	3418886e <HAL_RCCEx_PeriphCLKConfig+0x2416>
3418886a:	f7fd f805 	bl	34185878 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS1 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
3418886e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188872:	e9d3 2300 	ldrd	r2, r3, [r3]
34188876:	2100      	movs	r1, #0
34188878:	6139      	str	r1, [r7, #16]
3418887a:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
3418887e:	617b      	str	r3, [r7, #20]
34188880:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
34188884:	4603      	mov	r3, r0
34188886:	460a      	mov	r2, r1
34188888:	4313      	orrs	r3, r2
3418888a:	d053      	beq.n	34188934 <HAL_RCCEx_PeriphCLKConfig+0x24dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));

    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
3418888c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188890:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34188894:	4a17      	ldr	r2, [pc, #92]	@ (341888f4 <HAL_RCCEx_PeriphCLKConfig+0x249c>)
34188896:	4293      	cmp	r3, r2
34188898:	d12e      	bne.n	341888f8 <HAL_RCCEx_PeriphCLKConfig+0x24a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418889a:	4b0d      	ldr	r3, [pc, #52]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3418889c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341888a0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
341888a4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
341888a8:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
341888ac:	6f91      	ldr	r1, [r2, #120]	@ 0x78
341888ae:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
341888b2:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
341888b4:	3a01      	subs	r2, #1
341888b6:	0412      	lsls	r2, r2, #16
341888b8:	430a      	orrs	r2, r1
341888ba:	4905      	ldr	r1, [pc, #20]	@ (341888d0 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341888bc:	4313      	orrs	r3, r2
341888be:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
341888c2:	f7fd fd67 	bl	34186394 <LL_RCC_IC15_Enable>
341888c6:	e020      	b.n	3418890a <HAL_RCCEx_PeriphCLKConfig+0x24b2>
341888c8:	07011830 	.word	0x07011830
341888cc:	07021c30 	.word	0x07021c30
341888d0:	56028000 	.word	0x56028000
341888d4:	07031c30 	.word	0x07031c30
341888d8:	07011c30 	.word	0x07011c30
341888dc:	07020034 	.word	0x07020034
341888e0:	07030034 	.word	0x07030034
341888e4:	07010034 	.word	0x07010034
341888e8:	07020434 	.word	0x07020434
341888ec:	07030434 	.word	0x07030434
341888f0:	07010434 	.word	0x07010434
341888f4:	03020c14 	.word	0x03020c14
    }
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
341888f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341888fc:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34188900:	4a43      	ldr	r2, [pc, #268]	@ (34188a10 <HAL_RCCEx_PeriphCLKConfig+0x25b8>)
34188902:	4293      	cmp	r3, r2
34188904:	d101      	bne.n	3418890a <HAL_RCCEx_PeriphCLKConfig+0x24b2>
    {
      LL_RCC_CLKP_Enable();
34188906:	f7fd fd99 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS1 clock */
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
3418890a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418890e:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34188912:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34188916:	4618      	mov	r0, r3
34188918:	f7fd f986 	bl	34185c28 <LL_RCC_SetOTGPHYClockSource>
3418891c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188920:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34188924:	0fdb      	lsrs	r3, r3, #31
34188926:	2b01      	cmp	r3, #1
34188928:	d102      	bne.n	34188930 <HAL_RCCEx_PeriphCLKConfig+0x24d8>
3418892a:	f7fc ffb5 	bl	34185898 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
3418892e:	e001      	b.n	34188934 <HAL_RCCEx_PeriphCLKConfig+0x24dc>
34188930:	f7fc ffa2 	bl	34185878 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS2 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
34188934:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188938:	e9d3 2300 	ldrd	r2, r3, [r3]
3418893c:	2100      	movs	r1, #0
3418893e:	60b9      	str	r1, [r7, #8]
34188940:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34188944:	60fb      	str	r3, [r7, #12]
34188946:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
3418894a:	4603      	mov	r3, r0
3418894c:	460a      	mov	r2, r1
3418894e:	4313      	orrs	r3, r2
34188950:	d03b      	beq.n	341889ca <HAL_RCCEx_PeriphCLKConfig+0x2572>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));

    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
34188952:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188956:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
3418895a:	4a2e      	ldr	r2, [pc, #184]	@ (34188a14 <HAL_RCCEx_PeriphCLKConfig+0x25bc>)
3418895c:	4293      	cmp	r3, r2
3418895e:	d116      	bne.n	3418898e <HAL_RCCEx_PeriphCLKConfig+0x2536>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34188960:	4b2d      	ldr	r3, [pc, #180]	@ (34188a18 <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
34188962:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34188966:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418896a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418896e:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34188972:	6f91      	ldr	r1, [r2, #120]	@ 0x78
34188974:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34188978:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
3418897a:	3a01      	subs	r2, #1
3418897c:	0412      	lsls	r2, r2, #16
3418897e:	430a      	orrs	r2, r1
34188980:	4925      	ldr	r1, [pc, #148]	@ (34188a18 <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
34188982:	4313      	orrs	r3, r2
34188984:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34188988:	f7fd fd04 	bl	34186394 <LL_RCC_IC15_Enable>
3418898c:	e008      	b.n	341889a0 <HAL_RCCEx_PeriphCLKConfig+0x2548>
    }
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
3418898e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34188992:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34188996:	4a21      	ldr	r2, [pc, #132]	@ (34188a1c <HAL_RCCEx_PeriphCLKConfig+0x25c4>)
34188998:	4293      	cmp	r3, r2
3418899a:	d101      	bne.n	341889a0 <HAL_RCCEx_PeriphCLKConfig+0x2548>
    {
      LL_RCC_CLKP_Enable();
3418899c:	f7fd fd4e 	bl	3418643c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS2 clock */
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
341889a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341889a4:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
341889a8:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
341889ac:	4618      	mov	r0, r3
341889ae:	f7fd f93b 	bl	34185c28 <LL_RCC_SetOTGPHYClockSource>
341889b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341889b6:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
341889ba:	0fdb      	lsrs	r3, r3, #31
341889bc:	2b01      	cmp	r3, #1
341889be:	d102      	bne.n	341889c6 <HAL_RCCEx_PeriphCLKConfig+0x256e>
341889c0:	f7fc ff6a 	bl	34185898 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
341889c4:	e001      	b.n	341889ca <HAL_RCCEx_PeriphCLKConfig+0x2572>
341889c6:	f7fc ff57 	bl	34185878 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
341889ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341889ce:	e9d3 2300 	ldrd	r2, r3, [r3]
341889d2:	2100      	movs	r1, #0
341889d4:	6039      	str	r1, [r7, #0]
341889d6:	f003 0380 	and.w	r3, r3, #128	@ 0x80
341889da:	607b      	str	r3, [r7, #4]
341889dc:	e9d7 0100 	ldrd	r0, r1, [r7]
341889e0:	4603      	mov	r3, r0
341889e2:	460a      	mov	r2, r1
341889e4:	4313      	orrs	r3, r2
341889e6:	d006      	beq.n	341889f6 <HAL_RCCEx_PeriphCLKConfig+0x259e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER_CONFIG(PeriphClkInit->TIMPresSelection);
341889e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341889ec:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
341889f0:	4618      	mov	r0, r3
341889f2:	f7fd f9cd 	bl	34185d90 <LL_RCC_SetTIMPrescaler>
  }

  if (status == HAL_OK)
341889f6:	f897 31c6 	ldrb.w	r3, [r7, #454]	@ 0x1c6
341889fa:	2b00      	cmp	r3, #0
341889fc:	d101      	bne.n	34188a02 <HAL_RCCEx_PeriphCLKConfig+0x25aa>
  {
    return HAL_OK;
341889fe:	2300      	movs	r3, #0
34188a00:	e000      	b.n	34188a04 <HAL_RCCEx_PeriphCLKConfig+0x25ac>
  }
  return HAL_ERROR;
34188a02:	2301      	movs	r3, #1
}
34188a04:	4618      	mov	r0, r3
34188a06:	f507 77e4 	add.w	r7, r7, #456	@ 0x1c8
34188a0a:	46bd      	mov	sp, r7
34188a0c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
34188a10:	03010c14 	.word	0x03010c14
34188a14:	03021414 	.word	0x03021414
34188a18:	56028000 	.word	0x56028000
34188a1c:	03011414 	.word	0x03011414

34188a20 <HAL_RCCEx_GetPLL1CLKFreq>:
  * @brief  Return PLL1 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL1 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL1CLKFreq(void)
{
34188a20:	b5f0      	push	{r4, r5, r6, r7, lr}
34188a22:	b087      	sub	sp, #28
34188a24:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34188a26:	2300      	movs	r3, #0
34188a28:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL1_IsReady() != 0U)
34188a2a:	f7fd f9d5 	bl	34185dd8 <LL_RCC_PLL1_IsReady>
34188a2e:	4603      	mov	r3, r0
34188a30:	2b00      	cmp	r3, #0
34188a32:	d02a      	beq.n	34188a8a <HAL_RCCEx_GetPLL1CLKFreq+0x6a>
  {
    if (LL_RCC_PLL1P_IsEnabled() != 0U)
34188a34:	f7fd fa38 	bl	34185ea8 <LL_RCC_PLL1P_IsEnabled>
34188a38:	4603      	mov	r3, r0
34188a3a:	2b00      	cmp	r3, #0
34188a3c:	d031      	beq.n	34188aa2 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34188a3e:	f7fd f9bd 	bl	34185dbc <LL_RCC_PLL1_GetSource>
34188a42:	4603      	mov	r3, r0
34188a44:	4618      	mov	r0, r3
34188a46:	f000 f903 	bl	34188c50 <RCCEx_GetPLLSourceFreq>
34188a4a:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34188a4c:	68bb      	ldr	r3, [r7, #8]
34188a4e:	2b00      	cmp	r3, #0
34188a50:	d027      	beq.n	34188aa2 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
      {
        divm = LL_RCC_PLL1_GetM();
34188a52:	f7fd f9f9 	bl	34185e48 <LL_RCC_PLL1_GetM>
34188a56:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34188a58:	687b      	ldr	r3, [r7, #4]
34188a5a:	2b00      	cmp	r3, #0
34188a5c:	d021      	beq.n	34188aa2 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
34188a5e:	f7fd f9e3 	bl	34185e28 <LL_RCC_PLL1_GetN>
34188a62:	4605      	mov	r5, r0
34188a64:	f7fd fa34 	bl	34185ed0 <LL_RCC_PLL1_GetFRACN>
34188a68:	4606      	mov	r6, r0
34188a6a:	f7fd f9fd 	bl	34185e68 <LL_RCC_PLL1_GetP1>
34188a6e:	4604      	mov	r4, r0
34188a70:	f7fd fa0a 	bl	34185e88 <LL_RCC_PLL1_GetP2>
34188a74:	4603      	mov	r3, r0
34188a76:	9301      	str	r3, [sp, #4]
34188a78:	9400      	str	r4, [sp, #0]
34188a7a:	4633      	mov	r3, r6
34188a7c:	462a      	mov	r2, r5
34188a7e:	6879      	ldr	r1, [r7, #4]
34188a80:	68b8      	ldr	r0, [r7, #8]
34188a82:	f000 f943 	bl	34188d0c <RCCEx_CalcPLLFreq>
34188a86:	60f8      	str	r0, [r7, #12]
34188a88:	e00b      	b.n	34188aa2 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
                                            LL_RCC_PLL1_GetP1(), LL_RCC_PLL1_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL1_IsEnabledBypass() != 0U)
34188a8a:	f7fd f9b9 	bl	34185e00 <LL_RCC_PLL1_IsEnabledBypass>
34188a8e:	4603      	mov	r3, r0
34188a90:	2b00      	cmp	r3, #0
34188a92:	d006      	beq.n	34188aa2 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34188a94:	f7fd f992 	bl	34185dbc <LL_RCC_PLL1_GetSource>
34188a98:	4603      	mov	r3, r0
34188a9a:	4618      	mov	r0, r3
34188a9c:	f000 f8d8 	bl	34188c50 <RCCEx_GetPLLSourceFreq>
34188aa0:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34188aa2:	68fb      	ldr	r3, [r7, #12]
}
34188aa4:	4618      	mov	r0, r3
34188aa6:	3714      	adds	r7, #20
34188aa8:	46bd      	mov	sp, r7
34188aaa:	bdf0      	pop	{r4, r5, r6, r7, pc}

34188aac <HAL_RCCEx_GetPLL2CLKFreq>:
  * @brief  Return PLL2 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL2 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL2CLKFreq(void)
{
34188aac:	b5f0      	push	{r4, r5, r6, r7, lr}
34188aae:	b087      	sub	sp, #28
34188ab0:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34188ab2:	2300      	movs	r3, #0
34188ab4:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL2_IsReady() != 0U)
34188ab6:	f7fd fa27 	bl	34185f08 <LL_RCC_PLL2_IsReady>
34188aba:	4603      	mov	r3, r0
34188abc:	2b00      	cmp	r3, #0
34188abe:	d02a      	beq.n	34188b16 <HAL_RCCEx_GetPLL2CLKFreq+0x6a>
  {
    if (LL_RCC_PLL2P_IsEnabled() != 0U)
34188ac0:	f7fd fa8a 	bl	34185fd8 <LL_RCC_PLL2P_IsEnabled>
34188ac4:	4603      	mov	r3, r0
34188ac6:	2b00      	cmp	r3, #0
34188ac8:	d031      	beq.n	34188b2e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34188aca:	f7fd fa0f 	bl	34185eec <LL_RCC_PLL2_GetSource>
34188ace:	4603      	mov	r3, r0
34188ad0:	4618      	mov	r0, r3
34188ad2:	f000 f8bd 	bl	34188c50 <RCCEx_GetPLLSourceFreq>
34188ad6:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34188ad8:	68bb      	ldr	r3, [r7, #8]
34188ada:	2b00      	cmp	r3, #0
34188adc:	d027      	beq.n	34188b2e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
      {

        divm = LL_RCC_PLL2_GetM();
34188ade:	f7fd fa4b 	bl	34185f78 <LL_RCC_PLL2_GetM>
34188ae2:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34188ae4:	687b      	ldr	r3, [r7, #4]
34188ae6:	2b00      	cmp	r3, #0
34188ae8:	d021      	beq.n	34188b2e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
34188aea:	f7fd fa35 	bl	34185f58 <LL_RCC_PLL2_GetN>
34188aee:	4605      	mov	r5, r0
34188af0:	f7fd fa86 	bl	34186000 <LL_RCC_PLL2_GetFRACN>
34188af4:	4606      	mov	r6, r0
34188af6:	f7fd fa4f 	bl	34185f98 <LL_RCC_PLL2_GetP1>
34188afa:	4604      	mov	r4, r0
34188afc:	f7fd fa5c 	bl	34185fb8 <LL_RCC_PLL2_GetP2>
34188b00:	4603      	mov	r3, r0
34188b02:	9301      	str	r3, [sp, #4]
34188b04:	9400      	str	r4, [sp, #0]
34188b06:	4633      	mov	r3, r6
34188b08:	462a      	mov	r2, r5
34188b0a:	6879      	ldr	r1, [r7, #4]
34188b0c:	68b8      	ldr	r0, [r7, #8]
34188b0e:	f000 f8fd 	bl	34188d0c <RCCEx_CalcPLLFreq>
34188b12:	60f8      	str	r0, [r7, #12]
34188b14:	e00b      	b.n	34188b2e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
                                            LL_RCC_PLL2_GetP1(), LL_RCC_PLL2_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL2_IsEnabledBypass() != 0U)
34188b16:	f7fd fa0b 	bl	34185f30 <LL_RCC_PLL2_IsEnabledBypass>
34188b1a:	4603      	mov	r3, r0
34188b1c:	2b00      	cmp	r3, #0
34188b1e:	d006      	beq.n	34188b2e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34188b20:	f7fd f9e4 	bl	34185eec <LL_RCC_PLL2_GetSource>
34188b24:	4603      	mov	r3, r0
34188b26:	4618      	mov	r0, r3
34188b28:	f000 f892 	bl	34188c50 <RCCEx_GetPLLSourceFreq>
34188b2c:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34188b2e:	68fb      	ldr	r3, [r7, #12]
}
34188b30:	4618      	mov	r0, r3
34188b32:	3714      	adds	r7, #20
34188b34:	46bd      	mov	sp, r7
34188b36:	bdf0      	pop	{r4, r5, r6, r7, pc}

34188b38 <HAL_RCCEx_GetPLL3CLKFreq>:
  * @brief  Return PLL3 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL3 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL3CLKFreq(void)
{
34188b38:	b5f0      	push	{r4, r5, r6, r7, lr}
34188b3a:	b087      	sub	sp, #28
34188b3c:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34188b3e:	2300      	movs	r3, #0
34188b40:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL3_IsReady() != 0U)
34188b42:	f7fd fa79 	bl	34186038 <LL_RCC_PLL3_IsReady>
34188b46:	4603      	mov	r3, r0
34188b48:	2b00      	cmp	r3, #0
34188b4a:	d02a      	beq.n	34188ba2 <HAL_RCCEx_GetPLL3CLKFreq+0x6a>
  {
    if (LL_RCC_PLL3P_IsEnabled() != 0U)
34188b4c:	f7fd fadc 	bl	34186108 <LL_RCC_PLL3P_IsEnabled>
34188b50:	4603      	mov	r3, r0
34188b52:	2b00      	cmp	r3, #0
34188b54:	d031      	beq.n	34188bba <HAL_RCCEx_GetPLL3CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34188b56:	f7fd fa61 	bl	3418601c <LL_RCC_PLL3_GetSource>
34188b5a:	4603      	mov	r3, r0
34188b5c:	4618      	mov	r0, r3
34188b5e:	f000 f877 	bl	34188c50 <RCCEx_GetPLLSourceFreq>
34188b62:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34188b64:	68bb      	ldr	r3, [r7, #8]
34188b66:	2b00      	cmp	r3, #0
34188b68:	d027      	beq.n	34188bba <HAL_RCCEx_GetPLL3CLKFreq+0x82>
      {
        divm = LL_RCC_PLL3_GetM();
34188b6a:	f7fd fa9d 	bl	341860a8 <LL_RCC_PLL3_GetM>
34188b6e:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34188b70:	687b      	ldr	r3, [r7, #4]
34188b72:	2b00      	cmp	r3, #0
34188b74:	d021      	beq.n	34188bba <HAL_RCCEx_GetPLL3CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
34188b76:	f7fd fa87 	bl	34186088 <LL_RCC_PLL3_GetN>
34188b7a:	4605      	mov	r5, r0
34188b7c:	f7fd fad8 	bl	34186130 <LL_RCC_PLL3_GetFRACN>
34188b80:	4606      	mov	r6, r0
34188b82:	f7fd faa1 	bl	341860c8 <LL_RCC_PLL3_GetP1>
34188b86:	4604      	mov	r4, r0
34188b88:	f7fd faae 	bl	341860e8 <LL_RCC_PLL3_GetP2>
34188b8c:	4603      	mov	r3, r0
34188b8e:	9301      	str	r3, [sp, #4]
34188b90:	9400      	str	r4, [sp, #0]
34188b92:	4633      	mov	r3, r6
34188b94:	462a      	mov	r2, r5
34188b96:	6879      	ldr	r1, [r7, #4]
34188b98:	68b8      	ldr	r0, [r7, #8]
34188b9a:	f000 f8b7 	bl	34188d0c <RCCEx_CalcPLLFreq>
34188b9e:	60f8      	str	r0, [r7, #12]
34188ba0:	e00b      	b.n	34188bba <HAL_RCCEx_GetPLL3CLKFreq+0x82>
                                            LL_RCC_PLL3_GetP1(), LL_RCC_PLL3_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL3_IsEnabledBypass() != 0U)
34188ba2:	f7fd fa5d 	bl	34186060 <LL_RCC_PLL3_IsEnabledBypass>
34188ba6:	4603      	mov	r3, r0
34188ba8:	2b00      	cmp	r3, #0
34188baa:	d006      	beq.n	34188bba <HAL_RCCEx_GetPLL3CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34188bac:	f7fd fa36 	bl	3418601c <LL_RCC_PLL3_GetSource>
34188bb0:	4603      	mov	r3, r0
34188bb2:	4618      	mov	r0, r3
34188bb4:	f000 f84c 	bl	34188c50 <RCCEx_GetPLLSourceFreq>
34188bb8:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34188bba:	68fb      	ldr	r3, [r7, #12]
}
34188bbc:	4618      	mov	r0, r3
34188bbe:	3714      	adds	r7, #20
34188bc0:	46bd      	mov	sp, r7
34188bc2:	bdf0      	pop	{r4, r5, r6, r7, pc}

34188bc4 <HAL_RCCEx_GetPLL4CLKFreq>:
  * @brief  Return PLL4 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL4 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL4CLKFreq(void)
{
34188bc4:	b5f0      	push	{r4, r5, r6, r7, lr}
34188bc6:	b087      	sub	sp, #28
34188bc8:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34188bca:	2300      	movs	r3, #0
34188bcc:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL4_IsReady() != 0U)
34188bce:	f7fd facb 	bl	34186168 <LL_RCC_PLL4_IsReady>
34188bd2:	4603      	mov	r3, r0
34188bd4:	2b00      	cmp	r3, #0
34188bd6:	d02a      	beq.n	34188c2e <HAL_RCCEx_GetPLL4CLKFreq+0x6a>
  {
    if (LL_RCC_PLL4P_IsEnabled() != 0U)
34188bd8:	f7fd fb2e 	bl	34186238 <LL_RCC_PLL4P_IsEnabled>
34188bdc:	4603      	mov	r3, r0
34188bde:	2b00      	cmp	r3, #0
34188be0:	d031      	beq.n	34188c46 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34188be2:	f7fd fab3 	bl	3418614c <LL_RCC_PLL4_GetSource>
34188be6:	4603      	mov	r3, r0
34188be8:	4618      	mov	r0, r3
34188bea:	f000 f831 	bl	34188c50 <RCCEx_GetPLLSourceFreq>
34188bee:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34188bf0:	68bb      	ldr	r3, [r7, #8]
34188bf2:	2b00      	cmp	r3, #0
34188bf4:	d027      	beq.n	34188c46 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
      {

        divm = LL_RCC_PLL4_GetM();
34188bf6:	f7fd faef 	bl	341861d8 <LL_RCC_PLL4_GetM>
34188bfa:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34188bfc:	687b      	ldr	r3, [r7, #4]
34188bfe:	2b00      	cmp	r3, #0
34188c00:	d021      	beq.n	34188c46 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
34188c02:	f7fd fad9 	bl	341861b8 <LL_RCC_PLL4_GetN>
34188c06:	4605      	mov	r5, r0
34188c08:	f7fd fb2a 	bl	34186260 <LL_RCC_PLL4_GetFRACN>
34188c0c:	4606      	mov	r6, r0
34188c0e:	f7fd faf3 	bl	341861f8 <LL_RCC_PLL4_GetP1>
34188c12:	4604      	mov	r4, r0
34188c14:	f7fd fb00 	bl	34186218 <LL_RCC_PLL4_GetP2>
34188c18:	4603      	mov	r3, r0
34188c1a:	9301      	str	r3, [sp, #4]
34188c1c:	9400      	str	r4, [sp, #0]
34188c1e:	4633      	mov	r3, r6
34188c20:	462a      	mov	r2, r5
34188c22:	6879      	ldr	r1, [r7, #4]
34188c24:	68b8      	ldr	r0, [r7, #8]
34188c26:	f000 f871 	bl	34188d0c <RCCEx_CalcPLLFreq>
34188c2a:	60f8      	str	r0, [r7, #12]
34188c2c:	e00b      	b.n	34188c46 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
                                            LL_RCC_PLL4_GetP1(), LL_RCC_PLL4_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL4_IsEnabledBypass() != 0U)
34188c2e:	f7fd faaf 	bl	34186190 <LL_RCC_PLL4_IsEnabledBypass>
34188c32:	4603      	mov	r3, r0
34188c34:	2b00      	cmp	r3, #0
34188c36:	d006      	beq.n	34188c46 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34188c38:	f7fd fa88 	bl	3418614c <LL_RCC_PLL4_GetSource>
34188c3c:	4603      	mov	r3, r0
34188c3e:	4618      	mov	r0, r3
34188c40:	f000 f806 	bl	34188c50 <RCCEx_GetPLLSourceFreq>
34188c44:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34188c46:	68fb      	ldr	r3, [r7, #12]
}
34188c48:	4618      	mov	r0, r3
34188c4a:	3714      	adds	r7, #20
34188c4c:	46bd      	mov	sp, r7
34188c4e:	bdf0      	pop	{r4, r5, r6, r7, pc}

34188c50 <RCCEx_GetPLLSourceFreq>:
  * @brief  Return PLL source clock frequency
  * @param  PLLsource PLL source clock
  * @retval PLL source clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
34188c50:	b580      	push	{r7, lr}
34188c52:	b084      	sub	sp, #16
34188c54:	af00      	add	r7, sp, #0
34188c56:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
34188c58:	2300      	movs	r3, #0
34188c5a:	60fb      	str	r3, [r7, #12]

  switch (PLLsource)
34188c5c:	687b      	ldr	r3, [r7, #4]
34188c5e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34188c62:	d039      	beq.n	34188cd8 <RCCEx_GetPLLSourceFreq+0x88>
34188c64:	687b      	ldr	r3, [r7, #4]
34188c66:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34188c6a:	d838      	bhi.n	34188cde <RCCEx_GetPLLSourceFreq+0x8e>
34188c6c:	687b      	ldr	r3, [r7, #4]
34188c6e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34188c72:	d029      	beq.n	34188cc8 <RCCEx_GetPLLSourceFreq+0x78>
34188c74:	687b      	ldr	r3, [r7, #4]
34188c76:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34188c7a:	d830      	bhi.n	34188cde <RCCEx_GetPLLSourceFreq+0x8e>
34188c7c:	687b      	ldr	r3, [r7, #4]
34188c7e:	2b00      	cmp	r3, #0
34188c80:	d004      	beq.n	34188c8c <RCCEx_GetPLLSourceFreq+0x3c>
34188c82:	687b      	ldr	r3, [r7, #4]
34188c84:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34188c88:	d00e      	beq.n	34188ca8 <RCCEx_GetPLLSourceFreq+0x58>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
      break;

    default:
      /* unexpected case */
      break;
34188c8a:	e028      	b.n	34188cde <RCCEx_GetPLLSourceFreq+0x8e>
      if (LL_RCC_HSI_IsReady() != 0U)
34188c8c:	f7fc fe26 	bl	341858dc <LL_RCC_HSI_IsReady>
34188c90:	4603      	mov	r3, r0
34188c92:	2b00      	cmp	r3, #0
34188c94:	d025      	beq.n	34188ce2 <RCCEx_GetPLLSourceFreq+0x92>
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34188c96:	f7fc fe33 	bl	34185900 <LL_RCC_HSI_GetDivider>
34188c9a:	4603      	mov	r3, r0
34188c9c:	09db      	lsrs	r3, r3, #7
34188c9e:	4a16      	ldr	r2, [pc, #88]	@ (34188cf8 <RCCEx_GetPLLSourceFreq+0xa8>)
34188ca0:	fa22 f303 	lsr.w	r3, r2, r3
34188ca4:	60fb      	str	r3, [r7, #12]
      break;
34188ca6:	e01c      	b.n	34188ce2 <RCCEx_GetPLLSourceFreq+0x92>
      if (LL_RCC_MSI_IsReady() != 0U)
34188ca8:	f7fc fe38 	bl	3418591c <LL_RCC_MSI_IsReady>
34188cac:	4603      	mov	r3, r0
34188cae:	2b00      	cmp	r3, #0
34188cb0:	d019      	beq.n	34188ce6 <RCCEx_GetPLLSourceFreq+0x96>
        if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
34188cb2:	f7fc fe45 	bl	34185940 <LL_RCC_MSI_GetFrequency>
34188cb6:	4603      	mov	r3, r0
34188cb8:	2b00      	cmp	r3, #0
34188cba:	d102      	bne.n	34188cc2 <RCCEx_GetPLLSourceFreq+0x72>
          pllinputfreq = MSI_VALUE;
34188cbc:	4b0f      	ldr	r3, [pc, #60]	@ (34188cfc <RCCEx_GetPLLSourceFreq+0xac>)
34188cbe:	60fb      	str	r3, [r7, #12]
      break;
34188cc0:	e011      	b.n	34188ce6 <RCCEx_GetPLLSourceFreq+0x96>
          pllinputfreq = 16000000UL;
34188cc2:	4b0f      	ldr	r3, [pc, #60]	@ (34188d00 <RCCEx_GetPLLSourceFreq+0xb0>)
34188cc4:	60fb      	str	r3, [r7, #12]
      break;
34188cc6:	e00e      	b.n	34188ce6 <RCCEx_GetPLLSourceFreq+0x96>
      if (LL_RCC_HSE_IsReady() != 0U)
34188cc8:	f7fc fdf6 	bl	341858b8 <LL_RCC_HSE_IsReady>
34188ccc:	4603      	mov	r3, r0
34188cce:	2b00      	cmp	r3, #0
34188cd0:	d00b      	beq.n	34188cea <RCCEx_GetPLLSourceFreq+0x9a>
        pllinputfreq = HSE_VALUE;
34188cd2:	4b0c      	ldr	r3, [pc, #48]	@ (34188d04 <RCCEx_GetPLLSourceFreq+0xb4>)
34188cd4:	60fb      	str	r3, [r7, #12]
      break;
34188cd6:	e008      	b.n	34188cea <RCCEx_GetPLLSourceFreq+0x9a>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
34188cd8:	4b0b      	ldr	r3, [pc, #44]	@ (34188d08 <RCCEx_GetPLLSourceFreq+0xb8>)
34188cda:	60fb      	str	r3, [r7, #12]
      break;
34188cdc:	e006      	b.n	34188cec <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34188cde:	bf00      	nop
34188ce0:	e004      	b.n	34188cec <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34188ce2:	bf00      	nop
34188ce4:	e002      	b.n	34188cec <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34188ce6:	bf00      	nop
34188ce8:	e000      	b.n	34188cec <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34188cea:	bf00      	nop
  }

  return pllinputfreq;
34188cec:	68fb      	ldr	r3, [r7, #12]
}
34188cee:	4618      	mov	r0, r3
34188cf0:	3710      	adds	r7, #16
34188cf2:	46bd      	mov	sp, r7
34188cf4:	bd80      	pop	{r7, pc}
34188cf6:	bf00      	nop
34188cf8:	03d09000 	.word	0x03d09000
34188cfc:	003d0900 	.word	0x003d0900
34188d00:	00f42400 	.word	0x00f42400
34188d04:	02dc6c00 	.word	0x02dc6c00
34188d08:	00bb8000 	.word	0x00bb8000

34188d0c <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
34188d0c:	b480      	push	{r7}
34188d0e:	b087      	sub	sp, #28
34188d10:	af00      	add	r7, sp, #0
34188d12:	60f8      	str	r0, [r7, #12]
34188d14:	60b9      	str	r1, [r7, #8]
34188d16:	607a      	str	r2, [r7, #4]
34188d18:	603b      	str	r3, [r7, #0]
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
34188d1a:	68fb      	ldr	r3, [r7, #12]
34188d1c:	ee07 3a90 	vmov	s15, r3
34188d20:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34188d24:	687b      	ldr	r3, [r7, #4]
34188d26:	ee07 3a90 	vmov	s15, r3
34188d2a:	eef8 6a67 	vcvt.f32.u32	s13, s15
34188d2e:	683b      	ldr	r3, [r7, #0]
34188d30:	ee07 3a90 	vmov	s15, r3
34188d34:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34188d38:	eddf 5a19 	vldr	s11, [pc, #100]	@ 34188da0 <RCCEx_CalcPLLFreq+0x94>
34188d3c:	eec6 7a25 	vdiv.f32	s15, s12, s11
34188d40:	ee76 7aa7 	vadd.f32	s15, s13, s15
34188d44:	ee67 6a27 	vmul.f32	s13, s14, s15
34188d48:	68bb      	ldr	r3, [r7, #8]
34188d4a:	ee07 3a90 	vmov	s15, r3
34188d4e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34188d52:	eec6 7a87 	vdiv.f32	s15, s13, s14
34188d56:	edc7 7a05 	vstr	s15, [r7, #20]

  freq = freq / (float_t)P1;
34188d5a:	6a3b      	ldr	r3, [r7, #32]
34188d5c:	ee07 3a90 	vmov	s15, r3
34188d60:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34188d64:	edd7 6a05 	vldr	s13, [r7, #20]
34188d68:	eec6 7a87 	vdiv.f32	s15, s13, s14
34188d6c:	edc7 7a05 	vstr	s15, [r7, #20]
  freq = freq / (float_t)P2;
34188d70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188d72:	ee07 3a90 	vmov	s15, r3
34188d76:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34188d7a:	edd7 6a05 	vldr	s13, [r7, #20]
34188d7e:	eec6 7a87 	vdiv.f32	s15, s13, s14
34188d82:	edc7 7a05 	vstr	s15, [r7, #20]

  return (uint32_t)freq;
34188d86:	edd7 7a05 	vldr	s15, [r7, #20]
34188d8a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34188d8e:	ee17 3a90 	vmov	r3, s15
}
34188d92:	4618      	mov	r0, r3
34188d94:	371c      	adds	r7, #28
34188d96:	46bd      	mov	sp, r7
34188d98:	f85d 7b04 	ldr.w	r7, [sp], #4
34188d9c:	4770      	bx	lr
34188d9e:	bf00      	nop
34188da0:	4b800000 	.word	0x4b800000

34188da4 <HAL_RIF_RIMC_ConfigMasterAttributes>:
  *         This parameter can be one of @ref RIF_MASTER_INDEX
  * @param  pConfig Pointer on Master Isolation configuration structure
  * @retval None
  */
void HAL_RIF_RIMC_ConfigMasterAttributes(uint32_t MasterId, const RIMC_MasterConfig_t *pConfig)
{
34188da4:	b480      	push	{r7}
34188da6:	b089      	sub	sp, #36	@ 0x24
34188da8:	af00      	add	r7, sp, #0
34188daa:	6078      	str	r0, [r7, #4]
34188dac:	6039      	str	r1, [r7, #0]
  assert_param(IS_RIF_MASTER_INDEX(MasterId));
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
  assert_param(IS_RIF_MASTER_CID(pConfig->MasterCID));
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(pConfig->SecPriv));

  master_cid = POSITION_VAL(pConfig->MasterCID);
34188dae:	683b      	ldr	r3, [r7, #0]
34188db0:	681b      	ldr	r3, [r3, #0]
34188db2:	613b      	str	r3, [r7, #16]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
34188db4:	693b      	ldr	r3, [r7, #16]
34188db6:	fa93 f3a3 	rbit	r3, r3
34188dba:	60fb      	str	r3, [r7, #12]
  return result;
34188dbc:	68fb      	ldr	r3, [r7, #12]
34188dbe:	617b      	str	r3, [r7, #20]
  if (value == 0U)
34188dc0:	697b      	ldr	r3, [r7, #20]
34188dc2:	2b00      	cmp	r3, #0
34188dc4:	d101      	bne.n	34188dca <HAL_RIF_RIMC_ConfigMasterAttributes+0x26>
    return 32U;
34188dc6:	2320      	movs	r3, #32
34188dc8:	e003      	b.n	34188dd2 <HAL_RIF_RIMC_ConfigMasterAttributes+0x2e>
  return __builtin_clz(value);
34188dca:	697b      	ldr	r3, [r7, #20]
34188dcc:	fab3 f383 	clz	r3, r3
34188dd0:	b2db      	uxtb	r3, r3
34188dd2:	61fb      	str	r3, [r7, #28]
  rimc_attr_val = RIFSC->RIMC_ATTRx[MasterId];
34188dd4:	4a10      	ldr	r2, [pc, #64]	@ (34188e18 <HAL_RIF_RIMC_ConfigMasterAttributes+0x74>)
34188dd6:	687b      	ldr	r3, [r7, #4]
34188dd8:	f503 7341 	add.w	r3, r3, #772	@ 0x304
34188ddc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34188de0:	61bb      	str	r3, [r7, #24]
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
34188de2:	69bb      	ldr	r3, [r7, #24]
34188de4:	f423 735c 	bic.w	r3, r3, #880	@ 0x370
34188de8:	61bb      	str	r3, [r7, #24]
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
34188dea:	69fb      	ldr	r3, [r7, #28]
34188dec:	011a      	lsls	r2, r3, #4
34188dee:	683b      	ldr	r3, [r7, #0]
34188df0:	685b      	ldr	r3, [r3, #4]
34188df2:	021b      	lsls	r3, r3, #8
34188df4:	4313      	orrs	r3, r2
34188df6:	69ba      	ldr	r2, [r7, #24]
34188df8:	4313      	orrs	r3, r2
34188dfa:	61bb      	str	r3, [r7, #24]
  RIFSC->RIMC_ATTRx[MasterId] = rimc_attr_val;
34188dfc:	4906      	ldr	r1, [pc, #24]	@ (34188e18 <HAL_RIF_RIMC_ConfigMasterAttributes+0x74>)
34188dfe:	687b      	ldr	r3, [r7, #4]
34188e00:	f503 7341 	add.w	r3, r3, #772	@ 0x304
34188e04:	69ba      	ldr	r2, [r7, #24]
34188e06:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
34188e0a:	bf00      	nop
34188e0c:	3724      	adds	r7, #36	@ 0x24
34188e0e:	46bd      	mov	sp, r7
34188e10:	f85d 7b04 	ldr.w	r7, [sp], #4
34188e14:	4770      	bx	lr
34188e16:	bf00      	nop
34188e18:	54024000 	.word	0x54024000

34188e1c <HAL_RIF_RISC_SetSlaveSecureAttributes>:
  * @param  SecPriv specifies the security and privilege attributes of the peripheral.
  *         This parameter can be one or a combination of @ref RIF_SEC_PRIV
  * @retval None
  */
void HAL_RIF_RISC_SetSlaveSecureAttributes(uint32_t PeriphId, uint32_t SecPriv)
{
34188e1c:	b480      	push	{r7}
34188e1e:	b085      	sub	sp, #20
34188e20:	af00      	add	r7, sp, #0
34188e22:	6078      	str	r0, [r7, #4]
34188e24:	6039      	str	r1, [r7, #0]
  __IO uint32_t sec_reg_val;

  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(SecPriv));

  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
34188e26:	4a25      	ldr	r2, [pc, #148]	@ (34188ebc <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
34188e28:	687b      	ldr	r3, [r7, #4]
34188e2a:	0f1b      	lsrs	r3, r3, #28
34188e2c:	3304      	adds	r3, #4
34188e2e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34188e32:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
34188e34:	687b      	ldr	r3, [r7, #4]
34188e36:	f003 031f 	and.w	r3, r3, #31
34188e3a:	2201      	movs	r2, #1
34188e3c:	fa02 f303 	lsl.w	r3, r2, r3
34188e40:	43da      	mvns	r2, r3
34188e42:	68fb      	ldr	r3, [r7, #12]
34188e44:	4013      	ands	r3, r2
34188e46:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= ((SecPriv & RIF_ATTRIBUTE_SEC) << (PeriphId & RIF_PERIPH_BIT_POSITION));
34188e48:	683b      	ldr	r3, [r7, #0]
34188e4a:	f003 0201 	and.w	r2, r3, #1
34188e4e:	687b      	ldr	r3, [r7, #4]
34188e50:	f003 031f 	and.w	r3, r3, #31
34188e54:	409a      	lsls	r2, r3
34188e56:	68fb      	ldr	r3, [r7, #12]
34188e58:	4313      	orrs	r3, r2
34188e5a:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
34188e5c:	4917      	ldr	r1, [pc, #92]	@ (34188ebc <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
34188e5e:	687b      	ldr	r3, [r7, #4]
34188e60:	0f1b      	lsrs	r3, r3, #28
34188e62:	68fa      	ldr	r2, [r7, #12]
34188e64:	3304      	adds	r3, #4
34188e66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
34188e6a:	4a14      	ldr	r2, [pc, #80]	@ (34188ebc <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
34188e6c:	687b      	ldr	r3, [r7, #4]
34188e6e:	0f1b      	lsrs	r3, r3, #28
34188e70:	330c      	adds	r3, #12
34188e72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34188e76:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
34188e78:	687b      	ldr	r3, [r7, #4]
34188e7a:	f003 031f 	and.w	r3, r3, #31
34188e7e:	2201      	movs	r2, #1
34188e80:	fa02 f303 	lsl.w	r3, r2, r3
34188e84:	43da      	mvns	r2, r3
34188e86:	68fb      	ldr	r3, [r7, #12]
34188e88:	4013      	ands	r3, r2
34188e8a:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
34188e8c:	683b      	ldr	r3, [r7, #0]
34188e8e:	085b      	lsrs	r3, r3, #1
34188e90:	f003 0201 	and.w	r2, r3, #1
34188e94:	687b      	ldr	r3, [r7, #4]
34188e96:	f003 031f 	and.w	r3, r3, #31
34188e9a:	409a      	lsls	r2, r3
34188e9c:	68fb      	ldr	r3, [r7, #12]
34188e9e:	4313      	orrs	r3, r2
34188ea0:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
34188ea2:	4906      	ldr	r1, [pc, #24]	@ (34188ebc <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
34188ea4:	687b      	ldr	r3, [r7, #4]
34188ea6:	0f1b      	lsrs	r3, r3, #28
34188ea8:	68fa      	ldr	r2, [r7, #12]
34188eaa:	330c      	adds	r3, #12
34188eac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
34188eb0:	bf00      	nop
34188eb2:	3714      	adds	r7, #20
34188eb4:	46bd      	mov	sp, r7
34188eb6:	f85d 7b04 	ldr.w	r7, [sp], #4
34188eba:	4770      	bx	lr
34188ebc:	54024000 	.word	0x54024000

34188ec0 <UTIL_LCD_SetFuncDriver>:
/**
  * @brief  Link board LCD drivers to STM32 LCD Utility drivers
  * @param  pDrv Structure of LCD functions
  */
void UTIL_LCD_SetFuncDriver(const LCD_UTILS_Drv_t *pDrv)
{
34188ec0:	b580      	push	{r7, lr}
34188ec2:	b082      	sub	sp, #8
34188ec4:	af00      	add	r7, sp, #0
34188ec6:	6078      	str	r0, [r7, #4]
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
34188ec8:	687b      	ldr	r3, [r7, #4]
34188eca:	681b      	ldr	r3, [r3, #0]
34188ecc:	4a2b      	ldr	r2, [pc, #172]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188ece:	6013      	str	r3, [r2, #0]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
34188ed0:	687b      	ldr	r3, [r7, #4]
34188ed2:	685b      	ldr	r3, [r3, #4]
34188ed4:	4a29      	ldr	r2, [pc, #164]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188ed6:	6053      	str	r3, [r2, #4]
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
34188ed8:	687b      	ldr	r3, [r7, #4]
34188eda:	689b      	ldr	r3, [r3, #8]
34188edc:	4a27      	ldr	r2, [pc, #156]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188ede:	6093      	str	r3, [r2, #8]
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
34188ee0:	687b      	ldr	r3, [r7, #4]
34188ee2:	68db      	ldr	r3, [r3, #12]
34188ee4:	4a25      	ldr	r2, [pc, #148]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188ee6:	60d3      	str	r3, [r2, #12]
  FuncDriver.FillRect       = pDrv->FillRect;
34188ee8:	687b      	ldr	r3, [r7, #4]
34188eea:	691b      	ldr	r3, [r3, #16]
34188eec:	4a23      	ldr	r2, [pc, #140]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188eee:	6113      	str	r3, [r2, #16]
  FuncDriver.GetPixel       = pDrv->GetPixel;
34188ef0:	687b      	ldr	r3, [r7, #4]
34188ef2:	695b      	ldr	r3, [r3, #20]
34188ef4:	4a21      	ldr	r2, [pc, #132]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188ef6:	6153      	str	r3, [r2, #20]
  FuncDriver.SetPixel       = pDrv->SetPixel;
34188ef8:	687b      	ldr	r3, [r7, #4]
34188efa:	699b      	ldr	r3, [r3, #24]
34188efc:	4a1f      	ldr	r2, [pc, #124]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188efe:	6193      	str	r3, [r2, #24]
  FuncDriver.GetXSize       = pDrv->GetXSize;
34188f00:	687b      	ldr	r3, [r7, #4]
34188f02:	69db      	ldr	r3, [r3, #28]
34188f04:	4a1d      	ldr	r2, [pc, #116]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188f06:	61d3      	str	r3, [r2, #28]
  FuncDriver.GetYSize       = pDrv->GetYSize;
34188f08:	687b      	ldr	r3, [r7, #4]
34188f0a:	6a1b      	ldr	r3, [r3, #32]
34188f0c:	4a1b      	ldr	r2, [pc, #108]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188f0e:	6213      	str	r3, [r2, #32]
  FuncDriver.SetLayer       = pDrv->SetLayer;
34188f10:	687b      	ldr	r3, [r7, #4]
34188f12:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34188f14:	4a19      	ldr	r2, [pc, #100]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188f16:	6253      	str	r3, [r2, #36]	@ 0x24
  FuncDriver.GetFormat      = pDrv->GetFormat;
34188f18:	687b      	ldr	r3, [r7, #4]
34188f1a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34188f1c:	4a17      	ldr	r2, [pc, #92]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188f1e:	6293      	str	r3, [r2, #40]	@ 0x28

  DrawProp->LcdLayer = 0;
34188f20:	4b17      	ldr	r3, [pc, #92]	@ (34188f80 <UTIL_LCD_SetFuncDriver+0xc0>)
34188f22:	2200      	movs	r2, #0
34188f24:	60da      	str	r2, [r3, #12]
  DrawProp->LcdDevice = 0;
34188f26:	4b16      	ldr	r3, [pc, #88]	@ (34188f80 <UTIL_LCD_SetFuncDriver+0xc0>)
34188f28:	2200      	movs	r2, #0
34188f2a:	611a      	str	r2, [r3, #16]
  FuncDriver.GetXSize(0, &DrawProp[DrawProp->LcdLayer].LcdXsize);
34188f2c:	4b13      	ldr	r3, [pc, #76]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188f2e:	69db      	ldr	r3, [r3, #28]
34188f30:	4a13      	ldr	r2, [pc, #76]	@ (34188f80 <UTIL_LCD_SetFuncDriver+0xc0>)
34188f32:	68d2      	ldr	r2, [r2, #12]
34188f34:	0152      	lsls	r2, r2, #5
34188f36:	3210      	adds	r2, #16
34188f38:	4911      	ldr	r1, [pc, #68]	@ (34188f80 <UTIL_LCD_SetFuncDriver+0xc0>)
34188f3a:	440a      	add	r2, r1
34188f3c:	3204      	adds	r2, #4
34188f3e:	4611      	mov	r1, r2
34188f40:	2000      	movs	r0, #0
34188f42:	4798      	blx	r3
  FuncDriver.GetYSize(0, &DrawProp[DrawProp->LcdLayer].LcdYsize);
34188f44:	4b0d      	ldr	r3, [pc, #52]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188f46:	6a1b      	ldr	r3, [r3, #32]
34188f48:	4a0d      	ldr	r2, [pc, #52]	@ (34188f80 <UTIL_LCD_SetFuncDriver+0xc0>)
34188f4a:	68d2      	ldr	r2, [r2, #12]
34188f4c:	0152      	lsls	r2, r2, #5
34188f4e:	3218      	adds	r2, #24
34188f50:	490b      	ldr	r1, [pc, #44]	@ (34188f80 <UTIL_LCD_SetFuncDriver+0xc0>)
34188f52:	440a      	add	r2, r1
34188f54:	4611      	mov	r1, r2
34188f56:	2000      	movs	r0, #0
34188f58:	4798      	blx	r3
  FuncDriver.GetFormat(0, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
34188f5a:	4b08      	ldr	r3, [pc, #32]	@ (34188f7c <UTIL_LCD_SetFuncDriver+0xbc>)
34188f5c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34188f5e:	4a08      	ldr	r2, [pc, #32]	@ (34188f80 <UTIL_LCD_SetFuncDriver+0xc0>)
34188f60:	68d2      	ldr	r2, [r2, #12]
34188f62:	0152      	lsls	r2, r2, #5
34188f64:	3218      	adds	r2, #24
34188f66:	4906      	ldr	r1, [pc, #24]	@ (34188f80 <UTIL_LCD_SetFuncDriver+0xc0>)
34188f68:	440a      	add	r2, r1
34188f6a:	3204      	adds	r2, #4
34188f6c:	4611      	mov	r1, r2
34188f6e:	2000      	movs	r0, #0
34188f70:	4798      	blx	r3
}
34188f72:	bf00      	nop
34188f74:	3708      	adds	r7, #8
34188f76:	46bd      	mov	sp, r7
34188f78:	bd80      	pop	{r7, pc}
34188f7a:	bf00      	nop
34188f7c:	341c01c0 	.word	0x341c01c0
34188f80:	341c0180 	.word	0x341c0180

34188f84 <UTIL_LCD_SetTextColor>:
/**
  * @brief  Sets the LCD text color.
  * @param  Color  Text color code
  */
void UTIL_LCD_SetTextColor(uint32_t Color)
{
34188f84:	b480      	push	{r7}
34188f86:	b083      	sub	sp, #12
34188f88:	af00      	add	r7, sp, #0
34188f8a:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].TextColor = Color;
34188f8c:	4b06      	ldr	r3, [pc, #24]	@ (34188fa8 <UTIL_LCD_SetTextColor+0x24>)
34188f8e:	68db      	ldr	r3, [r3, #12]
34188f90:	4a05      	ldr	r2, [pc, #20]	@ (34188fa8 <UTIL_LCD_SetTextColor+0x24>)
34188f92:	015b      	lsls	r3, r3, #5
34188f94:	4413      	add	r3, r2
34188f96:	687a      	ldr	r2, [r7, #4]
34188f98:	601a      	str	r2, [r3, #0]
}
34188f9a:	bf00      	nop
34188f9c:	370c      	adds	r7, #12
34188f9e:	46bd      	mov	sp, r7
34188fa0:	f85d 7b04 	ldr.w	r7, [sp], #4
34188fa4:	4770      	bx	lr
34188fa6:	bf00      	nop
34188fa8:	341c0180 	.word	0x341c0180

34188fac <UTIL_LCD_SetBackColor>:
/**
  * @brief  Sets the LCD background color.
  * @param  Color  Layer background color code
  */
void UTIL_LCD_SetBackColor(uint32_t Color)
{
34188fac:	b480      	push	{r7}
34188fae:	b083      	sub	sp, #12
34188fb0:	af00      	add	r7, sp, #0
34188fb2:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].BackColor = Color;
34188fb4:	4b06      	ldr	r3, [pc, #24]	@ (34188fd0 <UTIL_LCD_SetBackColor+0x24>)
34188fb6:	68db      	ldr	r3, [r3, #12]
34188fb8:	4a05      	ldr	r2, [pc, #20]	@ (34188fd0 <UTIL_LCD_SetBackColor+0x24>)
34188fba:	015b      	lsls	r3, r3, #5
34188fbc:	4413      	add	r3, r2
34188fbe:	3304      	adds	r3, #4
34188fc0:	687a      	ldr	r2, [r7, #4]
34188fc2:	601a      	str	r2, [r3, #0]
}
34188fc4:	bf00      	nop
34188fc6:	370c      	adds	r7, #12
34188fc8:	46bd      	mov	sp, r7
34188fca:	f85d 7b04 	ldr.w	r7, [sp], #4
34188fce:	4770      	bx	lr
34188fd0:	341c0180 	.word	0x341c0180

34188fd4 <UTIL_LCD_SetFont>:
/**
  * @brief  Sets the LCD text font.
  * @param  fonts  Layer font to be used
  */
void UTIL_LCD_SetFont(sFONT *fonts)
{
34188fd4:	b480      	push	{r7}
34188fd6:	b083      	sub	sp, #12
34188fd8:	af00      	add	r7, sp, #0
34188fda:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].pFont = fonts;
34188fdc:	4b06      	ldr	r3, [pc, #24]	@ (34188ff8 <UTIL_LCD_SetFont+0x24>)
34188fde:	68db      	ldr	r3, [r3, #12]
34188fe0:	4a05      	ldr	r2, [pc, #20]	@ (34188ff8 <UTIL_LCD_SetFont+0x24>)
34188fe2:	015b      	lsls	r3, r3, #5
34188fe4:	4413      	add	r3, r2
34188fe6:	3308      	adds	r3, #8
34188fe8:	687a      	ldr	r2, [r7, #4]
34188fea:	601a      	str	r2, [r3, #0]
}
34188fec:	bf00      	nop
34188fee:	370c      	adds	r7, #12
34188ff0:	46bd      	mov	sp, r7
34188ff2:	f85d 7b04 	ldr.w	r7, [sp], #4
34188ff6:	4770      	bx	lr
34188ff8:	341c0180 	.word	0x341c0180

34188ffc <UTIL_LCD_FillRGBRect>:
  * @param  Xpos    X position
  * @param  Ypos    Y position
  * @param  Length  Line length
  */
void UTIL_LCD_FillRGBRect(uint32_t Xpos, uint32_t Ypos, uint8_t *pData, uint32_t Width, uint32_t Height)
{
34188ffc:	b590      	push	{r4, r7, lr}
34188ffe:	b087      	sub	sp, #28
34189000:	af02      	add	r7, sp, #8
34189002:	60f8      	str	r0, [r7, #12]
34189004:	60b9      	str	r1, [r7, #8]
34189006:	607a      	str	r2, [r7, #4]
34189008:	603b      	str	r3, [r7, #0]
  /* Write RGB rectangle data */
  FuncDriver.FillRGBRect(DrawProp->LcdDevice, Xpos, Ypos, pData, Width, Height);
3418900a:	4b08      	ldr	r3, [pc, #32]	@ (3418902c <UTIL_LCD_FillRGBRect+0x30>)
3418900c:	685c      	ldr	r4, [r3, #4]
3418900e:	4b08      	ldr	r3, [pc, #32]	@ (34189030 <UTIL_LCD_FillRGBRect+0x34>)
34189010:	6918      	ldr	r0, [r3, #16]
34189012:	6a3b      	ldr	r3, [r7, #32]
34189014:	9301      	str	r3, [sp, #4]
34189016:	683b      	ldr	r3, [r7, #0]
34189018:	9300      	str	r3, [sp, #0]
3418901a:	687b      	ldr	r3, [r7, #4]
3418901c:	68ba      	ldr	r2, [r7, #8]
3418901e:	68f9      	ldr	r1, [r7, #12]
34189020:	47a0      	blx	r4
}
34189022:	bf00      	nop
34189024:	3714      	adds	r7, #20
34189026:	46bd      	mov	sp, r7
34189028:	bd90      	pop	{r4, r7, pc}
3418902a:	bf00      	nop
3418902c:	341c01c0 	.word	0x341c01c0
34189030:	341c0180 	.word	0x341c0180

34189034 <UTIL_LCD_Clear>:
/**
  * @brief  Clears the whole currently active layer of LTDC.
  * @param  Color  Color of the background
  */
void UTIL_LCD_Clear(uint32_t Color)
{
34189034:	b580      	push	{r7, lr}
34189036:	b084      	sub	sp, #16
34189038:	af02      	add	r7, sp, #8
3418903a:	6078      	str	r0, [r7, #4]
  /* Clear the LCD */
  UTIL_LCD_FillRect(0, 0, DrawProp[DrawProp->LcdLayer].LcdXsize, DrawProp[DrawProp->LcdLayer].LcdYsize, Color);
3418903c:	4b0c      	ldr	r3, [pc, #48]	@ (34189070 <UTIL_LCD_Clear+0x3c>)
3418903e:	68db      	ldr	r3, [r3, #12]
34189040:	4a0b      	ldr	r2, [pc, #44]	@ (34189070 <UTIL_LCD_Clear+0x3c>)
34189042:	015b      	lsls	r3, r3, #5
34189044:	4413      	add	r3, r2
34189046:	3314      	adds	r3, #20
34189048:	681a      	ldr	r2, [r3, #0]
3418904a:	4b09      	ldr	r3, [pc, #36]	@ (34189070 <UTIL_LCD_Clear+0x3c>)
3418904c:	68db      	ldr	r3, [r3, #12]
3418904e:	4908      	ldr	r1, [pc, #32]	@ (34189070 <UTIL_LCD_Clear+0x3c>)
34189050:	015b      	lsls	r3, r3, #5
34189052:	440b      	add	r3, r1
34189054:	3318      	adds	r3, #24
34189056:	6819      	ldr	r1, [r3, #0]
34189058:	687b      	ldr	r3, [r7, #4]
3418905a:	9300      	str	r3, [sp, #0]
3418905c:	460b      	mov	r3, r1
3418905e:	2100      	movs	r1, #0
34189060:	2000      	movs	r0, #0
34189062:	f000 f8f5 	bl	34189250 <UTIL_LCD_FillRect>
}
34189066:	bf00      	nop
34189068:	3708      	adds	r7, #8
3418906a:	46bd      	mov	sp, r7
3418906c:	bd80      	pop	{r7, pc}
3418906e:	bf00      	nop
34189070:	341c0180 	.word	0x341c0180

34189074 <UTIL_LCD_DisplayChar>:
  * @param  Ypos Line where to display the character shape.
  * @param  Ascii Character ascii code
  *           This parameter must be a number between Min_Data = 0x20 and Max_Data = 0x7E
  */
void UTIL_LCD_DisplayChar(uint32_t Xpos, uint32_t Ypos, uint8_t Ascii)
{
34189074:	b580      	push	{r7, lr}
34189076:	b084      	sub	sp, #16
34189078:	af00      	add	r7, sp, #0
3418907a:	60f8      	str	r0, [r7, #12]
3418907c:	60b9      	str	r1, [r7, #8]
3418907e:	4613      	mov	r3, r2
34189080:	71fb      	strb	r3, [r7, #7]
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
34189082:	4b16      	ldr	r3, [pc, #88]	@ (341890dc <UTIL_LCD_DisplayChar+0x68>)
34189084:	68db      	ldr	r3, [r3, #12]
34189086:	4a15      	ldr	r2, [pc, #84]	@ (341890dc <UTIL_LCD_DisplayChar+0x68>)
34189088:	015b      	lsls	r3, r3, #5
3418908a:	4413      	add	r3, r2
3418908c:	3308      	adds	r3, #8
3418908e:	681b      	ldr	r3, [r3, #0]
34189090:	681a      	ldr	r2, [r3, #0]
34189092:	79fb      	ldrb	r3, [r7, #7]
34189094:	3b20      	subs	r3, #32
  DrawProp[DrawProp->LcdLayer].pFont->Height * ((DrawProp[DrawProp->LcdLayer].pFont->Width + 7) / 8)]);
34189096:	4911      	ldr	r1, [pc, #68]	@ (341890dc <UTIL_LCD_DisplayChar+0x68>)
34189098:	68c9      	ldr	r1, [r1, #12]
3418909a:	4810      	ldr	r0, [pc, #64]	@ (341890dc <UTIL_LCD_DisplayChar+0x68>)
3418909c:	0149      	lsls	r1, r1, #5
3418909e:	4401      	add	r1, r0
341890a0:	3108      	adds	r1, #8
341890a2:	6809      	ldr	r1, [r1, #0]
341890a4:	88c9      	ldrh	r1, [r1, #6]
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
341890a6:	fb03 f101 	mul.w	r1, r3, r1
  DrawProp[DrawProp->LcdLayer].pFont->Height * ((DrawProp[DrawProp->LcdLayer].pFont->Width + 7) / 8)]);
341890aa:	4b0c      	ldr	r3, [pc, #48]	@ (341890dc <UTIL_LCD_DisplayChar+0x68>)
341890ac:	68db      	ldr	r3, [r3, #12]
341890ae:	480b      	ldr	r0, [pc, #44]	@ (341890dc <UTIL_LCD_DisplayChar+0x68>)
341890b0:	015b      	lsls	r3, r3, #5
341890b2:	4403      	add	r3, r0
341890b4:	3308      	adds	r3, #8
341890b6:	681b      	ldr	r3, [r3, #0]
341890b8:	889b      	ldrh	r3, [r3, #4]
341890ba:	3307      	adds	r3, #7
341890bc:	2b00      	cmp	r3, #0
341890be:	da00      	bge.n	341890c2 <UTIL_LCD_DisplayChar+0x4e>
341890c0:	3307      	adds	r3, #7
341890c2:	10db      	asrs	r3, r3, #3
341890c4:	fb01 f303 	mul.w	r3, r1, r3
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
341890c8:	4413      	add	r3, r2
341890ca:	461a      	mov	r2, r3
341890cc:	68b9      	ldr	r1, [r7, #8]
341890ce:	68f8      	ldr	r0, [r7, #12]
341890d0:	f000 f93e 	bl	34189350 <DrawChar>
}
341890d4:	bf00      	nop
341890d6:	3710      	adds	r7, #16
341890d8:	46bd      	mov	sp, r7
341890da:	bd80      	pop	{r7, pc}
341890dc:	341c0180 	.word	0x341c0180

341890e0 <UTIL_LCD_DisplayStringAt>:
  *            @arg  CENTER_MODE
  *            @arg  RIGHT_MODE
  *            @arg  LEFT_MODE
  */
void UTIL_LCD_DisplayStringAt(uint32_t Xpos, uint32_t Ypos, uint8_t *Text, Text_AlignModeTypdef Mode)
{
341890e0:	b580      	push	{r7, lr}
341890e2:	b08a      	sub	sp, #40	@ 0x28
341890e4:	af00      	add	r7, sp, #0
341890e6:	60f8      	str	r0, [r7, #12]
341890e8:	60b9      	str	r1, [r7, #8]
341890ea:	607a      	str	r2, [r7, #4]
341890ec:	70fb      	strb	r3, [r7, #3]
  uint32_t refcolumn = 1, i = 0;
341890ee:	2301      	movs	r3, #1
341890f0:	627b      	str	r3, [r7, #36]	@ 0x24
341890f2:	2300      	movs	r3, #0
341890f4:	623b      	str	r3, [r7, #32]
  uint32_t size = 0, xsize = 0;
341890f6:	2300      	movs	r3, #0
341890f8:	61fb      	str	r3, [r7, #28]
341890fa:	2300      	movs	r3, #0
341890fc:	617b      	str	r3, [r7, #20]
  uint8_t  *ptr = Text;
341890fe:	687b      	ldr	r3, [r7, #4]
34189100:	61bb      	str	r3, [r7, #24]

  /* Get the text size */
  while (*ptr++) size ++ ;
34189102:	e002      	b.n	3418910a <UTIL_LCD_DisplayStringAt+0x2a>
34189104:	69fb      	ldr	r3, [r7, #28]
34189106:	3301      	adds	r3, #1
34189108:	61fb      	str	r3, [r7, #28]
3418910a:	69bb      	ldr	r3, [r7, #24]
3418910c:	1c5a      	adds	r2, r3, #1
3418910e:	61ba      	str	r2, [r7, #24]
34189110:	781b      	ldrb	r3, [r3, #0]
34189112:	2b00      	cmp	r3, #0
34189114:	d1f6      	bne.n	34189104 <UTIL_LCD_DisplayStringAt+0x24>

  /* Characters number per line */
  xsize = (DrawProp[DrawProp->LcdLayer].LcdXsize/DrawProp[DrawProp->LcdLayer].pFont->Width);
34189116:	4b4d      	ldr	r3, [pc, #308]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
34189118:	68db      	ldr	r3, [r3, #12]
3418911a:	4a4c      	ldr	r2, [pc, #304]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
3418911c:	015b      	lsls	r3, r3, #5
3418911e:	4413      	add	r3, r2
34189120:	3314      	adds	r3, #20
34189122:	681b      	ldr	r3, [r3, #0]
34189124:	4a49      	ldr	r2, [pc, #292]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
34189126:	68d2      	ldr	r2, [r2, #12]
34189128:	4948      	ldr	r1, [pc, #288]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
3418912a:	0152      	lsls	r2, r2, #5
3418912c:	440a      	add	r2, r1
3418912e:	3208      	adds	r2, #8
34189130:	6812      	ldr	r2, [r2, #0]
34189132:	8892      	ldrh	r2, [r2, #4]
34189134:	fbb3 f3f2 	udiv	r3, r3, r2
34189138:	617b      	str	r3, [r7, #20]

  switch (Mode)
3418913a:	78fb      	ldrb	r3, [r7, #3]
3418913c:	2b03      	cmp	r3, #3
3418913e:	d018      	beq.n	34189172 <UTIL_LCD_DisplayStringAt+0x92>
34189140:	2b03      	cmp	r3, #3
34189142:	dc2a      	bgt.n	3418919a <UTIL_LCD_DisplayStringAt+0xba>
34189144:	2b01      	cmp	r3, #1
34189146:	d002      	beq.n	3418914e <UTIL_LCD_DisplayStringAt+0x6e>
34189148:	2b02      	cmp	r3, #2
3418914a:	d015      	beq.n	34189178 <UTIL_LCD_DisplayStringAt+0x98>
3418914c:	e025      	b.n	3418919a <UTIL_LCD_DisplayStringAt+0xba>
  {
  case CENTER_MODE:
    {
      refcolumn = Xpos + ((xsize - size)* DrawProp[DrawProp->LcdLayer].pFont->Width) / 2;
3418914e:	697a      	ldr	r2, [r7, #20]
34189150:	69fb      	ldr	r3, [r7, #28]
34189152:	1ad3      	subs	r3, r2, r3
34189154:	4a3d      	ldr	r2, [pc, #244]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
34189156:	68d2      	ldr	r2, [r2, #12]
34189158:	493c      	ldr	r1, [pc, #240]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
3418915a:	0152      	lsls	r2, r2, #5
3418915c:	440a      	add	r2, r1
3418915e:	3208      	adds	r2, #8
34189160:	6812      	ldr	r2, [r2, #0]
34189162:	8892      	ldrh	r2, [r2, #4]
34189164:	fb02 f303 	mul.w	r3, r2, r3
34189168:	085b      	lsrs	r3, r3, #1
3418916a:	68fa      	ldr	r2, [r7, #12]
3418916c:	4413      	add	r3, r2
3418916e:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
34189170:	e016      	b.n	341891a0 <UTIL_LCD_DisplayStringAt+0xc0>
    }
  case LEFT_MODE:
    {
      refcolumn = Xpos;
34189172:	68fb      	ldr	r3, [r7, #12]
34189174:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
34189176:	e013      	b.n	341891a0 <UTIL_LCD_DisplayStringAt+0xc0>
    }
  case RIGHT_MODE:
    {
      refcolumn = - Xpos + ((xsize - size)*DrawProp[DrawProp->LcdLayer].pFont->Width);
34189178:	697a      	ldr	r2, [r7, #20]
3418917a:	69fb      	ldr	r3, [r7, #28]
3418917c:	1ad3      	subs	r3, r2, r3
3418917e:	4a33      	ldr	r2, [pc, #204]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
34189180:	68d2      	ldr	r2, [r2, #12]
34189182:	4932      	ldr	r1, [pc, #200]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
34189184:	0152      	lsls	r2, r2, #5
34189186:	440a      	add	r2, r1
34189188:	3208      	adds	r2, #8
3418918a:	6812      	ldr	r2, [r2, #0]
3418918c:	8892      	ldrh	r2, [r2, #4]
3418918e:	fb03 f202 	mul.w	r2, r3, r2
34189192:	68fb      	ldr	r3, [r7, #12]
34189194:	1ad3      	subs	r3, r2, r3
34189196:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
34189198:	e002      	b.n	341891a0 <UTIL_LCD_DisplayStringAt+0xc0>
    }
  default:
    {
      refcolumn = Xpos;
3418919a:	68fb      	ldr	r3, [r7, #12]
3418919c:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
3418919e:	bf00      	nop
    }
  }

  /* Check that the Start column is located in the screen */
  if ((refcolumn < 1) || (refcolumn >= 0x8000))
341891a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341891a2:	2b00      	cmp	r3, #0
341891a4:	d003      	beq.n	341891ae <UTIL_LCD_DisplayStringAt+0xce>
341891a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341891a8:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
341891ac:	d31b      	bcc.n	341891e6 <UTIL_LCD_DisplayStringAt+0x106>
  {
    refcolumn = 1;
341891ae:	2301      	movs	r3, #1
341891b0:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* Send the string character by character on LCD */
  while ((*Text != 0) & (((DrawProp[DrawProp->LcdLayer].LcdXsize - (i*DrawProp[DrawProp->LcdLayer].pFont->Width)) & 0xFFFF) >= DrawProp[DrawProp->LcdLayer].pFont->Width))
341891b2:	e018      	b.n	341891e6 <UTIL_LCD_DisplayStringAt+0x106>
  {
    /* Display one character on LCD */
    UTIL_LCD_DisplayChar(refcolumn, Ypos, *Text);
341891b4:	687b      	ldr	r3, [r7, #4]
341891b6:	781b      	ldrb	r3, [r3, #0]
341891b8:	461a      	mov	r2, r3
341891ba:	68b9      	ldr	r1, [r7, #8]
341891bc:	6a78      	ldr	r0, [r7, #36]	@ 0x24
341891be:	f7ff ff59 	bl	34189074 <UTIL_LCD_DisplayChar>
    /* Decrement the column position by 16 */
    refcolumn += DrawProp[DrawProp->LcdLayer].pFont->Width;
341891c2:	4b22      	ldr	r3, [pc, #136]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
341891c4:	68db      	ldr	r3, [r3, #12]
341891c6:	4a21      	ldr	r2, [pc, #132]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
341891c8:	015b      	lsls	r3, r3, #5
341891ca:	4413      	add	r3, r2
341891cc:	3308      	adds	r3, #8
341891ce:	681b      	ldr	r3, [r3, #0]
341891d0:	889b      	ldrh	r3, [r3, #4]
341891d2:	461a      	mov	r2, r3
341891d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341891d6:	4413      	add	r3, r2
341891d8:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Point on the next character */
    Text++;
341891da:	687b      	ldr	r3, [r7, #4]
341891dc:	3301      	adds	r3, #1
341891de:	607b      	str	r3, [r7, #4]
    i++;
341891e0:	6a3b      	ldr	r3, [r7, #32]
341891e2:	3301      	adds	r3, #1
341891e4:	623b      	str	r3, [r7, #32]
  while ((*Text != 0) & (((DrawProp[DrawProp->LcdLayer].LcdXsize - (i*DrawProp[DrawProp->LcdLayer].pFont->Width)) & 0xFFFF) >= DrawProp[DrawProp->LcdLayer].pFont->Width))
341891e6:	687b      	ldr	r3, [r7, #4]
341891e8:	781b      	ldrb	r3, [r3, #0]
341891ea:	2b00      	cmp	r3, #0
341891ec:	bf14      	ite	ne
341891ee:	2301      	movne	r3, #1
341891f0:	2300      	moveq	r3, #0
341891f2:	b2da      	uxtb	r2, r3
341891f4:	4b15      	ldr	r3, [pc, #84]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
341891f6:	68db      	ldr	r3, [r3, #12]
341891f8:	4914      	ldr	r1, [pc, #80]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
341891fa:	015b      	lsls	r3, r3, #5
341891fc:	440b      	add	r3, r1
341891fe:	3314      	adds	r3, #20
34189200:	6819      	ldr	r1, [r3, #0]
34189202:	4b12      	ldr	r3, [pc, #72]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
34189204:	68db      	ldr	r3, [r3, #12]
34189206:	4811      	ldr	r0, [pc, #68]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
34189208:	015b      	lsls	r3, r3, #5
3418920a:	4403      	add	r3, r0
3418920c:	3308      	adds	r3, #8
3418920e:	681b      	ldr	r3, [r3, #0]
34189210:	889b      	ldrh	r3, [r3, #4]
34189212:	4618      	mov	r0, r3
34189214:	6a3b      	ldr	r3, [r7, #32]
34189216:	fb00 f303 	mul.w	r3, r0, r3
3418921a:	1acb      	subs	r3, r1, r3
3418921c:	b29b      	uxth	r3, r3
3418921e:	490b      	ldr	r1, [pc, #44]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
34189220:	68c9      	ldr	r1, [r1, #12]
34189222:	480a      	ldr	r0, [pc, #40]	@ (3418924c <UTIL_LCD_DisplayStringAt+0x16c>)
34189224:	0149      	lsls	r1, r1, #5
34189226:	4401      	add	r1, r0
34189228:	3108      	adds	r1, #8
3418922a:	6809      	ldr	r1, [r1, #0]
3418922c:	8889      	ldrh	r1, [r1, #4]
3418922e:	428b      	cmp	r3, r1
34189230:	bf2c      	ite	cs
34189232:	2301      	movcs	r3, #1
34189234:	2300      	movcc	r3, #0
34189236:	b2db      	uxtb	r3, r3
34189238:	4013      	ands	r3, r2
3418923a:	b2db      	uxtb	r3, r3
3418923c:	2b00      	cmp	r3, #0
3418923e:	d1b9      	bne.n	341891b4 <UTIL_LCD_DisplayStringAt+0xd4>
  }
}
34189240:	bf00      	nop
34189242:	bf00      	nop
34189244:	3728      	adds	r7, #40	@ 0x28
34189246:	46bd      	mov	sp, r7
34189248:	bd80      	pop	{r7, pc}
3418924a:	bf00      	nop
3418924c:	341c0180 	.word	0x341c0180

34189250 <UTIL_LCD_FillRect>:
  * @param  Width  Rectangle width
  * @param  Height Rectangle height
  * @param  Color  Draw color
  */
void UTIL_LCD_FillRect(uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
34189250:	b590      	push	{r4, r7, lr}
34189252:	b087      	sub	sp, #28
34189254:	af02      	add	r7, sp, #8
34189256:	60f8      	str	r0, [r7, #12]
34189258:	60b9      	str	r1, [r7, #8]
3418925a:	607a      	str	r2, [r7, #4]
3418925c:	603b      	str	r3, [r7, #0]
  /* Fill the rectangle */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3418925e:	4b3a      	ldr	r3, [pc, #232]	@ (34189348 <UTIL_LCD_FillRect+0xf8>)
34189260:	68db      	ldr	r3, [r3, #12]
34189262:	4a39      	ldr	r2, [pc, #228]	@ (34189348 <UTIL_LCD_FillRect+0xf8>)
34189264:	015b      	lsls	r3, r3, #5
34189266:	4413      	add	r3, r2
34189268:	331c      	adds	r3, #28
3418926a:	681b      	ldr	r3, [r3, #0]
3418926c:	2b02      	cmp	r3, #2
3418926e:	d11a      	bne.n	341892a6 <UTIL_LCD_FillRect+0x56>
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
34189270:	4b36      	ldr	r3, [pc, #216]	@ (3418934c <UTIL_LCD_FillRect+0xfc>)
34189272:	691c      	ldr	r4, [r3, #16]
34189274:	4b34      	ldr	r3, [pc, #208]	@ (34189348 <UTIL_LCD_FillRect+0xf8>)
34189276:	6918      	ldr	r0, [r3, #16]
34189278:	6a3b      	ldr	r3, [r7, #32]
3418927a:	08db      	lsrs	r3, r3, #3
3418927c:	f003 021f 	and.w	r2, r3, #31
34189280:	6a3b      	ldr	r3, [r7, #32]
34189282:	0a9b      	lsrs	r3, r3, #10
34189284:	015b      	lsls	r3, r3, #5
34189286:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
3418928a:	431a      	orrs	r2, r3
3418928c:	6a3b      	ldr	r3, [r7, #32]
3418928e:	0cdb      	lsrs	r3, r3, #19
34189290:	02db      	lsls	r3, r3, #11
34189292:	b29b      	uxth	r3, r3
34189294:	4313      	orrs	r3, r2
34189296:	9301      	str	r3, [sp, #4]
34189298:	683b      	ldr	r3, [r7, #0]
3418929a:	9300      	str	r3, [sp, #0]
3418929c:	687b      	ldr	r3, [r7, #4]
3418929e:	68ba      	ldr	r2, [r7, #8]
341892a0:	68f9      	ldr	r1, [r7, #12]
341892a2:	47a0      	blx	r4
  }
  else /*LCD_PIXEL_FORMAT_ARGB8888*/
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
  }
}
341892a4:	e04b      	b.n	3418933e <UTIL_LCD_FillRect+0xee>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
341892a6:	4b28      	ldr	r3, [pc, #160]	@ (34189348 <UTIL_LCD_FillRect+0xf8>)
341892a8:	68db      	ldr	r3, [r3, #12]
341892aa:	4a27      	ldr	r2, [pc, #156]	@ (34189348 <UTIL_LCD_FillRect+0xf8>)
341892ac:	015b      	lsls	r3, r3, #5
341892ae:	4413      	add	r3, r2
341892b0:	331c      	adds	r3, #28
341892b2:	681b      	ldr	r3, [r3, #0]
341892b4:	2b01      	cmp	r3, #1
341892b6:	d10e      	bne.n	341892d6 <UTIL_LCD_FillRect+0x86>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB888(Color));
341892b8:	4b24      	ldr	r3, [pc, #144]	@ (3418934c <UTIL_LCD_FillRect+0xfc>)
341892ba:	691c      	ldr	r4, [r3, #16]
341892bc:	4b22      	ldr	r3, [pc, #136]	@ (34189348 <UTIL_LCD_FillRect+0xf8>)
341892be:	6918      	ldr	r0, [r3, #16]
341892c0:	6a3b      	ldr	r3, [r7, #32]
341892c2:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
341892c6:	9301      	str	r3, [sp, #4]
341892c8:	683b      	ldr	r3, [r7, #0]
341892ca:	9300      	str	r3, [sp, #0]
341892cc:	687b      	ldr	r3, [r7, #4]
341892ce:	68ba      	ldr	r2, [r7, #8]
341892d0:	68f9      	ldr	r1, [r7, #12]
341892d2:	47a0      	blx	r4
}
341892d4:	e033      	b.n	3418933e <UTIL_LCD_FillRect+0xee>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
341892d6:	4b1c      	ldr	r3, [pc, #112]	@ (34189348 <UTIL_LCD_FillRect+0xf8>)
341892d8:	68db      	ldr	r3, [r3, #12]
341892da:	4a1b      	ldr	r2, [pc, #108]	@ (34189348 <UTIL_LCD_FillRect+0xf8>)
341892dc:	015b      	lsls	r3, r3, #5
341892de:	4413      	add	r3, r2
341892e0:	331c      	adds	r3, #28
341892e2:	681b      	ldr	r3, [r3, #0]
341892e4:	2b04      	cmp	r3, #4
341892e6:	d11e      	bne.n	34189326 <UTIL_LCD_FillRect+0xd6>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882ARGB4444(Color));
341892e8:	4b18      	ldr	r3, [pc, #96]	@ (3418934c <UTIL_LCD_FillRect+0xfc>)
341892ea:	691c      	ldr	r4, [r3, #16]
341892ec:	4b16      	ldr	r3, [pc, #88]	@ (34189348 <UTIL_LCD_FillRect+0xf8>)
341892ee:	6918      	ldr	r0, [r3, #16]
341892f0:	6a3b      	ldr	r3, [r7, #32]
341892f2:	091b      	lsrs	r3, r3, #4
341892f4:	f003 020f 	and.w	r2, r3, #15
341892f8:	6a3b      	ldr	r3, [r7, #32]
341892fa:	0b1b      	lsrs	r3, r3, #12
341892fc:	011b      	lsls	r3, r3, #4
341892fe:	b2db      	uxtb	r3, r3
34189300:	431a      	orrs	r2, r3
34189302:	6a3b      	ldr	r3, [r7, #32]
34189304:	0d1b      	lsrs	r3, r3, #20
34189306:	021b      	lsls	r3, r3, #8
34189308:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3418930c:	431a      	orrs	r2, r3
3418930e:	6a3b      	ldr	r3, [r7, #32]
34189310:	0f1b      	lsrs	r3, r3, #28
34189312:	031b      	lsls	r3, r3, #12
34189314:	4313      	orrs	r3, r2
34189316:	9301      	str	r3, [sp, #4]
34189318:	683b      	ldr	r3, [r7, #0]
3418931a:	9300      	str	r3, [sp, #0]
3418931c:	687b      	ldr	r3, [r7, #4]
3418931e:	68ba      	ldr	r2, [r7, #8]
34189320:	68f9      	ldr	r1, [r7, #12]
34189322:	47a0      	blx	r4
}
34189324:	e00b      	b.n	3418933e <UTIL_LCD_FillRect+0xee>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
34189326:	4b09      	ldr	r3, [pc, #36]	@ (3418934c <UTIL_LCD_FillRect+0xfc>)
34189328:	691c      	ldr	r4, [r3, #16]
3418932a:	4b07      	ldr	r3, [pc, #28]	@ (34189348 <UTIL_LCD_FillRect+0xf8>)
3418932c:	6918      	ldr	r0, [r3, #16]
3418932e:	6a3b      	ldr	r3, [r7, #32]
34189330:	9301      	str	r3, [sp, #4]
34189332:	683b      	ldr	r3, [r7, #0]
34189334:	9300      	str	r3, [sp, #0]
34189336:	687b      	ldr	r3, [r7, #4]
34189338:	68ba      	ldr	r2, [r7, #8]
3418933a:	68f9      	ldr	r1, [r7, #12]
3418933c:	47a0      	blx	r4
}
3418933e:	bf00      	nop
34189340:	3714      	adds	r7, #20
34189342:	46bd      	mov	sp, r7
34189344:	bd90      	pop	{r4, r7, pc}
34189346:	bf00      	nop
34189348:	341c0180 	.word	0x341c0180
3418934c:	341c01c0 	.word	0x341c01c0

34189350 <DrawChar>:
  * @param  Xpos  Line where to display the character shape
  * @param  Ypos  Start column address
  * @param  pData Pointer to the character data
  */
static void DrawChar(uint32_t Xpos, uint32_t Ypos, const uint8_t *pData)
{
34189350:	b580      	push	{r7, lr}
34189352:	b0a8      	sub	sp, #160	@ 0xa0
34189354:	af02      	add	r7, sp, #8
34189356:	60f8      	str	r0, [r7, #12]
34189358:	60b9      	str	r1, [r7, #8]
3418935a:	607a      	str	r2, [r7, #4]
  uint32_t i = 0, j = 0, offset;
3418935c:	2300      	movs	r3, #0
3418935e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
34189362:	2300      	movs	r3, #0
34189364:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  uint32_t height, width;
  uint8_t  *pchar;
  uint32_t line;

  height = DrawProp[DrawProp->LcdLayer].pFont->Height;
34189368:	4ba0      	ldr	r3, [pc, #640]	@ (341895ec <DrawChar+0x29c>)
3418936a:	68db      	ldr	r3, [r3, #12]
3418936c:	4a9f      	ldr	r2, [pc, #636]	@ (341895ec <DrawChar+0x29c>)
3418936e:	015b      	lsls	r3, r3, #5
34189370:	4413      	add	r3, r2
34189372:	3308      	adds	r3, #8
34189374:	681b      	ldr	r3, [r3, #0]
34189376:	88db      	ldrh	r3, [r3, #6]
34189378:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
  width  = DrawProp[DrawProp->LcdLayer].pFont->Width;
3418937c:	4b9b      	ldr	r3, [pc, #620]	@ (341895ec <DrawChar+0x29c>)
3418937e:	68db      	ldr	r3, [r3, #12]
34189380:	4a9a      	ldr	r2, [pc, #616]	@ (341895ec <DrawChar+0x29c>)
34189382:	015b      	lsls	r3, r3, #5
34189384:	4413      	add	r3, r2
34189386:	3308      	adds	r3, #8
34189388:	681b      	ldr	r3, [r3, #0]
3418938a:	889b      	ldrh	r3, [r3, #4]
3418938c:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84

  uint8_t rgb8[24*4];
  uint16_t* rgb16 = (uint16_t*)rgb8;
34189390:	f107 0310 	add.w	r3, r7, #16
34189394:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  uint32_t* argb32 = (uint32_t*)rgb8;
34189398:	f107 0310 	add.w	r3, r7, #16
3418939c:	67fb      	str	r3, [r7, #124]	@ 0x7c
  uint16_t* argb4444 = (uint16_t*)rgb8;
3418939e:	f107 0310 	add.w	r3, r7, #16
341893a2:	67bb      	str	r3, [r7, #120]	@ 0x78

  offset =  8 *((width + 7)/8) -  width ;
341893a4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341893a8:	3307      	adds	r3, #7
341893aa:	f023 0207 	bic.w	r2, r3, #7
341893ae:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341893b2:	1ad3      	subs	r3, r2, r3
341893b4:	677b      	str	r3, [r7, #116]	@ 0x74

  for(i = 0; i < height; i++)
341893b6:	2300      	movs	r3, #0
341893b8:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
341893bc:	e260      	b.n	34189880 <DrawChar+0x530>
  {
    pchar = ((uint8_t *)pData + (width + 7)/8 * i);
341893be:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341893c2:	3307      	adds	r3, #7
341893c4:	08db      	lsrs	r3, r3, #3
341893c6:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
341893ca:	fb02 f303 	mul.w	r3, r2, r3
341893ce:	687a      	ldr	r2, [r7, #4]
341893d0:	4413      	add	r3, r2
341893d2:	673b      	str	r3, [r7, #112]	@ 0x70

    switch(((width + 7)/8))
341893d4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341893d8:	3307      	adds	r3, #7
341893da:	08db      	lsrs	r3, r3, #3
341893dc:	2b01      	cmp	r3, #1
341893de:	d002      	beq.n	341893e6 <DrawChar+0x96>
341893e0:	2b02      	cmp	r3, #2
341893e2:	d005      	beq.n	341893f0 <DrawChar+0xa0>
341893e4:	e00e      	b.n	34189404 <DrawChar+0xb4>
    {

    case 1:
      line =  pchar[0];
341893e6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
341893e8:	781b      	ldrb	r3, [r3, #0]
341893ea:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
      break;
341893ee:	e018      	b.n	34189422 <DrawChar+0xd2>

    case 2:
      line =  (pchar[0]<< 8) | pchar[1];
341893f0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
341893f2:	781b      	ldrb	r3, [r3, #0]
341893f4:	021b      	lsls	r3, r3, #8
341893f6:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
341893f8:	3201      	adds	r2, #1
341893fa:	7812      	ldrb	r2, [r2, #0]
341893fc:	4313      	orrs	r3, r2
341893fe:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
      break;
34189402:	e00e      	b.n	34189422 <DrawChar+0xd2>

    case 3:
    default:
      line =  (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];
34189404:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34189406:	781b      	ldrb	r3, [r3, #0]
34189408:	041a      	lsls	r2, r3, #16
3418940a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3418940c:	3301      	adds	r3, #1
3418940e:	781b      	ldrb	r3, [r3, #0]
34189410:	021b      	lsls	r3, r3, #8
34189412:	4313      	orrs	r3, r2
34189414:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
34189416:	3202      	adds	r2, #2
34189418:	7812      	ldrb	r2, [r2, #0]
3418941a:	4313      	orrs	r3, r2
3418941c:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
      break;
34189420:	bf00      	nop
    }

    if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34189422:	4b72      	ldr	r3, [pc, #456]	@ (341895ec <DrawChar+0x29c>)
34189424:	68db      	ldr	r3, [r3, #12]
34189426:	4a71      	ldr	r2, [pc, #452]	@ (341895ec <DrawChar+0x29c>)
34189428:	015b      	lsls	r3, r3, #5
3418942a:	4413      	add	r3, r2
3418942c:	331c      	adds	r3, #28
3418942e:	681b      	ldr	r3, [r3, #0]
34189430:	2b02      	cmp	r3, #2
34189432:	f040 808b 	bne.w	3418954c <DrawChar+0x1fc>
    {
      for (j = 0; j < width; j++)
34189436:	2300      	movs	r3, #0
34189438:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
3418943c:	e073      	b.n	34189526 <DrawChar+0x1d6>
      {
        if(line & (1 << (width- j + offset- 1)))
3418943e:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34189442:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34189446:	1ad2      	subs	r2, r2, r3
34189448:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3418944a:	4413      	add	r3, r2
3418944c:	3b01      	subs	r3, #1
3418944e:	2201      	movs	r2, #1
34189450:	fa02 f303 	lsl.w	r3, r2, r3
34189454:	461a      	mov	r2, r3
34189456:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3418945a:	4013      	ands	r3, r2
3418945c:	2b00      	cmp	r3, #0
3418945e:	d02d      	beq.n	341894bc <DrawChar+0x16c>
        {
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].TextColor);
34189460:	4b62      	ldr	r3, [pc, #392]	@ (341895ec <DrawChar+0x29c>)
34189462:	68db      	ldr	r3, [r3, #12]
34189464:	4a61      	ldr	r2, [pc, #388]	@ (341895ec <DrawChar+0x29c>)
34189466:	015b      	lsls	r3, r3, #5
34189468:	4413      	add	r3, r2
3418946a:	681b      	ldr	r3, [r3, #0]
3418946c:	08db      	lsrs	r3, r3, #3
3418946e:	b29b      	uxth	r3, r3
34189470:	f003 031f 	and.w	r3, r3, #31
34189474:	b29a      	uxth	r2, r3
34189476:	4b5d      	ldr	r3, [pc, #372]	@ (341895ec <DrawChar+0x29c>)
34189478:	68db      	ldr	r3, [r3, #12]
3418947a:	495c      	ldr	r1, [pc, #368]	@ (341895ec <DrawChar+0x29c>)
3418947c:	015b      	lsls	r3, r3, #5
3418947e:	440b      	add	r3, r1
34189480:	681b      	ldr	r3, [r3, #0]
34189482:	0a9b      	lsrs	r3, r3, #10
34189484:	b29b      	uxth	r3, r3
34189486:	015b      	lsls	r3, r3, #5
34189488:	b29b      	uxth	r3, r3
3418948a:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
3418948e:	b29b      	uxth	r3, r3
34189490:	4313      	orrs	r3, r2
34189492:	b299      	uxth	r1, r3
34189494:	4b55      	ldr	r3, [pc, #340]	@ (341895ec <DrawChar+0x29c>)
34189496:	68db      	ldr	r3, [r3, #12]
34189498:	4a54      	ldr	r2, [pc, #336]	@ (341895ec <DrawChar+0x29c>)
3418949a:	015b      	lsls	r3, r3, #5
3418949c:	4413      	add	r3, r2
3418949e:	681b      	ldr	r3, [r3, #0]
341894a0:	0cdb      	lsrs	r3, r3, #19
341894a2:	b29b      	uxth	r3, r3
341894a4:	02db      	lsls	r3, r3, #11
341894a6:	b29a      	uxth	r2, r3
341894a8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341894ac:	005b      	lsls	r3, r3, #1
341894ae:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
341894b2:	4403      	add	r3, r0
341894b4:	430a      	orrs	r2, r1
341894b6:	b292      	uxth	r2, r2
341894b8:	801a      	strh	r2, [r3, #0]
341894ba:	e02f      	b.n	3418951c <DrawChar+0x1cc>
        }
        else
        {
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].BackColor);
341894bc:	4b4b      	ldr	r3, [pc, #300]	@ (341895ec <DrawChar+0x29c>)
341894be:	68db      	ldr	r3, [r3, #12]
341894c0:	4a4a      	ldr	r2, [pc, #296]	@ (341895ec <DrawChar+0x29c>)
341894c2:	015b      	lsls	r3, r3, #5
341894c4:	4413      	add	r3, r2
341894c6:	3304      	adds	r3, #4
341894c8:	681b      	ldr	r3, [r3, #0]
341894ca:	08db      	lsrs	r3, r3, #3
341894cc:	b29b      	uxth	r3, r3
341894ce:	f003 031f 	and.w	r3, r3, #31
341894d2:	b29a      	uxth	r2, r3
341894d4:	4b45      	ldr	r3, [pc, #276]	@ (341895ec <DrawChar+0x29c>)
341894d6:	68db      	ldr	r3, [r3, #12]
341894d8:	4944      	ldr	r1, [pc, #272]	@ (341895ec <DrawChar+0x29c>)
341894da:	015b      	lsls	r3, r3, #5
341894dc:	440b      	add	r3, r1
341894de:	3304      	adds	r3, #4
341894e0:	681b      	ldr	r3, [r3, #0]
341894e2:	0a9b      	lsrs	r3, r3, #10
341894e4:	b29b      	uxth	r3, r3
341894e6:	015b      	lsls	r3, r3, #5
341894e8:	b29b      	uxth	r3, r3
341894ea:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
341894ee:	b29b      	uxth	r3, r3
341894f0:	4313      	orrs	r3, r2
341894f2:	b299      	uxth	r1, r3
341894f4:	4b3d      	ldr	r3, [pc, #244]	@ (341895ec <DrawChar+0x29c>)
341894f6:	68db      	ldr	r3, [r3, #12]
341894f8:	4a3c      	ldr	r2, [pc, #240]	@ (341895ec <DrawChar+0x29c>)
341894fa:	015b      	lsls	r3, r3, #5
341894fc:	4413      	add	r3, r2
341894fe:	3304      	adds	r3, #4
34189500:	681b      	ldr	r3, [r3, #0]
34189502:	0cdb      	lsrs	r3, r3, #19
34189504:	b29b      	uxth	r3, r3
34189506:	02db      	lsls	r3, r3, #11
34189508:	b29a      	uxth	r2, r3
3418950a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3418950e:	005b      	lsls	r3, r3, #1
34189510:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
34189514:	4403      	add	r3, r0
34189516:	430a      	orrs	r2, r1
34189518:	b292      	uxth	r2, r2
3418951a:	801a      	strh	r2, [r3, #0]
      for (j = 0; j < width; j++)
3418951c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34189520:	3301      	adds	r3, #1
34189522:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34189526:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
3418952a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418952e:	429a      	cmp	r2, r3
34189530:	d385      	bcc.n	3418943e <DrawChar+0xee>
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
34189532:	68b9      	ldr	r1, [r7, #8]
34189534:	1c4b      	adds	r3, r1, #1
34189536:	60bb      	str	r3, [r7, #8]
34189538:	f107 0210 	add.w	r2, r7, #16
3418953c:	2301      	movs	r3, #1
3418953e:	9300      	str	r3, [sp, #0]
34189540:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34189544:	68f8      	ldr	r0, [r7, #12]
34189546:	f7ff fd59 	bl	34188ffc <UTIL_LCD_FillRGBRect>
3418954a:	e194      	b.n	34189876 <DrawChar+0x526>
    }
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
3418954c:	4b27      	ldr	r3, [pc, #156]	@ (341895ec <DrawChar+0x29c>)
3418954e:	68db      	ldr	r3, [r3, #12]
34189550:	4a26      	ldr	r2, [pc, #152]	@ (341895ec <DrawChar+0x29c>)
34189552:	015b      	lsls	r3, r3, #5
34189554:	4413      	add	r3, r2
34189556:	331c      	adds	r3, #28
34189558:	681b      	ldr	r3, [r3, #0]
3418955a:	2b01      	cmp	r3, #1
3418955c:	f040 8095 	bne.w	3418968a <DrawChar+0x33a>
    {
      for (j = 0; j < width*3; j = j+ 3)
34189560:	2300      	movs	r3, #0
34189562:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34189566:	e079      	b.n	3418965c <DrawChar+0x30c>
      {
        if(line & (1 << (width- j/3 + offset- 1)))
34189568:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3418956c:	4a20      	ldr	r2, [pc, #128]	@ (341895f0 <DrawChar+0x2a0>)
3418956e:	fba2 2303 	umull	r2, r3, r2, r3
34189572:	085b      	lsrs	r3, r3, #1
34189574:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34189578:	1ad2      	subs	r2, r2, r3
3418957a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3418957c:	4413      	add	r3, r2
3418957e:	3b01      	subs	r3, #1
34189580:	2201      	movs	r2, #1
34189582:	fa02 f303 	lsl.w	r3, r2, r3
34189586:	461a      	mov	r2, r3
34189588:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3418958c:	4013      	ands	r3, r2
3418958e:	2b00      	cmp	r3, #0
34189590:	d030      	beq.n	341895f4 <DrawChar+0x2a4>
        {
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) & 0xFFU;
34189592:	4b16      	ldr	r3, [pc, #88]	@ (341895ec <DrawChar+0x29c>)
34189594:	68db      	ldr	r3, [r3, #12]
34189596:	4a15      	ldr	r2, [pc, #84]	@ (341895ec <DrawChar+0x29c>)
34189598:	015b      	lsls	r3, r3, #5
3418959a:	4413      	add	r3, r2
3418959c:	681b      	ldr	r3, [r3, #0]
3418959e:	b2d9      	uxtb	r1, r3
341895a0:	f107 0210 	add.w	r2, r7, #16
341895a4:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341895a8:	4413      	add	r3, r2
341895aa:	460a      	mov	r2, r1
341895ac:	701a      	strb	r2, [r3, #0]
          rgb8[j + 1U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) >> 8) & 0xFFU;
341895ae:	4b0f      	ldr	r3, [pc, #60]	@ (341895ec <DrawChar+0x29c>)
341895b0:	68db      	ldr	r3, [r3, #12]
341895b2:	4a0e      	ldr	r2, [pc, #56]	@ (341895ec <DrawChar+0x29c>)
341895b4:	015b      	lsls	r3, r3, #5
341895b6:	4413      	add	r3, r2
341895b8:	681b      	ldr	r3, [r3, #0]
341895ba:	0a1a      	lsrs	r2, r3, #8
341895bc:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341895c0:	3301      	adds	r3, #1
341895c2:	b2d2      	uxtb	r2, r2
341895c4:	3398      	adds	r3, #152	@ 0x98
341895c6:	443b      	add	r3, r7
341895c8:	f803 2c88 	strb.w	r2, [r3, #-136]
          rgb8[j + 2U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) >> 16) & 0xFFU;
341895cc:	4b07      	ldr	r3, [pc, #28]	@ (341895ec <DrawChar+0x29c>)
341895ce:	68db      	ldr	r3, [r3, #12]
341895d0:	4a06      	ldr	r2, [pc, #24]	@ (341895ec <DrawChar+0x29c>)
341895d2:	015b      	lsls	r3, r3, #5
341895d4:	4413      	add	r3, r2
341895d6:	681b      	ldr	r3, [r3, #0]
341895d8:	0c1a      	lsrs	r2, r3, #16
341895da:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341895de:	3302      	adds	r3, #2
341895e0:	b2d2      	uxtb	r2, r2
341895e2:	3398      	adds	r3, #152	@ 0x98
341895e4:	443b      	add	r3, r7
341895e6:	f803 2c88 	strb.w	r2, [r3, #-136]
341895ea:	e032      	b.n	34189652 <DrawChar+0x302>
341895ec:	341c0180 	.word	0x341c0180
341895f0:	aaaaaaab 	.word	0xaaaaaaab
        }
        else
        {
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) & 0xFFU;
341895f4:	4ba8      	ldr	r3, [pc, #672]	@ (34189898 <DrawChar+0x548>)
341895f6:	68db      	ldr	r3, [r3, #12]
341895f8:	4aa7      	ldr	r2, [pc, #668]	@ (34189898 <DrawChar+0x548>)
341895fa:	015b      	lsls	r3, r3, #5
341895fc:	4413      	add	r3, r2
341895fe:	3304      	adds	r3, #4
34189600:	681b      	ldr	r3, [r3, #0]
34189602:	b2d9      	uxtb	r1, r3
34189604:	f107 0210 	add.w	r2, r7, #16
34189608:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3418960c:	4413      	add	r3, r2
3418960e:	460a      	mov	r2, r1
34189610:	701a      	strb	r2, [r3, #0]
          rgb8[j + 1U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) >> 8) & 0xFFU;
34189612:	4ba1      	ldr	r3, [pc, #644]	@ (34189898 <DrawChar+0x548>)
34189614:	68db      	ldr	r3, [r3, #12]
34189616:	4aa0      	ldr	r2, [pc, #640]	@ (34189898 <DrawChar+0x548>)
34189618:	015b      	lsls	r3, r3, #5
3418961a:	4413      	add	r3, r2
3418961c:	3304      	adds	r3, #4
3418961e:	681b      	ldr	r3, [r3, #0]
34189620:	0a1a      	lsrs	r2, r3, #8
34189622:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34189626:	3301      	adds	r3, #1
34189628:	b2d2      	uxtb	r2, r2
3418962a:	3398      	adds	r3, #152	@ 0x98
3418962c:	443b      	add	r3, r7
3418962e:	f803 2c88 	strb.w	r2, [r3, #-136]
          rgb8[j + 2U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) >> 16) & 0xFFU;
34189632:	4b99      	ldr	r3, [pc, #612]	@ (34189898 <DrawChar+0x548>)
34189634:	68db      	ldr	r3, [r3, #12]
34189636:	4a98      	ldr	r2, [pc, #608]	@ (34189898 <DrawChar+0x548>)
34189638:	015b      	lsls	r3, r3, #5
3418963a:	4413      	add	r3, r2
3418963c:	3304      	adds	r3, #4
3418963e:	681b      	ldr	r3, [r3, #0]
34189640:	0c1a      	lsrs	r2, r3, #16
34189642:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34189646:	3302      	adds	r3, #2
34189648:	b2d2      	uxtb	r2, r2
3418964a:	3398      	adds	r3, #152	@ 0x98
3418964c:	443b      	add	r3, r7
3418964e:	f803 2c88 	strb.w	r2, [r3, #-136]
      for (j = 0; j < width*3; j = j+ 3)
34189652:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34189656:	3303      	adds	r3, #3
34189658:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
3418965c:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34189660:	4613      	mov	r3, r2
34189662:	005b      	lsls	r3, r3, #1
34189664:	4413      	add	r3, r2
34189666:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
3418966a:	429a      	cmp	r2, r3
3418966c:	f4ff af7c 	bcc.w	34189568 <DrawChar+0x218>
        }
      }

      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
34189670:	68b9      	ldr	r1, [r7, #8]
34189672:	1c4b      	adds	r3, r1, #1
34189674:	60bb      	str	r3, [r7, #8]
34189676:	f107 0210 	add.w	r2, r7, #16
3418967a:	2301      	movs	r3, #1
3418967c:	9300      	str	r3, [sp, #0]
3418967e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34189682:	68f8      	ldr	r0, [r7, #12]
34189684:	f7ff fcba 	bl	34188ffc <UTIL_LCD_FillRGBRect>
34189688:	e0f5      	b.n	34189876 <DrawChar+0x526>
    }
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
3418968a:	4b83      	ldr	r3, [pc, #524]	@ (34189898 <DrawChar+0x548>)
3418968c:	68db      	ldr	r3, [r3, #12]
3418968e:	4a82      	ldr	r2, [pc, #520]	@ (34189898 <DrawChar+0x548>)
34189690:	015b      	lsls	r3, r3, #5
34189692:	4413      	add	r3, r2
34189694:	331c      	adds	r3, #28
34189696:	681b      	ldr	r3, [r3, #0]
34189698:	2b04      	cmp	r3, #4
3418969a:	f040 80a6 	bne.w	341897ea <DrawChar+0x49a>
    {
      for (j = 0; j < width; j++)
3418969e:	2300      	movs	r3, #0
341896a0:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
341896a4:	e08e      	b.n	341897c4 <DrawChar+0x474>
      {
        if(line & (1 << (width- j + offset- 1)))
341896a6:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
341896aa:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341896ae:	1ad2      	subs	r2, r2, r3
341896b0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
341896b2:	4413      	add	r3, r2
341896b4:	3b01      	subs	r3, #1
341896b6:	2201      	movs	r2, #1
341896b8:	fa02 f303 	lsl.w	r3, r2, r3
341896bc:	461a      	mov	r2, r3
341896be:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
341896c2:	4013      	ands	r3, r2
341896c4:	2b00      	cmp	r3, #0
341896c6:	d03a      	beq.n	3418973e <DrawChar+0x3ee>
        {
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].TextColor);
341896c8:	4b73      	ldr	r3, [pc, #460]	@ (34189898 <DrawChar+0x548>)
341896ca:	68db      	ldr	r3, [r3, #12]
341896cc:	4a72      	ldr	r2, [pc, #456]	@ (34189898 <DrawChar+0x548>)
341896ce:	015b      	lsls	r3, r3, #5
341896d0:	4413      	add	r3, r2
341896d2:	681b      	ldr	r3, [r3, #0]
341896d4:	091b      	lsrs	r3, r3, #4
341896d6:	b29b      	uxth	r3, r3
341896d8:	f003 030f 	and.w	r3, r3, #15
341896dc:	b29a      	uxth	r2, r3
341896de:	4b6e      	ldr	r3, [pc, #440]	@ (34189898 <DrawChar+0x548>)
341896e0:	68db      	ldr	r3, [r3, #12]
341896e2:	496d      	ldr	r1, [pc, #436]	@ (34189898 <DrawChar+0x548>)
341896e4:	015b      	lsls	r3, r3, #5
341896e6:	440b      	add	r3, r1
341896e8:	681b      	ldr	r3, [r3, #0]
341896ea:	0b1b      	lsrs	r3, r3, #12
341896ec:	b29b      	uxth	r3, r3
341896ee:	011b      	lsls	r3, r3, #4
341896f0:	b29b      	uxth	r3, r3
341896f2:	b2db      	uxtb	r3, r3
341896f4:	b29b      	uxth	r3, r3
341896f6:	4313      	orrs	r3, r2
341896f8:	b29a      	uxth	r2, r3
341896fa:	4b67      	ldr	r3, [pc, #412]	@ (34189898 <DrawChar+0x548>)
341896fc:	68db      	ldr	r3, [r3, #12]
341896fe:	4966      	ldr	r1, [pc, #408]	@ (34189898 <DrawChar+0x548>)
34189700:	015b      	lsls	r3, r3, #5
34189702:	440b      	add	r3, r1
34189704:	681b      	ldr	r3, [r3, #0]
34189706:	0d1b      	lsrs	r3, r3, #20
34189708:	b29b      	uxth	r3, r3
3418970a:	021b      	lsls	r3, r3, #8
3418970c:	b29b      	uxth	r3, r3
3418970e:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34189712:	b29b      	uxth	r3, r3
34189714:	4313      	orrs	r3, r2
34189716:	b299      	uxth	r1, r3
34189718:	4b5f      	ldr	r3, [pc, #380]	@ (34189898 <DrawChar+0x548>)
3418971a:	68db      	ldr	r3, [r3, #12]
3418971c:	4a5e      	ldr	r2, [pc, #376]	@ (34189898 <DrawChar+0x548>)
3418971e:	015b      	lsls	r3, r3, #5
34189720:	4413      	add	r3, r2
34189722:	681b      	ldr	r3, [r3, #0]
34189724:	0f1b      	lsrs	r3, r3, #28
34189726:	b29b      	uxth	r3, r3
34189728:	031b      	lsls	r3, r3, #12
3418972a:	b29a      	uxth	r2, r3
3418972c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34189730:	005b      	lsls	r3, r3, #1
34189732:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
34189734:	4403      	add	r3, r0
34189736:	430a      	orrs	r2, r1
34189738:	b292      	uxth	r2, r2
3418973a:	801a      	strh	r2, [r3, #0]
3418973c:	e03d      	b.n	341897ba <DrawChar+0x46a>
        }
        else
        {
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].BackColor);
3418973e:	4b56      	ldr	r3, [pc, #344]	@ (34189898 <DrawChar+0x548>)
34189740:	68db      	ldr	r3, [r3, #12]
34189742:	4a55      	ldr	r2, [pc, #340]	@ (34189898 <DrawChar+0x548>)
34189744:	015b      	lsls	r3, r3, #5
34189746:	4413      	add	r3, r2
34189748:	3304      	adds	r3, #4
3418974a:	681b      	ldr	r3, [r3, #0]
3418974c:	091b      	lsrs	r3, r3, #4
3418974e:	b29b      	uxth	r3, r3
34189750:	f003 030f 	and.w	r3, r3, #15
34189754:	b29a      	uxth	r2, r3
34189756:	4b50      	ldr	r3, [pc, #320]	@ (34189898 <DrawChar+0x548>)
34189758:	68db      	ldr	r3, [r3, #12]
3418975a:	494f      	ldr	r1, [pc, #316]	@ (34189898 <DrawChar+0x548>)
3418975c:	015b      	lsls	r3, r3, #5
3418975e:	440b      	add	r3, r1
34189760:	3304      	adds	r3, #4
34189762:	681b      	ldr	r3, [r3, #0]
34189764:	0b1b      	lsrs	r3, r3, #12
34189766:	b29b      	uxth	r3, r3
34189768:	011b      	lsls	r3, r3, #4
3418976a:	b29b      	uxth	r3, r3
3418976c:	b2db      	uxtb	r3, r3
3418976e:	b29b      	uxth	r3, r3
34189770:	4313      	orrs	r3, r2
34189772:	b29a      	uxth	r2, r3
34189774:	4b48      	ldr	r3, [pc, #288]	@ (34189898 <DrawChar+0x548>)
34189776:	68db      	ldr	r3, [r3, #12]
34189778:	4947      	ldr	r1, [pc, #284]	@ (34189898 <DrawChar+0x548>)
3418977a:	015b      	lsls	r3, r3, #5
3418977c:	440b      	add	r3, r1
3418977e:	3304      	adds	r3, #4
34189780:	681b      	ldr	r3, [r3, #0]
34189782:	0d1b      	lsrs	r3, r3, #20
34189784:	b29b      	uxth	r3, r3
34189786:	021b      	lsls	r3, r3, #8
34189788:	b29b      	uxth	r3, r3
3418978a:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3418978e:	b29b      	uxth	r3, r3
34189790:	4313      	orrs	r3, r2
34189792:	b299      	uxth	r1, r3
34189794:	4b40      	ldr	r3, [pc, #256]	@ (34189898 <DrawChar+0x548>)
34189796:	68db      	ldr	r3, [r3, #12]
34189798:	4a3f      	ldr	r2, [pc, #252]	@ (34189898 <DrawChar+0x548>)
3418979a:	015b      	lsls	r3, r3, #5
3418979c:	4413      	add	r3, r2
3418979e:	3304      	adds	r3, #4
341897a0:	681b      	ldr	r3, [r3, #0]
341897a2:	0f1b      	lsrs	r3, r3, #28
341897a4:	b29b      	uxth	r3, r3
341897a6:	031b      	lsls	r3, r3, #12
341897a8:	b29a      	uxth	r2, r3
341897aa:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341897ae:	005b      	lsls	r3, r3, #1
341897b0:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
341897b2:	4403      	add	r3, r0
341897b4:	430a      	orrs	r2, r1
341897b6:	b292      	uxth	r2, r2
341897b8:	801a      	strh	r2, [r3, #0]
      for (j = 0; j < width; j++)
341897ba:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341897be:	3301      	adds	r3, #1
341897c0:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
341897c4:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
341897c8:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341897cc:	429a      	cmp	r2, r3
341897ce:	f4ff af6a 	bcc.w	341896a6 <DrawChar+0x356>
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, (uint8_t*)&argb4444[0], width, 1);
341897d2:	68b9      	ldr	r1, [r7, #8]
341897d4:	1c4b      	adds	r3, r1, #1
341897d6:	60bb      	str	r3, [r7, #8]
341897d8:	2301      	movs	r3, #1
341897da:	9300      	str	r3, [sp, #0]
341897dc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341897e0:	6fba      	ldr	r2, [r7, #120]	@ 0x78
341897e2:	68f8      	ldr	r0, [r7, #12]
341897e4:	f7ff fc0a 	bl	34188ffc <UTIL_LCD_FillRGBRect>
341897e8:	e045      	b.n	34189876 <DrawChar+0x526>
    }
    else /*LCD_PIXEL_FORMAT_ARGB888*/
    {
      for (j = 0; j < width; j++)
341897ea:	2300      	movs	r3, #0
341897ec:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
341897f0:	e02f      	b.n	34189852 <DrawChar+0x502>
      {
        if(line & (1 << (width- j + offset- 1)))
341897f2:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
341897f6:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341897fa:	1ad2      	subs	r2, r2, r3
341897fc:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
341897fe:	4413      	add	r3, r2
34189800:	3b01      	subs	r3, #1
34189802:	2201      	movs	r2, #1
34189804:	fa02 f303 	lsl.w	r3, r2, r3
34189808:	461a      	mov	r2, r3
3418980a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3418980e:	4013      	ands	r3, r2
34189810:	2b00      	cmp	r3, #0
34189812:	d00c      	beq.n	3418982e <DrawChar+0x4de>
        {
          argb32[j] = DrawProp[DrawProp->LcdLayer].TextColor;
34189814:	4b20      	ldr	r3, [pc, #128]	@ (34189898 <DrawChar+0x548>)
34189816:	68da      	ldr	r2, [r3, #12]
34189818:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3418981c:	009b      	lsls	r3, r3, #2
3418981e:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
34189820:	440b      	add	r3, r1
34189822:	491d      	ldr	r1, [pc, #116]	@ (34189898 <DrawChar+0x548>)
34189824:	0152      	lsls	r2, r2, #5
34189826:	440a      	add	r2, r1
34189828:	6812      	ldr	r2, [r2, #0]
3418982a:	601a      	str	r2, [r3, #0]
3418982c:	e00c      	b.n	34189848 <DrawChar+0x4f8>
        }
        else
        {
          argb32[j] = DrawProp[DrawProp->LcdLayer].BackColor;
3418982e:	4b1a      	ldr	r3, [pc, #104]	@ (34189898 <DrawChar+0x548>)
34189830:	68da      	ldr	r2, [r3, #12]
34189832:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34189836:	009b      	lsls	r3, r3, #2
34189838:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
3418983a:	440b      	add	r3, r1
3418983c:	4916      	ldr	r1, [pc, #88]	@ (34189898 <DrawChar+0x548>)
3418983e:	0152      	lsls	r2, r2, #5
34189840:	440a      	add	r2, r1
34189842:	3204      	adds	r2, #4
34189844:	6812      	ldr	r2, [r2, #0]
34189846:	601a      	str	r2, [r3, #0]
      for (j = 0; j < width; j++)
34189848:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3418984c:	3301      	adds	r3, #1
3418984e:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34189852:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
34189856:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418985a:	429a      	cmp	r2, r3
3418985c:	d3c9      	bcc.n	341897f2 <DrawChar+0x4a2>
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
3418985e:	68b9      	ldr	r1, [r7, #8]
34189860:	1c4b      	adds	r3, r1, #1
34189862:	60bb      	str	r3, [r7, #8]
34189864:	f107 0210 	add.w	r2, r7, #16
34189868:	2301      	movs	r3, #1
3418986a:	9300      	str	r3, [sp, #0]
3418986c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34189870:	68f8      	ldr	r0, [r7, #12]
34189872:	f7ff fbc3 	bl	34188ffc <UTIL_LCD_FillRGBRect>
  for(i = 0; i < height; i++)
34189876:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
3418987a:	3301      	adds	r3, #1
3418987c:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
34189880:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
34189884:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
34189888:	429a      	cmp	r2, r3
3418988a:	f4ff ad98 	bcc.w	341893be <DrawChar+0x6e>
    }
  }
}
3418988e:	bf00      	nop
34189890:	bf00      	nop
34189892:	3798      	adds	r7, #152	@ 0x98
34189894:	46bd      	mov	sp, r7
34189896:	bd80      	pop	{r7, pc}
34189898:	341c0180 	.word	0x341c0180

3418989c <memset>:
3418989c:	4402      	add	r2, r0
3418989e:	4603      	mov	r3, r0
341898a0:	4293      	cmp	r3, r2
341898a2:	d100      	bne.n	341898a6 <memset+0xa>
341898a4:	4770      	bx	lr
341898a6:	f803 1b01 	strb.w	r1, [r3], #1
341898aa:	e7f9      	b.n	341898a0 <memset+0x4>

341898ac <__libc_init_array>:
341898ac:	b570      	push	{r4, r5, r6, lr}
341898ae:	4d0d      	ldr	r5, [pc, #52]	@ (341898e4 <__libc_init_array+0x38>)
341898b0:	2600      	movs	r6, #0
341898b2:	4c0d      	ldr	r4, [pc, #52]	@ (341898e8 <__libc_init_array+0x3c>)
341898b4:	1b64      	subs	r4, r4, r5
341898b6:	10a4      	asrs	r4, r4, #2
341898b8:	42a6      	cmp	r6, r4
341898ba:	d109      	bne.n	341898d0 <__libc_init_array+0x24>
341898bc:	4d0b      	ldr	r5, [pc, #44]	@ (341898ec <__libc_init_array+0x40>)
341898be:	2600      	movs	r6, #0
341898c0:	4c0b      	ldr	r4, [pc, #44]	@ (341898f0 <__libc_init_array+0x44>)
341898c2:	f000 f817 	bl	341898f4 <_init>
341898c6:	1b64      	subs	r4, r4, r5
341898c8:	10a4      	asrs	r4, r4, #2
341898ca:	42a6      	cmp	r6, r4
341898cc:	d105      	bne.n	341898da <__libc_init_array+0x2e>
341898ce:	bd70      	pop	{r4, r5, r6, pc}
341898d0:	f855 3b04 	ldr.w	r3, [r5], #4
341898d4:	3601      	adds	r6, #1
341898d6:	4798      	blx	r3
341898d8:	e7ee      	b.n	341898b8 <__libc_init_array+0xc>
341898da:	f855 3b04 	ldr.w	r3, [r5], #4
341898de:	3601      	adds	r6, #1
341898e0:	4798      	blx	r3
341898e2:	e7f2      	b.n	341898ca <__libc_init_array+0x1e>
341898e4:	3418c4a8 	.word	0x3418c4a8
341898e8:	3418c4a8 	.word	0x3418c4a8
341898ec:	3418c4a8 	.word	0x3418c4a8
341898f0:	3418c4ac 	.word	0x3418c4ac

341898f4 <_init>:
341898f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
341898f6:	bf00      	nop
341898f8:	bcf8      	pop	{r3, r4, r5, r6, r7}
341898fa:	bc08      	pop	{r3}
341898fc:	469e      	mov	lr, r3
341898fe:	4770      	bx	lr

34189900 <_fini>:
34189900:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34189902:	bf00      	nop
34189904:	bcf8      	pop	{r3, r4, r5, r6, r7}
34189906:	bc08      	pop	{r3}
34189908:	469e      	mov	lr, r3
3418990a:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

3418c4e0 <SECURE_SystemCoreClockUpdate>:
3418c4e0:	e97f e97f 	sg
3418c4e4:	f7f5 bdfe 	b.w	341820e4 <__acle_se_SECURE_SystemCoreClockUpdate>
	...
